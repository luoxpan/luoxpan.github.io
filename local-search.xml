<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Google-CPP风格指南</title>
    <link href="/2024/03/21/Google-CPP%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <url>/2024/03/21/Google-CPP%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Google-CPP风格指南"><a href="#Google-CPP风格指南" class="headerlink" title="Google-CPP风格指南"></a>Google-CPP风格指南</h1><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>通用规则：命名要有描述性，少用缩写</li><li>文件命名：小写+下划线 <code>my_logger.h</code></li><li>类型命名：给个单词首字母大写，不包含下划线 <code>MyExcitingClass</code></li><li>变量（包括函数参数）和数据成员名一律小写，单词之间用下划线连接 <code>string table_name</code> </li><li>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线.<code>string table_name_</code></li><li>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线</li><li>常量命名：以“k”开头，大小写混合。<code>const int kDaysInWeek</code></li><li>函数命名：取值和设值与变量名匹配<code>int count()</code>,<code>void set_count()</code>，小写+下划线</li><li>函数命名：常规函数使用大小写混合（驼峰命名）<code>AddTableEntry()</code></li></ol><h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h2><ol><li>使用<code>#define</code>防护符</li><li>代码文件引用了其他地方定义的符号时，该文件应该直接导入（include)提供该符号的声明头文件</li><li>尽量避免使用前向声明</li><li>只把10行以下的小函数定义为内联（inline)</li><li>推荐按照以下顺序导入头文件：配套的头文件，C语言系统库头文件，C++标准库头文件，其他库头文件，本项目的其他头文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FOO_SERVER_FOOSERVER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO_SERVER_FOOSERVER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;foo/server/fooserver.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;base/basictypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;foo/server/bar.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;third_party/absl/flags/flag.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//FOO_SERVER_FOOSERVER_H</span></span><br></code></pre></td></tr></table></figure><h2 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h2><ol><li>遵守命名空间命名规则</li><li>用注释给命名空间收尾</li></ol><p>目前没有接触较大的项目，使用作用域的机会较小。以后用到再来学习。</p><h3 id="3-类"><a href="#3-类" class="headerlink" title="3. 类"></a>3. 类</h3><ol><li>不在构造函数中做太多逻辑相关的初始化，考虑使用Init或工厂模式</li><li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li><li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li><li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <code>private</code> 且无需实现;</li><li>仅在作为数据集合时使用 <code>struct</code>;</li><li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <code>virtual</code> 关键字, 虽然编译器允许不这样做;</li><li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li><li>接口类类名以 <code>Interface</code> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 <code>protected</code>;</li><li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li><li>存取函数一般内联在头文件中;</li><li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt; <code>private</code>;</li><li>函数体尽量短小, 紧凑, 功能单一;</li></ol><h3 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h3><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code>std::unique_ptr</code> 来明确所有权传递, 例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">FooFactory</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FooConsumer</span><span class="hljs-params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code>std::shared_ptr&lt;const Foo&gt;</code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p><h3 id="5-Cpplint"><a href="#5-Cpplint" class="headerlink" title="5. Cpplint"></a>5. Cpplint</h3><p><code>cpplint.py</code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>, 或在上一行加 <code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p><p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>. 如果你参与的项目没有提供, 你可以单独下载 <a href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p><h3 id="6-其他C-特性"><a href="#6-其他C-特性" class="headerlink" title="6. 其他C++特性"></a>6. 其他C++特性</h3><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 <code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code> 来表示将值从一个对象移动而不是复制到另一个对象.</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等， 而不是一口气重载多个 <code>Append()</code>.</p><h4 id="缺省函数"><a href="#缺省函数" class="headerlink" title="缺省函数"></a>缺省函数</h4><p>不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>使用C++的类型转换，而不是使用C风格。例如<code>static_cast&lt;&gt;()</code> </p><h4 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h4><p>强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>不要使用变长数组和<code>alloca()</code> ，使用<code>vector&lt;&gt;</code>,<code>unique_ptr&lt;T[]&gt;</code>等替换</li><li>不要使用C++异常</li><li>不要使用运行时类型识别（RAII）</li><li>不要使用流，使用<code>printf(),fprintf(stderr,..)</code>等替代。</li><li>尽量以内联函数，枚举和常量代替预处理宏。</li></ol><h2 id="Pimpl（private-Implementation"><a href="#Pimpl（private-Implementation" class="headerlink" title="Pimpl（private Implementation)"></a>Pimpl（private Implementation)</h2><p>pimpl的优点：</p><ul><li>核心数据成员被隐藏：核心数据成员被隐藏，不必暴露在头文件中，对使用者透明，提高了安全性</li><li>降低编译依赖，提高编译速度</li><li>接口与实现分离</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//csocket_client.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span> <span class="hljs-comment">//for std::unique_ptr  </span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSocketClient</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSocketClient</span>():<span class="hljs-built_in">m_pImpl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;());<br>    ~<span class="hljs-built_in">CSocketClient</span>();<br><br>    <span class="hljs-comment">//其他功能函数</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span>                  <span class="hljs-title class_">Impl</span>;<br>    std::unique_ptr&lt;Impl&gt;   m_pImpl;<br>&#125;;<br><br><span class="hljs-comment">//csocket_client.cpp</span><br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">CSocketClient</span>::Impl<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-comment">//方法的具体实现</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//其他方法省略...</span><br>    <br><span class="hljs-keyword">public</span>:<br>SOCKET                          m_hSocket;<br>    <span class="hljs-type">short</span>                           m_nPort;<br>    <span class="hljs-type">char</span>                            m_szServer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">long</span>                            m_nLastDataTime;        <span class="hljs-comment">//最近一次收发数据的时间</span><br>    <span class="hljs-type">long</span>                            m_nHeartbeatInterval;   <span class="hljs-comment">//心跳包时间间隔，单位秒</span><br>    CRITICAL_SECTION                m_csLastDataTime;       <span class="hljs-comment">//保护m_nLastDataTime的互斥体 </span><br>    HANDLE                          m_hSendDataThread;      <span class="hljs-comment">//发送数据线程</span><br>    HANDLE                          m_hRecvDataThread;      <span class="hljs-comment">//接收数据线程</span><br>    std::string                     m_strSendBuf;<br>    std::string                     m_strRecvBuf;<br>    HANDLE                          m_hExitEvent;<br>    <span class="hljs-type">bool</span>                            m_bConnected;<br>    CRITICAL_SECTION                m_csSendBuf;<br>    HANDLE                          m_hSemaphoreSendBuf;<br>    HWND                            m_hProxyWnd;<br>    CNetProxy*                      m_pNetProxy;<br>    <span class="hljs-type">int</span>                             m_nReconnectTimeInterval;    <span class="hljs-comment">//重连时间间隔</span><br>    <span class="hljs-type">time_t</span>                          m_nLastReconnectTime;        <span class="hljs-comment">//上次重连时刻</span><br>    CFlowStatistics*                m_pFlowStatistics;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第二章</title>
    <link href="/2023/10/19/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/10/19/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="5-了解-C-默默编写并调用了哪些函数"><a href="#5-了解-C-默默编写并调用了哪些函数" class="headerlink" title="5.  了解 C++ 默默编写并调用了哪些函数"></a>5.  了解 C++ 默默编写并调用了哪些函数</h2><ul><li>编译器可以暗自为 class 创建 default 构造函数,copy 构造函数,copy assignment 操作符,以及析构函数.</li><li>如果你打算在一个”内含<code>reference</code>成员”的 class 内支持赋值操作,则必须自己定义复制构造函数和赋值操作符.同样,拥有 const 成员变量的类也必须自己定义复制和赋值函数.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//以下只是一个例子,真实场景中应尽量避免定义类成员函数为引用.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameObject</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NameObject</span>(string&amp; name,<span class="hljs-type">const</span> T&amp; value);<br><br><span class="hljs-keyword">private</span>:<br>    string &amp;name_value_;<br>    <span class="hljs-type">const</span> T object_value_;<br>&#125;;<br><span class="hljs-comment">//上面的情况请提供自定义的复制构造函数和赋值运算符重载.</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数-就该明确拒绝" class="headerlink" title="6. 若不想使用编译器自动生成的函数,就该明确拒绝"></a>6. 若不想使用编译器自动生成的函数,就该明确拒绝</h2><ul><li>如果你不希望某个对象具有复制的功能,应使用<code>delete</code>拒绝编译器自动帮你生成复制函数.</li><li>将copy和 copy assignment 函数声明为 private ,且不提供实现也可以,但没有使用<code>delete</code>直观<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>()&#123;&#125;<br>    ~<span class="hljs-built_in">HomeForSale</span>()&#123;&#125;<br><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;)=<span class="hljs-keyword">delete</span>;<br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;)=<span class="hljs-keyword">delete</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="7-为多态基类声明-virtual-析构函数"><a href="#7-为多态基类声明-virtual-析构函数" class="headerlink" title="7. 为多态基类声明 virtual 析构函数"></a>7. 为多态基类声明 virtual 析构函数</h2><p>C++ 明确指出,当 derived class 对象经由一个 base class 指针被删除,而该 base class 带着一个 non-virtual 析构函数时,其结果未定义.实际执行的通常情况是 base class 中的资源被释放,但 drived class 中的资源没被销毁.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeKeeper</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicClock</span>:<span class="hljs-keyword">public</span> TimeKeeper&#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>TimeKeeper* ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">delete</span> dtk; <span class="hljs-comment">//此时能正确调用派生类和基类的析构函数.</span><br></code></pre></td></tr></table></figure><ul><li>带多态性质的 base class 应该声明一个 virtual 析构函数.如果 class 带有任何 virtual 函数,它就应该拥有一个 virtual 析构函数.</li><li>class 的设计目的如果不是作为 base class 使用,或不是为了具备多态性,就不该声明 virtual 析构函数</li><li>可以使用<code>virtual ~ClassName() = 0</code>来生成一个纯虚类,此时需要给纯虚析构函数一个定义,不过什么都不用做.<code>ClassName::~ClassName()&#123;&#125;</code></li></ul><h2 id="8-别让异常逃离析构函数-避免在析构函数中出现异常"><a href="#8-别让异常逃离析构函数-避免在析构函数中出现异常" class="headerlink" title="8. 别让异常逃离析构函数(避免在析构函数中出现异常)"></a>8. 别让异常逃离析构函数(避免在析构函数中出现异常)</h2><ul><li>析构函数绝对不要吐出异常.如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下他们(不传播)或结束程序.</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么 class 应该提供一个普通函数(而非在析构函数中)执行该操作.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>        db.<span class="hljs-built_in">close</span>();<br>        closed=<span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>        <span class="hljs-keyword">if</span>(!closed)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                db.<span class="hljs-built_in">close</span>():<br>            &#125;<span class="hljs-built_in">catch</span>()&#123;<br>                <span class="hljs-comment">//...</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DBConnection db;<br>    <span class="hljs-type">bool</span> closed;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="9-绝不在构造和析构过程中调用-virtual-函数"><a href="#9-绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="9. 绝不在构造和析构过程中调用 virtual 函数"></a>9. 绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造和析构期间不要调用 virtual 函数,因为这类调用从不下降至 derived class (比起当前执行构造函数和析构函数的那层)</p><h2 id="10-令-operator-返回一个-reference-to-this"><a href="#10-令-operator-返回一个-reference-to-this" class="headerlink" title="10. 令 operator= 返回一个 reference to *this"></a>10. 令 operator= 返回一个 reference to *this</h2><ul><li>令赋值操作符返回一个 reference to *this,这是为了实现”连锁赋值”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Widget&amp; oprator=(<span class="hljs-type">int</span> rhs)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-在operator-中处理”自我赋值”"><a href="#11-在operator-中处理”自我赋值”" class="headerlink" title="11. 在operator= 中处理”自我赋值”"></a>11. 在operator= 中处理”自我赋值”</h2>小心潜在的”自我赋值”导致的错误.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 一份不安全的operator= 实现版本</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;          <br>    pb=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);  <span class="hljs-comment">//如果rhs==*this就出问题了</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>两种解决办法:</li></ul><ol><li>“证同测试”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;rhs ) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//证同测试</span><br>    <span class="hljs-keyword">delete</span> pb;          <br>    pb=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);  <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>实现”异常安全性”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Bitmap* pOrig=pb;   <span class="hljs-comment">//记住原来的pb</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<span class="hljs-comment">//执行赋值</span><br>    <span class="hljs-keyword">delete</span> pOrig;<span class="hljs-comment">//删除原先的pb</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12. 复制对象时勿忘其每一个成分"></a>12. 复制对象时勿忘其每一个成分</h2></li></ol><ul><li>copying 函数应该确保复制”对象内所有的成员变量”及”所有 base class 成分</li><li>不要尝试一某个 copying 函数实现另一个 copying 函数.应该将共同机能放进第三个函数中,并由两个 copying 函数共同调用.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">PriorityCustomer::<span class="hljs-built_in">PrioriytCustomer</span>(<span class="hljs-type">const</span> PriotiryCustomer&amp; rhs)<br>:<span class="hljs-built_in">Customer</span>(rhs), <span class="hljs-comment">//调用base class 的copy 构造函数</span><br><span class="hljs-built_in">priority</span>(rhs.priotiry)<br>&#123;<br><br>&#125;<br>PriorityCustomer&amp; <br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Priorityj&amp; rhs)&#123;<br>    Customer::<span class="hljs-keyword">operator</span>=(rhs);<br>    priority = rhs.priotity;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第一章</title>
    <link href="/2023/10/17/Effective%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/10/17/Effective%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-读书笔记"><a href="#Effective-C-读书笔记" class="headerlink" title="Effective C++ 读书笔记"></a>Effective C++ 读书笔记</h1><h2 id="1-视-C-为一个语言联邦"><a href="#1-视-C-为一个语言联邦" class="headerlink" title="1. 视 C++ 为一个语言联邦"></a>1. 视 C++ 为一个语言联邦</h2><p>C++的四个次语言:</p><ul><li><strong>C</strong> .</li><li><strong>Object-Oriented C++ .</strong>  面对对象</li><li><strong>Template C++</strong> 模板,泛型编程</li><li><strong>STL</strong>. 标准模板库</li></ul><h2 id="2-尽量以const-enum-inline替换-define"><a href="#2-尽量以const-enum-inline替换-define" class="headerlink" title="2. 尽量以const,enum,inline替换#define"></a>2. 尽量以const,enum,inline替换#define</h2><ul><li>对于单纯变量,最好以 const 对象或 enums 替换#define</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用 const 替换 #define </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NumOfMonths=<span class="hljs-number">12</span>;<br><span class="hljs-comment">// 编译期不需要知道常量值时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostEstimate</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> FudgeFactor;<span class="hljs-comment">//位于头文件中  </span><br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> CostEstimate::FudgeFactor=<span class="hljs-number">1.35</span>;<span class="hljs-comment">//位于实现文件中</span><br><br><span class="hljs-comment">// 编译期需要知道常量值可以用 enum hack 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns=<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于形似函数的宏,使用 inline<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(a&gt;b?a:b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-尽可能使用-const"><a href="#3-尽可能使用-const" class="headerlink" title="3.尽可能使用 const"></a>3.尽可能使用 const</h2><ul><li><code>const</code> 修饰指针<ul><li><code>const</code> 在星号左边表示被指物为常量 <code>const Widget* w; Widget const * w;</code> w指向一个常量</li><li><code>const</code> 在星号右边表示指针自身为常量 <code>Widget * const w</code> w这个指针为常量,不能改变它的指向</li><li><code>const</code> 同时出现在左边和右边表示被指物和指针两者都是常量</li></ul></li><li><code>const</code> 修饰智能指针<ul><li>直接使用<code>const</code>表示智能指针本身为常量(不能指向其他对象):<ul><li><code>const vector&lt;int&gt;::iterator ite=vec.begin()</code></li></ul></li><li>使用<code>const_iterator</code>表示常量的智能指针(不能改变指针指向的对象):<ul><li><code>vector&lt;int&gt;::const_iterator ite=vec.cbegin()</code></li></ul></li></ul></li><li><code>const</code> 修饰函数<ul><li><code>const</code> 在最左边表示返回值为常量 <code>const A func(A&amp; a1,const A&amp; a2) &#123;...&#125;</code></li><li><code>const</code> 在右边表示该函数不会改变传入的参数<code>A func(A&amp; a1,const A&amp; a2) const &#123;...&#125;</code></li></ul></li><li><code>const</code> 成员函数不可以更改对象内任何 <code>non-static</code> 成员变量,但有时候我们希望某些变量可以在 <code>const</code> 成员函数中改变,此时可以用<code>mutable</code>修饰成员变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *pText;<br>    <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!lengthIsValid)&#123;<br>        <span class="hljs-comment">//mutable 的成员变量能在const成员函数中修改</span><br>        textLength=std::<span class="hljs-built_in">strlen</span>(pText); <br>        lengthIsValid=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>const 函数可以调用 non-const 函数,甚至可以使用 const 函数来实现同名的 non-const 函数<br>,从而避免代码重复.</li><li><strong>不要在 const 函数中调用 non-const 函数,即使你感觉没问题</strong></li></ul><h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2><ul><li>为内置型对象进行手工初始化,因为C++不保证初始化他们</li><li>构造函数最好使用成员初值列(member initialization list),而不要在构造函数本体内进行赋值<br>操作.初值列列出的成员变量,其排列次序应该和他们在class中的声明次序相同</li><li>为免除”跨编译单元之初始化次序”问题,请以local static 对象替换 non-local-static 对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 不推荐的做法</span><br>ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std::string&amp; name,<span class="hljs-type">const</span> std::string&amp; address,<br>                <span class="hljs-type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">以下这些是赋值而不是初始化</span><br><span class="hljs-comment">*/</span><br>    theName=name;<br>    theAddress=address;<br>    thePhones=phones;<br>    numTimesConsulter=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 规定,对象的成员变量的初始化动作发生在进入构造函数本体之前,在上面的构造函数中,<code>theName, theAddress,thePhones</code>等变量都不是初始化,而是被赋值.真正的初始化发生在进入构造函数之前,<br>这导致这种实现对一个自定义对象先调用 default 构造函数进行初始化,然后立刻对他们赋予新值,这导致之前的 default 构造毫无意义.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 推荐的做法</span><br>ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std::string&amp; name,<span class="hljs-type">const</span> std::string&amp; address,<br>                <span class="hljs-type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones):<br>    <span class="hljs-built_in">theName</span>(name),<br>    <span class="hljs-built_in">theAddress</span>(address),<br>    <span class="hljs-built_in">thePhones</span>(phones),<br>    <span class="hljs-built_in">numTimesConsulter</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 以上使用初值列对成员对象进行初始化</span><br>&#123; &#125;<br></code></pre></td></tr></table></figure><p>对 local static 对象进行简单包装,将其转换为 static 对象可以解决一些初始化次序问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123;...&#125;;<br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> FileSystem fs;<br>    <span class="hljs-keyword">return</span> fs;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span>&#123;...&#125;;<br>Directory::<span class="hljs-built_in">Directory</span>(params)<br>&#123;<br>    ...<br>    std::<span class="hljs-type">size_t</span> disks=<span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();<br>    ...<br>&#125;<br><span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Directory td;<br>    <span class="hljs-keyword">return</span> td;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp随机数</title>
    <link href="/2023/10/10/cpp%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2023/10/10/cpp%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CPP-随机数"><a href="#CPP-随机数" class="headerlink" title="CPP 随机数"></a>CPP 随机数</h1><p>传统的使用<code>rand()</code>产生随机数有许多缺点，例如受最大最小值限制，随机数分布不均匀等。C++11提供了对随机数的更好的支持。目前，向获得较好的随机数可以有一下三个步骤：</p><ul><li>使用<code>random_device</code> 利用硬件生成随机种子，这种方法使用硬件，开销大，一般只用来产生随机种子</li><li>使用上述的随机种子作为随机数生成器的参数构造生成器，常用且较好的生成器为<code>std::mt19937</code> </li><li>使用<code>uniform_int_distribution</code>等给生成器限定范围</li></ul><p>实例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 注意windows下使用random_device不能使用mingw-gcc做编译器,linux下是正常的</span><br><span class="hljs-comment">* windows下要用random_device就使用msvc编译</span><br><span class="hljs-comment">* 如果windows下就是要用mingw-gcc,那么可以用: </span><br><span class="hljs-comment">* std::mt19937 rng(time(NULL));</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/* linux mingw-gcc*/</span><br>    <span class="hljs-comment">// std::random_device rnd; //利用硬件实现生成随机种子,效率低,所以只用来生成种子</span><br>    <span class="hljs-comment">// std::mt19937 rng(rnd()); //linux</span><br><br>    <span class="hljs-comment">/* windows mingw-gcc或msvc */</span><br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-literal">NULL</span>))</span></span>; <span class="hljs-comment">//windows   利用随机种子rnd生成的更好的随机数生成器</span><br><br>    <span class="hljs-comment">/* 均匀分布 */</span><br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//限制类型和范围,且随机数均匀分布</span><br>    <span class="hljs-function">std::uniform_real_distribution&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">unf</span><span class="hljs-params">(<span class="hljs-number">0.0f</span>,<span class="hljs-number">10.0f</span>)</span></span>; <span class="hljs-comment">//浮点随机数,随机数均匀分布</span><br>    <span class="hljs-function">std::uniform_real_distribution&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">und</span><span class="hljs-params">(<span class="hljs-number">10.0f</span>,<span class="hljs-number">20.0f</span>)</span></span>; <span class="hljs-comment">//double随机数,均匀分布</span><br>    <span class="hljs-comment">/* 正太分布 */</span><br>    <span class="hljs-comment">// std::normal_distribution&lt;int&gt; uni(50,100);</span><br>    <span class="hljs-comment">// std::normal_distribution&lt;float&gt; unf(0.0f,10.0f);</span><br>    <span class="hljs-comment">// std::normal_distribution&lt;double&gt; und(10.0f,20.0f);</span><br>    <span class="hljs-type">int</span> random_int=<span class="hljs-built_in">uni</span>(rng);<br>    <span class="hljs-type">float</span> random_float=<span class="hljs-built_in">unf</span>(rng);<br>    <span class="hljs-type">double</span> random_double=<span class="hljs-built_in">und</span>(rng);<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;random_int: &quot;</span>&lt;&lt;random_int&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;random_float: &quot;</span>&lt;&lt;random_float&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;random_double: &quot;</span>&lt;&lt;random_double&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">// 生成随机数组</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    std::<span class="hljs-built_in">generate</span>(<span class="hljs-built_in">begin</span>(a),<span class="hljs-built_in">end</span>(a),[&amp;]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">uni</span>(rng);&#125;);<br><br>    std::vector&lt;<span class="hljs-type">float</span>&gt; b;<br>    std::<span class="hljs-built_in">generate_n</span>(std::<span class="hljs-built_in">back_inserter</span>(b),<span class="hljs-number">10</span>,[&amp;]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">unf</span>(rng);&#125;);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v:a)&#123;<br>        std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v:b)&#123;<br>        std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br>    <br>    <span class="hljs-comment">// 从数组中随机取数</span><br>    std::vector&lt;std::string&gt; vec_str &#123;<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;cherry&quot;</span>,<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>&#125;;<br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">size_t</span>&gt; <span class="hljs-title">uns</span><span class="hljs-params">(<span class="hljs-number">0</span>,vec_str.size())</span></span>;<br>    std::cout&lt;&lt;vec_str[<span class="hljs-built_in">uns</span>(rng)]&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux C++编译与调试</title>
    <link href="/2023/04/07/Linux%20C++%E7%BC%96%E8%AF%91%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <url>/2023/04/07/Linux%20C++%E7%BC%96%E8%AF%91%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="g-编译"><a href="#g-编译" class="headerlink" title="g++ 编译"></a>g++ 编译</h3><ul><li> <code>vim show.cpp</code><br>#ifndef SHOW_CPP_<br>#define SHOW_CPP_<br>#include<br>void show(){<br>std::cout&lt;&lt;”hello world”&lt;&lt;endl;<br>}<br>#endif //end SHOW_CPP_ </li><li> <code>:n main.cpp</code><br>#ifndef MAIN_CPP_<br>#define MAIN_CPP_<br>void show();<br>int main(void){<br>show();<br>int i=0;//故意留的warning<br>return 0;<br>} </li><li> g++编译 </li></ul><p>:w 保存 Ctrl+z 暂时挂起（fg命令行恢复） 执行编译命令：</p><p><code>g++ main.cpp show.cpp -o main</code></p><p>编译成功则执行 <code>./main</code>运行可执行程序</p><p>若编译不成功输入fg恢复vim窗口，Debug后重试</p><h4 id="g-语法基础"><a href="#g-语法基础" class="headerlink" title="g++语法基础"></a>g++语法基础</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">g++ -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> &gt; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.i</span> <span class="hljs-comment">//预处理并结果放入main.i，也可以命名为main.txt等</span><br>g++ -S <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.i</span> -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.s</span> <span class="hljs-comment">//生成汇编文件，这个不太常用</span><br>g++ -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> <span class="hljs-comment">//预处理，编译和汇编，将程序做成obj文件，上述命令生成main.o和show.o</span><br>g++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> <span class="hljs-comment">//直接生成可执行文件，默认明明为a.out   ./a.out即可执行</span><br>g++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span>  <span class="hljs-comment">//和上面一样直接生成可执行文件，但被我们命名为main ./main即可执行</span><br>g++ -g <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span> <span class="hljs-comment">//直接生成可执行文件并重命名为main,但-g保留了调试信息，可以使用gdb进行调试</span><br></code></pre></td></tr></table></figure><p>总结：g++ [-E|-S|-c] [-g] file1.h file1.cpp file2.cpp -o myName<br>或者 g++ [-E|-S|-c] [-g] -o myName file1.h file1.cpp file2.cpp<br>也就是 【-o 生成名】放前放后都可以，但都要在[-E|-S|-c] [-g]后面</p><h3 id="makefile-文件基础"><a href="#makefile-文件基础" class="headerlink" title="makefile 文件基础"></a>makefile 文件基础</h3><p>每次输入g++语法命令太麻烦，用makefile文件来更方便的编译文件。<br>makefile的基础就是：<br>目标：依赖<br> 运行指令<br>当依赖不存在时，去后面找依赖的生成，即该依赖作为目标的语句。当依赖都存在且依赖比目标新的时候，执行“运行指令”生成最新的目标文件。<br>高阶内容需要时自查，下面这个例子可以应付目前大多数项目了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj=main.o show.o <span class="hljs-comment">#可以理解为重命名</span><br><span class="hljs-section">main:<span class="hljs-variable">$(obj)</span></span><br>g++ -g -o main <span class="hljs-variable">$(obj)</span> <span class="hljs-comment">#加-g是为了可以用gdb调试</span><br><span class="hljs-section">main.o: (*.h)# 上面的例子没有.h文件，如果有，要加上</span><br>g++ -g -c main.cpp<br><span class="hljs-section">string.o:(*.h)</span><br>g++ -g -c string.cpp<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean #虚目标，理解为makefile不会直接运行clean下面的命令</span><br><span class="hljs-section">clean:  #终端输入 make clean时，下面命令开始执行</span><br>-rm main *.o <span class="hljs-comment">#删除生成的文件，方便重编译</span><br>clear <span class="hljs-comment">#清空终端</span><br>ls <span class="hljs-comment">#列出当前目录</span><br></code></pre></td></tr></table></figure><p>更方便的makefile模板</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGET := main<br>SOURCE_DIR   := src<br>INCLUDE_DIR  := <span class="hljs-keyword">include</span><br>OBJECT_DIR   := obj<br>BIN_DIR      := bin<br><br>CC := g++<br>CCFLAGS := -g -Wall -std=c++11<br><br>SRCFILES     := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(SOURCE_DIR)</span>/*.cpp)</span><br>INCLUDES     := <span class="hljs-variable">$(INCLUDE_DIR)</span><br>OBJECTS      := $(SRCFILES:<span class="hljs-variable">$(SOURCE_DIR)</span>/%.cpp=<span class="hljs-variable">$(OBJECT_DIR)</span>/%.o)<br><br><span class="hljs-section">all: <span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span></span><br><br><span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span>: <span class="hljs-variable">$(OBJECTS)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CCFLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(OBJECTS)</span><br><br><span class="hljs-variable">$(OBJECT_DIR)</span>/%.o: <span class="hljs-variable">$(SOURCE_DIR)</span>/%.cpp<br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CCFLAGS)</span> -I<span class="hljs-variable">$(INCLUDES)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:run clean</span><br><br><span class="hljs-section">run:</span><br><span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-section">clean:</span><br>rm <span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span> <span class="hljs-variable">$(OBJECTS)</span><br><br><br></code></pre></td></tr></table></figure><h3 id="gdb-调试基础"><a href="#gdb-调试基础" class="headerlink" title="gdb 调试基础"></a>gdb 调试基础</h3><p>用带-g指令的g++生成可执行文件后，使用gdb ./main 启动gdb调试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">b main  <span class="hljs-regexp">//m</span>ain函数起点设置断点<br>b main.cpp:<span class="hljs-number">25</span> <span class="hljs-regexp">//m</span>ain.cpp文件的<span class="hljs-number">25</span>行处设置断点<br>run  <span class="hljs-regexp">//</span>运行程序，要运行起来才能调试<br>start <span class="hljs-regexp">//</span>开始单步调试<br>layout src <span class="hljs-regexp">//</span>显示源代码，这个比较直观，就和使用IDE一样了<br>n  <span class="hljs-regexp">//</span>下一行<br>s  <span class="hljs-regexp">//</span>进入函数<br>c  <span class="hljs-regexp">//</span>跳到下一个断点<br>p var <span class="hljs-regexp">//</span>打印var的值（信息）基础指令<br></code></pre></td></tr></table></figure><ul><li> 启动<code>gdb</code><br>#1.没有参数情况：gdb+可执行程序<br>gdb ./main<br>#2.带参数：gdb –args 可执行程序 + args<br>gdb –args ./main 2 #2是参数<br>#int main(int args,char* argv[]);<br>#3.连接已经运行的程序<br>gdp -p PID #终端ps -x 查看进程PID<br>sudo gdp -p PID </li><li> 查看源码<br>#1.list 列出部分源码<br>list | l<br>#2.列出往上的10行源码<br>list -10<br>#3.所有源代码<br>layout src </li><li> 运行程序<br>#1.使用run运行程序<br>run </li><li> 设置断点<br>#1.b 函数名<br>b main<br>#2.b 文件名:行号<br>b main.cpp:10 </li><li> 查看断点<br>info breakpoints<br>info b </li><li> 删除断点<br>#1.删除指定断点 delete num<br>delete 3 #删除第三个断点，第几个可以用info查看<br>#2.删除所有代码<br>delete 回车之后输入y确认删除所有断点 </li><li> 单步执行<br>#1.运行一行,不进入函数 next<br>n | next<br>#2.进入函数 step<br>s | step<br>#3.按机器指令执行一次 ni si </li><li> 查看变量<br>#查看、打印变量 p<br>p var_name </li><li> 监控变量<br>#1.监控变量，如果发生变化就通知<br>watch var<br>#2.监控变量，达到条件通知<br>watch var if var==1 #var变量变为1的时候通知我们<br>#3.查看所有watchpoints<br>info watchpoint </li><li> 跳出函数,循环<br>finish </li><li> 退出<br>quit </li></ul><h4 id="gdb-补充"><a href="#gdb-补充" class="headerlink" title="gdb 补充"></a>gdb 补充</h4><ul><li> 查看堆栈信息<br>x /20aw $sp #当前堆栈的20条信息，以ASCII码宽字符形式打印 </li><li> 记录回溯 反向调试<br>#1.记录一个执行点，运行几步后返回<br>record #记录当前位置<br>#使用record后可以反向调试<br>#往前走一行 reverse-next,真正的程序肯定不能逆向，当调试程序是可以的<br>reverse-n | reverse-next<br>reverse-s | reverse-step<br>#反向调试到调用当前函数的位置<br>reverse-finish<br>#每次输入reverse很麻烦，如果需要始终反向走，使用set<br>set exec-direction reverse<br>#反向调试可能会影响性能，不用是尽快结束<br>record stop </li><li> 执行终端指令<br>#gdb调试下也可以执行终端命令 shell 命令<br>(gdb)shell ls<br>(gdb)shell cat -n test.cpp #-n是显示行号 </li><li> 日志功能<br>#开启日志功能，可以把调试全过程记录下来<br>set logging on </li><li> 调试core文件<br>#程序发生段错误等原因挂掉，可能无法调试.out二进制文件，需要调试core文件<br>#core文件不会默认生成<br>ulimit -a #查看限制 core file size 默认是0<br>ulimit -c unlimited<br>#解除占用后重新使用<br>g++ -g main.cpp<br>#此时就会生成core文件，再用gdb调试<br>gdb ./main core文件 #core文件的名字用ll可查看<br>#如果没有生成core文件，使用ulimit -a 看看是不是权限被限制了。 </li><li> 调试正在运行的程序<br>#后台运行 ./a.out&amp;<br>#查看进程号 ps -ef<br>ps -ef | grep a.out<br>#调试正在运行的程序<br>gdb -p PID </li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序分析工具valgrind的使用</title>
    <link href="/2023/04/06/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind/"/>
    <url>/2023/04/06/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><div class="note note-info">            <p>参考《后台开发：核心技术与应用实践》第四章</p>          </div><h1 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h1><p>一个C/C++程序分析器，其包括Memcheck,Callgrind,Cachegrind,Helgrind,Massif等工具</p><ul><li>Memcheck 内存检查器，能够发现绝大多数内存错误使用情况。</li><li>Callgrind 收集程序运行时的一些数据，建立函数调用关系图</li><li>Cachegrind 检查程序中缓存使用出现的问题</li><li>Helgrind 检查多线程程序中出现的竞争问题</li></ul><p>本文主要介绍使用valgrind进行内存检查。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install valgrind<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认使用memcheck工具。如果要使用其它工具，用<code>--tool=tool name</code>指定.如<code>--tool=helgrind</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind ./main<br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li>使用未初始化的内存</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">/*<br> *使用未初始化的内存<br> */<br><span class="hljs-comment">#include &lt;iostream&gt;</span><br><br><span class="hljs-built_in">int</span> main()&#123;<br>        <span class="hljs-built_in">int</span> a[<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">int</span> i,s=<span class="hljs-number">0</span>;<br>        a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=a[<span class="hljs-number">3</span>]=a[<span class="hljs-number">4</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                s=s+a[i];<br>                <span class="hljs-keyword">if</span>(s==<span class="hljs-number">33</span>)&#123;<br>                        std::cout&lt;&lt;<span class="hljs-string">&quot;sum is 33&quot;</span>&lt;&lt;std::endl;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                        std::cout&lt;&lt;<span class="hljs-string">&quot;sum is not 33&quot;</span>&lt;&lt;std::endl;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>/* 运行结果<br>lumos@ubu:valgrind$ g++ test2.cpp -g -o test2<br>lumos@ubu:valgrind$ ./test2<br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><br>*/<br></code></pre></td></tr></table></figure><p>使用valgrind进行检查：</p><p><code>valgrid ./test2</code></p><p><img src="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/image-20230406162751586.png" alt="image-20230406162751586"></p><ol start="2"><li>内存读写越界</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内存读写越界</span><br><span class="hljs-comment"> * pt只有四个元素，但后面的for循环使p指向了pt数组外的地址</span><br><span class="hljs-comment"> * 可能导致程序出现不可预期的错误</span><br><span class="hljs-comment"> * 这种错误很难用肉眼发现，但valgrind很容易的发现了问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> *pt=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(len*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-type">int</span> *p=pt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                p++;<br>        &#125;<br>        *p=<span class="hljs-number">5</span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;the value of p is &quot;</span>&lt;&lt;*p&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/image-20230406163722777.png" alt="image-20230406163722777"></p><ol start="3"><li>动态内存管理错误</li></ol><p>常见的内存管理错误：</p><ul><li>申请与释放不一致。C使用malloc/free来申请和释放内存，C++使用new/delete。不可将两者混用。</li><li>申请和释放不一致。申请多少就释放多少，已经释放过的内存不能再次释放，没有释放的内存造成内存泄漏</li><li>释放后仍然读写。如果内存被释放后再访问，可能覆盖其它部分的信息，这是严重的错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *动态内存管理错误</span><br><span class="hljs-comment"> * 下面的代码包含了多种动态内存错误</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">char</span> *p=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">char</span> *pt=p;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>                p[i]=<span class="hljs-string">&#x27;z&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> p;<br>        pt[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;x&#x27;</span>;<br>        <span class="hljs-built_in">free</span>(pt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/image-20230406165225358.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>valgrind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列4-一些关键字</title>
    <link href="/2023/04/01/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%974-%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/04/01/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%974-%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><table><thead><tr><th>关键字</th><th>mutable</th><th>volatile</th></tr></thead><tbody><tr><td></td><td>1.最常见的用法：声明类成员变量是mutable的，</td><td></td></tr><tr><td>用法</td><td>意味着类中的const方法可以修改这个成员</td><td>用来修饰变量，告诉编译器不要对该变量做优化，总是从内存中读取该变量真正的值。</td></tr><tr><td></td><td>2.用于lambda表达式中，可以直接修改以值传递的变量</td><td>该关键字无法完成线程同步。</td></tr></tbody></table><table><thead><tr><th>关键字</th><th>register</th><th>explicit</th></tr></thead><tbody><tr><td>用法</td><td>C语言中，该关键字用来修饰局部变量，建议编译器将该值存入寄存器，</td><td>用于修饰类的构造函数，表示禁用隐式转换构造。</td></tr><tr><td></td><td>以获得更好的性能。但现代编译器大多会自行决定将哪些变量存入寄存器，故C++中的register其实没什么用</td><td>explicit A(int a)</td></tr><tr><td></td><td>register int a=2;</td><td></td></tr></tbody></table><table><thead><tr><th>关键字</th><th>default</th><th>delete</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>用法</td><td>让编译器自动生成默认构造函数，减少工作量</td><td>禁用类成员函数，一般用来在需要的时候禁用拷贝构造、移动构造、拷贝赋值，移动赋值。</td></tr><tr><td></td><td>class A{A()=default;}</td><td>class A{ A(const A&amp;)=delete;}</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>关键字</th><th>override</th><th>final</th></tr></thead><tbody><tr><td></td><td>放在函数声明后，用来显式的指明该函数时对基类中虚函数的重写。</td><td>放在类名后,表示该类禁止任何其他类继承它。</td></tr><tr><td>用法</td><td>void func() override { }</td><td>放在函数声明后，表示该函数禁止被重写。</td></tr><tr><td></td><td></td><td>class A final { }</td></tr><tr><td></td><td></td><td>void func() final { }</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//mutable 使用示例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::string m_name;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_DebugCount &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">//如果没有mutable,这个变量不能修改，因为该函数是const的</span><br>        m_DebugCount++;<br>        <span class="hljs-keyword">return</span> m_name;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Entity e &#123;<span class="hljs-string">&quot;lxp&quot;</span>&#125;;<br>    e.<span class="hljs-built_in">GetName</span>();<br>    <br>    <span class="hljs-type">int</span> x=<span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">auto</span> f1=[=]() <span class="hljs-keyword">mutable</span><br>    &#123;<br>        x++;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;x++: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-comment">//如果不用mutable，x按值传递，则不能直接作为左值，需要用临时变量y接收</span><br>    <span class="hljs-keyword">auto</span> f2=[=]() <br>    &#123;<br>        <span class="hljs-type">int</span> y=x;<br>        y++;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;x++: &quot;</span>&lt;&lt;y&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-comment">//f1和f2都不会改变x.因为是按值传递的</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;x is 8&quot;</span>&lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列3-强制类型转换</title>
    <link href="/2023/03/31/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%973-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/03/31/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%973-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>C++11提供了四类强制类型转换<code>static_cast,const_cast,dynamic_cast,reinterpret_cast</code>。如需要类型转换时，推荐使用这4中类型转换。</p><h2 id="总结使用原则"><a href="#总结使用原则" class="headerlink" title="总结使用原则"></a>总结使用原则</h2><p>总结使用原则，具体介绍见下文。</p><ol><li>基本内置类型转换用<code>static_cast</code></li><li><code>void*</code>与任意类型指针的转换用<code>static_cast</code></li><li>存在继承，但不存在多态的类、类指针、类引用的上行转换，即子-&gt;父的转换用<code>static_cast</code></li><li>存在多态的类指针、类引用，不管上下行都用<code>dynamic_cast</code>。转换后检查结果是否为空</li><li>常量与非常量之间的转换。只用于将常量转换为非常量作为函数参数的情况</li><li>尽量不使用<code>reinterpret_cast</code></li><li>对于没有多态的类，也可以用<code>static_cast</code>来进行下行转换，但不安全，尽量不要使用。</li></ol><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>静态类型转换</p><p>支持的操作</p><ol><li>基本内置类型转换</li><li>任意类型指针转换都可以用<code>void*</code> 作为媒介</li><li>存在继承的类且没有多态的类之间的类型转换：上行（子-&gt;父）√ 下行（父-&gt;子)×</li><li>存在多态（自然存在继承）的类之间的类型转换：上行（子-&gt;父）可以，但失去多态性；下行（父-&gt;子）不可以</li><li>存在继承但没有多态的类指针/引用之间转换：随便转，但下行不安全</li><li>存在多态的类指针/引用之间的转换：随便转但某些下行不安全</li></ol><p>建议的操作：</p><ol><li>各种内置类型转换（各种C中的隐式转换都建议使用``static_cast`代替</li><li>非空指针与<code>void *</code>之间的转换用<code>static_cast</code></li><li>不存在多态的类或类的指针或类的引用的上行转换用<code>static_cast</code></li></ol><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>将基类的指针/引用安全的转换为其派生类的指针或引用。只能在存在多态时使用。</p><ol><li>只有在派生类之间转换时才使用<code>dynamic_cast</code></li><li>基类必须有虚函数，因为<code>dynamic_cast</code>是运行时类型检查，需要运行时类型信息，而这个信息存在虚函数表中，虚函数表第一个函数指针的前面有一个<code>type_info</code>。</li></ol><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>常量转换。将常量指针或引用转换为非常量指针或引用。也可以将非常量转换为常量。</p><p>转换得到的非常量不是真正的非常量，依然不可修改（如果修改了，尽管编译不报错，运行时可能会段错误）。</p><p>非常量转换得到的常量也不是真正的常量。</p><p>唯一用途：函数重载（避免代码重复）。允许在某些时候将一个常量转换为非常量，作为函数参数传入。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;shorterstring(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)&#123;<br><span class="hljs-keyword">return</span> s1.size（）&lt;=s2.size（）?s1:s2;<br>&#125;<br><br><span class="hljs-built_in">string</span> &amp;shorterstring(<span class="hljs-built_in">string</span> &amp;s1,<span class="hljs-built_in">string</span> &amp;s2)&#123;<br><span class="hljs-built_in">auto</span> &amp;r=shorterstring(const_cast&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;&gt;(s1),<br>const_cast&lt;<span class="hljs-keyword">const</span> std:<span class="hljs-built_in">string</span> &amp;&gt;(s2));<br><span class="hljs-keyword">return</span> const_cast&lt;<span class="hljs-built_in">string</span> &amp;&gt;(r); <br>&#125;<br><br><span class="hljs-built_in">int</span> main()&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> s1,s2;<br><span class="hljs-built_in">string</span> shorterStr1=shorterString(s1,s2);<br><span class="hljs-built_in">string</span> s3,s4;<br><span class="hljs-built_in">string</span> shorterStr2=shorterString(s3,s4);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>为位运算的位模式提供低层次上的重新解释。</p><p>非常危险的操作，能不用就不用。</p><ol><li><code>reinterpret_cast&lt;type&gt;(expression)</code> <code>type</code>与<code>expression</code>中至少有一个是指针/引用。</li><li>指针类型之间的转换可以直接使用<code>reinterpret_cast</code>，无需媒介。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux三剑客grep,sed,awk</title>
    <link href="/2023/03/30/Linux%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <url>/2023/03/30/Linux%E4%B8%89%E5%89%91%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>&#124;</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \\ &amp;#124;</code></td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><p>简写字符集</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr></tbody></table><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><ul><li><p>作用：筛选数据</p></li><li><p>格式： <code>grep [选项] [过滤规则] [路径]</code> 或 <code>输出 | grep [选项] [过滤规则]</code></p></li><li><p>选项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">-n : 显示行号<br>-o : 只显示匹配到的内容<br>-c : 显示总共匹配到多少行<br>-E : 使用正则表达式<br>-v : 反向查找，查找不存在指定字符的行<br>-R : 递归查找<br>-A n : 显示匹配到的行的后n行<br>-B n ：显示匹配到的行的前n行<br>-C n : 显示匹配到的行的前后各n行。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[system]<br>system.cpu<br>system.cache<br>[system.cpu]<br>system.cpu.type<br>system.cpu.freq<br>[system.cache]<br>system.cache.type<br>system.cache.clock<br>[system.cache.clock]<br>syystem.cache.clock.mic<br></code></pre></td></tr></table></figure></li><li><p>将上述<code>sys.ini</code>只显示[<em>]或[</em>.*]的行及其下面两行的指令</p></li></ul><p><code>cat sys.ini | grep -A 2 -E &quot;^\[\w*\]$|^\[\w*\.\w*\]$&quot;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[system]<br>system.cpu<br>system.cache<br>[system.cpu]<br>system.cpu.type<br>system.cpu.freq<br>[system.cache]<br>system.cache.type<br>system.cache.clock<br></code></pre></td></tr></table></figure><ul><li><p>不含cpu的行 <code>cat sys.ini | grep -v &quot;cpu&quot;</code></p><h2 id="sed-流式编辑器"><a href="#sed-流式编辑器" class="headerlink" title="sed 流式编辑器"></a>sed 流式编辑器</h2></li><li><p>作用：主要用来修改文件</p></li><li><p>格式：<code>sed [选项 “[定位][指令]&quot; [路径]</code></p><ul><li>不指定定位，则默认处理全文</li></ul></li><li><p>参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-e : 允许多项编辑</span><br><span class="hljs-deletion">-n ：取消默认输出</span><br><span class="hljs-deletion">-i : 就地编辑文本</span><br><span class="hljs-deletion">-r : 支持扩展正则表达式。正则表达式放在//之间</span><br><span class="hljs-deletion">-f : 指定定位规则的文件</span><br></code></pre></td></tr></table></figure></li><li><p>指令</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">p:</span> 打印<br><span class="hljs-symbol">d:</span> 删除<br><span class="hljs-symbol">a:</span> 再当前行后添加一行或多行内容<br><span class="hljs-symbol">i:</span> 在当前行之前插入文本<br><span class="hljs-symbol">w:</span> 匹配到的行写入一个新的文件<br><span class="hljs-symbol">s:</span> 用一个字符替换成另一个字符<br><span class="hljs-symbol">c:</span> 用新文件替换当前行中的内容<br></code></pre></td></tr></table></figure><p>掌握几个基础的就行。其它用到再查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#会把第二行输出，然后把整个文本输出</span><br>sed <span class="hljs-string">&quot;2p&quot;</span> sys.ini<br><span class="hljs-comment">#只会输出第2行</span><br>sed -n <span class="hljs-string">&quot;2p&quot;</span> sys.ini<br><span class="hljs-comment">#只输出第3，7行</span><br>sed -n -e <span class="hljs-string">&quot;3p&quot;</span> -e <span class="hljs-string">&quot;7p&quot;</span> sys.ini<br><br><span class="hljs-comment">#删除第2行。-i就地编辑。如果没有-i只是暂时编辑，文件其实没变</span><br>sed -i <span class="hljs-string">&quot;2d&quot;</span> sys.ini<br><span class="hljs-comment">#第二行之前加入文本</span><br>sed <span class="hljs-string">&quot;2i 加到第二行之前&quot;</span> sys.ini<br>sed -i <span class="hljs-string">&quot;2i 加到第二行之前&quot;</span> sys.ini<br><span class="hljs-comment">#第二行之后加入文本</span><br>sed <span class="hljs-string">&quot;2a 加到第二行之后&quot;</span> sys.ini<br>sed -i <span class="hljs-string">&quot;2a 加到第二行之后&quot;</span> sys.ini<br></code></pre></td></tr></table></figure><h2 id="awk-文本处理工具"><a href="#awk-文本处理工具" class="headerlink" title="awk 文本处理工具"></a>awk 文本处理工具</h2></li><li><p>作用：处理文本，将文本按指定规则进行处理</p></li><li><p>格式 <code>awk [选项] &#39;匹配规则和处理规则&#39; [路径]</code></p></li><li><p>选项</p><ul><li><code>-F</code>设置输入字段分隔符，也可以用处理规则中的<code>BEGIN&#123;&#125;</code></li></ul></li><li><p>处理规则：</p><ul><li><code>BEGIN&#123;&#125;</code>处理文本之前设置变量</li><li><code>//</code>使用的匹配规则，正则表达式或字符串</li><li><code>&#123; &#125;</code>一条命令，可以是循环或判断</li><li><code>END&#123;&#125;</code>处理文本之后执行END中的指令</li></ul></li><li><p>awk中的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$0</span>: 当前行<br>NR: 行号<br>NF: 总共保存的列数<br>FS: 输入字段分隔符，默认空格<br>OFS: 输出字段分隔符<br>RS: 设置的正则<br>RT: 正则匹配到的内容<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>awk的处理逻辑其实很简单，首先执行BEGIN{}中的内容，只要是设置输入分隔符FS和输出分隔符OFS，执行/ /中的匹配规则，找出符合匹配的行，这些行逐行的执行后面的处理指令。最后执行END{}中的指令，主要是输出一些自定义的变量自定义值等。</p>          </div><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#以:为分割符，输出第3列和第5列 ,且中间用-连接</span><br>awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;-&quot;&#125;&#123;print $3,$5&#125;&#x27;</span> a.txt<br><span class="hljs-comment">#输出第4行到的8行</span><br>awk <span class="hljs-string">&#x27;&#123;if(NR&gt;=4&amp;&amp;NR&lt;=8)&#123;print $0&#125;&#125;&#x27;</span> a.txt<br><span class="hljs-comment">#格式化输出第1，2列和最后一列</span><br><span class="hljs-comment"># %s表示字符类型，%d表示数值类型，占15个位置，-表示左对齐，默认为右对齐。</span><br><span class="hljs-comment">#print 默认加换行，printf 没有自动换行，要自己加\n</span><br>awk -F: <span class="hljs-string">&#x27;&#123;printf &quot;|%-15s| %-10s| %-15s|\n&quot;, $1,$2,$NF&#125;&#x27;</span> /etc/passwd<br><br><span class="hljs-comment">#输出奇数行及其行号,分隔符为&quot;,&quot;</span><br>awk -F, <span class="hljs-string">&#x27;&#123;if(NR@==0)&#123;print NR,$0&#125;&#125;&#x27;</span> a.txt<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span>循环：<span class="hljs-keyword">for</span>(i=0;i&lt;5;i++)  <span class="hljs-keyword">for</span>(i=1;i&lt;NF;i++)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim编辑器</title>
    <link href="/2023/03/30/VIM%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/30/VIM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>主要进行位置跳转</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ada">h,j,k,l : ←，↑，↓，右<br>nh,nj,nk,nl <br>w,b,e ：w(word) b(backword) e(<span class="hljs-keyword">end</span>)<br>    w : 下个小词的开头 <span class="hljs-type">W</span> : 下个大词的开头<br>b : 上个小词的开头 <span class="hljs-type">B</span> : 上个大词的开头<br>e : 下个小词的结尾 <span class="hljs-type">E</span> : 下个段的结尾<br>f,t : <span class="hljs-type">f</span>(find) t(till,贴靠)<br>    fa : 本行中下个<span class="hljs-type">a</span>的位置    Fa ：本行中上个a的位置<br>    ta : 本行中下个<span class="hljs-type">a</span>的位置的前一个 Ta : 本行中上个<span class="hljs-type">a</span>的位置的前一个<br>^,$ :<br>^ 本行开头<br>$ 本行结尾<br>+,- :<br>+ 下行非空<br>    - 上行非空<br>    <br>%,*,#:<br>    % 匹配括号移动，需要先把光标移动到括号上<br>    *,# 匹配光标所在的单词，*是下一个,#是上一个<br>gg : 第一行第一个字符<br><span class="hljs-number">6</span>gg : 第6行的开头  等同于6<span class="hljs-type">G</span><br>G : 最后一行的第一个字符<br><span class="hljs-number">4</span>G ：第<span class="hljs-number">4</span>行的第一个字符 等同于 <span class="hljs-number">4</span>gg<br>Go : 最后一行插入<br>gg=G : 全文自动缩进<br>E : 5<span class="hljs-type">j</span><br>U : 5<span class="hljs-type">k</span><br>J : 合并，下一行与当前行合并<br>K : 光标所在词的帮助文档(<span class="hljs-type">man</span>文档)<br>u : 撤销<br>r : 替换一个字符<br>R ：连续替换字符，ESC退出<br>x : 删除当前字符 3<span class="hljs-type">x</span><br>X : 删除前一个字符 4<span class="hljs-type">X</span><br>yy ：复制<br>ye : 从当前位置拷贝到单词结束<br>nyy : 复制<span class="hljs-type">n</span>行 等同于yny<br>p : 粘贴<br>np : 粘贴<span class="hljs-type">n</span>次<br>dd : 剪切一行<br>ndd : 剪切<span class="hljs-type">n</span>行 等同于dnd<br>dt<span class="hljs-string">&quot; :从当前位置开始删除直到遇到&quot;</span><br>DD : 从光标位置开始剪切 <span class="hljs-type">nDD</span> DnD<br>cc : 删除一行并进入插入模式<br>CC ： 从光标位置开始删除，并进入插入模式<br>ctrl+o 上一次跳转的位置<br>ctrl+i 下一次跳转的位置<br>ma : 做一个名为<span class="hljs-type">a</span>的标记命令模式 :marks 查看所有标记<br>`a : 跳转到<span class="hljs-type">a</span>标记<br>`<span class="hljs-string">&quot; : 上次退出当前文件的位置</span><br><span class="hljs-string">`[ : 上次修改的开始位置</span><br><span class="hljs-string">`] : 上次修改的结束位置</span><br><span class="hljs-string">`. : 上次编辑的最后操作位置</span><br><span class="hljs-string">. 重复上一操作</span><br><span class="hljs-string">3. 重复上一操作3次</span><br></code></pre></td></tr></table></figure><p> 在当前行上移动光标<br><img src="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/DlMXjBAowJIYrVx.png" alt="1678953831946-1589002c-c1d6-40eb-8752-d2a8f19bca12.png"></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>正常模式 =<code>:</code>=&gt;进入命令模式<br>常用命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">:w 保存 :q 退出 :wq 保存退出<br>:w! :q! :wq! 强制执行<br>:h i  获取i的帮助文档<br>:e other.txt  另外other.txt<br>:w other.txt 另存为，要求other.txt不存在<br>:w! other.txt  强制写入other.txt 替换原来的内容<br>:w &gt;&gt; other.txt 在other.txt的最后追加内容<br>:<span class="hljs-number">40</span> 直接跳到第<span class="hljs-number">40</span>行<br>:bn 下一个文件（如果打开了多个文件）<br>:sp 上下分屏<br>:vs 左右分屏<br>ctrl+w+ 箭头 切换窗口<br></code></pre></td></tr></table></figure><p>搜索与替换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/pattern  搜索pattern  先回车,n下一个,N上一个n,s取消高亮<br>?pattern 搜索pattern 和/方向相反，向上搜索<br>:s/aaa/bbb/g  本行所有aaa替换为bbb<br>:<span class="hljs-number">1</span>,<span class="hljs-number">5</span>s/aaa/bbb/g  第<span class="hljs-number">1</span>至<span class="hljs-number">5</span>行所有aaa替换为bbb<br>:.,$s/aaa/bbb/g  当前行到最后一行所有aaa替换为bbb<br>:%s/aaa/bbb/g   全文aaa替换为bbb<br></code></pre></td></tr></table></figure><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i : 当前位置插入<br>I : 当前行开头插入<br>a : 光标的下一位置插入<br>A : 当前行的结尾插入<br>o : 下一行插入<br>O : 上一行插入<br>cw : 替换从光标所在位置后到一个单词结尾的字符 要修改一个单词时使用<br><br>ctrl+c 退出插入模式<br>ESC 退出插入模式<br>ctrl+o 进入命令-插入模式，只退出插入模式一下，执行一个命令后进入插入模式<br></code></pre></td></tr></table></figure><h2 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs r">v 进入选择模式<br>ctrl<span class="hljs-operator">+</span>v 进入块选择模式<br>ctrl<span class="hljs-operator">+</span>d 选择该光标左下角所有内容<br>h<span class="hljs-punctuation">,</span>j<span class="hljs-punctuation">,</span>k<span class="hljs-punctuation">,</span>l 进行选择<br>y 复制<br>p 粘贴<br>A 在开头写入<span class="hljs-comment"># ESC退出，所有选中行全都加上了#注释</span><br><span class="hljs-built_in">c</span> 选中后<span class="hljs-built_in">c</span>删除选中内容并进入插入模式，重新输入后ESC退出，所有选中内容都被修改了<br>选中多行的一个字符，cw<span class="hljs-punctuation">,</span>删除一个单词，并进入插入模式<br></code></pre></td></tr></table></figure><h2 id="vimrc"><a href="#vimrc" class="headerlink" title="~/.vimrc"></a>~/.vimrc</h2><p>vim配置文档</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs routeros">syntax on <span class="hljs-string">&quot;语法高亮</span><br><span class="hljs-string">set nocompatible &quot;</span>不与vi兼容<br><span class="hljs-built_in">set</span> number <span class="hljs-string">&quot;显示行号 </span><br><span class="hljs-string">&quot;</span><span class="hljs-built_in">set</span> nu “nu 为 number的缩写<br><br><span class="hljs-built_in">set</span> relativenumber <span class="hljs-string">&quot;显示相对行号</span><br><span class="hljs-string"></span><br><span class="hljs-string">set cursorline &quot;</span>突出显示当前行  <span class="hljs-built_in">set</span> cul<br><span class="hljs-string">&quot;set cursorcolumn &quot;</span>突出显示当前列 <span class="hljs-built_in">set</span> cuc<br><br><span class="hljs-built_in">set</span> showmatch <span class="hljs-string">&quot;显示括号匹配</span><br><span class="hljs-string">set showmode &quot;</span>在底部显示，当前处于命令模式还是插入模式<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">bg</span>=dark <span class="hljs-string">&quot;设置黑色背景</span><br><span class="hljs-string">:colorscheme desert</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>设置缩进 1、设置TAB长度为4空格 2、设置自动缩进长度为4空格 3、继承前一行的缩进方式，适用于多行注释<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">tabstop</span>=4<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">shiftwidth</span>=4<br><br><span class="hljs-built_in">set</span> expandtab <span class="hljs-string">&quot;按下tab自动转换为空格</span><br><span class="hljs-string"></span><br><span class="hljs-string">autocmd BufWritePost <span class="hljs-variable">$MYVIMRC</span> source <span class="hljs-variable">$MYVIMRC</span> &quot;</span>实现.vimrc保存时自动重启加载<br><span class="hljs-built_in">set</span> wrap <span class="hljs-string">&quot;设置自动换行 set nowarap 取消自动换行 </span><br><span class="hljs-string">set showcmd &quot;</span>输入的命令显示出来，看的清楚些<br><span class="hljs-string">&quot;在命令模式下，按下tab可以自动补全命令</span><br><span class="hljs-string">set wildmenu</span><br><span class="hljs-string"></span><br><span class="hljs-string">set wildmode=longest,list,full</span><br><span class="hljs-string"></span><br><span class="hljs-string">set backspace=indent,eol,start &quot;</span>inset模式下，使退格键可以删掉任何东西<br><span class="hljs-built_in">set</span> hlsearch <span class="hljs-string">&quot;搜索高亮  </span><br><span class="hljs-string">exec &quot;</span>nohlsearch<span class="hljs-string">&quot;</span><br><span class="hljs-string">set incsearch &quot;</span>高亮显示搜索的匹配过程，每输入一个字符，就自动跳转到第一个匹配结果<br><br>hi Search <span class="hljs-attribute">term</span>=standout <span class="hljs-attribute">cterm</span>=bold <span class="hljs-attribute">ctermfg</span>=7 <span class="hljs-attribute">ctermbg</span>=1<br><span class="hljs-built_in">set</span> ignorecase <span class="hljs-string">&quot;</span><br><span class="hljs-string">set smartcase  &quot;</span>  <br><span class="hljs-built_in">set</span> <span class="hljs-attribute">mouse</span>=a    <span class="hljs-string">&quot;</span><br><span class="hljs-string">set autoindent &quot;</span>自动缩进，按下回车后，下一行会自动根上一行的缩进保持一致 <br><br><span class="hljs-built_in">set</span> smartindent <span class="hljs-string">&quot;智能缩进</span><br><span class="hljs-string">set ruler &quot;</span>在状态栏显示光标当前位置，哪一行哪一列<br><span class="hljs-built_in">set</span> undofile<br>noremap E 5j <span class="hljs-string">&quot;向下移动5行</span><br><span class="hljs-string">noremap U 5k &quot;</span>向上移动5行<br>inoremap jk &lt;ESC&gt; <br><span class="hljs-string">&quot;按下s取消高亮结果显示,本来按下s删除当前字符并进入插入模式</span><br><span class="hljs-string"></span><br><span class="hljs-string">map s :noh&lt;CR&gt; </span><br><span class="hljs-string">map S :w&lt;CR&gt;</span><br><span class="hljs-string">map Q :q&lt;CR&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>map R :source <span class="hljs-variable">$MYVIMRC</span>&lt;CR&gt;<br>map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;<br>filetype indent on <span class="hljs-string">&quot;开启文件类型检查，并且载入与该类型对应的缩进规则。如何，如果编辑的是.py文件，Vim就是会找到Python的缩进规则</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列2-内存对齐、空类、多态</title>
    <link href="/2023/03/25/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%972-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E3%80%81%E7%A9%BA%E7%B1%BB%E3%80%81%E5%A4%9A%E6%80%81/"/>
    <url>/2023/03/25/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%972-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E3%80%81%E7%A9%BA%E7%B1%BB%E3%80%81%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><h3 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h3><ul><li>一部分原因是某些硬件平台对特定的数据只能从特定地址开始存取。</li><li>根本原因在于字节对齐可以提高CPU访问数据的效率。例如，一个int数据如果不按字节对齐，就会出现为了读取一个数据，需要CPU访问两次内存的情况，CPU访问内存所花费的时间是远远大于计算的，显然不按字节存取会造成CPU性能瓶颈</li></ul><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型要求起始地址是其长度的整数倍。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//占据内存[0,1]</span><br><span class="hljs-built_in">int</span> b;<span class="hljs-comment">//占据内存[4,5,6,7].地址2,3不可用,</span><br><span class="hljs-comment">//因为int要按4对齐,要求起始地址%4==0</span><br>&#125;;<br>sizeof(A)=<span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>第一个元素按照基本类型或结构体的对齐原则对齐后，后面的元素连续存放即可</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>不指定对齐方式的情况</p><ul><li>每个元素单独按照自身长度进行对齐</li><li>整体按照元素最大长度进行对齐</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-comment">//short: 2 int: 4 long: 8</span><br><span class="hljs-keyword">struct</span> A&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//[0,1]</span><br><span class="hljs-built_in">int</span> b;<span class="hljs-comment">//[4..7]</span><br><span class="hljs-built_in">short</span> c;<span class="hljs-comment">//[8,9]</span><br>&#125;;<span class="hljs-comment">//12,因为10不是4的倍数，故填充至12（这里的10来源：地址0到9有10位）</span><br><br><span class="hljs-keyword">struct</span> B&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//[0,1]</span><br><span class="hljs-built_in">short</span> b;<span class="hljs-comment">//[2,3]</span><br><span class="hljs-built_in">int</span> c;<span class="hljs-comment">//[4..7]</span><br>&#125;;<span class="hljs-comment">//8//8是4的倍数，不用填充</span><br><br><span class="hljs-keyword">struct</span> C&#123;<br><span class="hljs-built_in">int</span> a;<span class="hljs-comment">//[0..3]</span><br><span class="hljs-built_in">short</span> b;<span class="hljs-comment">//[4,5]</span><br><span class="hljs-built_in">short</span> c;<span class="hljs-comment">//[6,7]</span><br>&#125;;<span class="hljs-comment">//8//8是4的倍数，不用填充</span><br><br><span class="hljs-keyword">struct</span> D&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//[0,1]</span><br><span class="hljs-built_in">long</span> b;<span class="hljs-comment">//[8..15]</span><br><span class="hljs-built_in">short</span> c;<span class="hljs-comment">//[16,17]</span><br><span class="hljs-built_in">int</span> d;<span class="hljs-comment">//[20..23]</span><br>&#125;;<span class="hljs-comment">//24//24是8的倍数，不用填充</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;short: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">short</span>)&lt;&lt;<span class="hljs-string">&quot; int: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>)<br>&lt;&lt;<span class="hljs-string">&quot; long: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;A: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(A)&lt;&lt;<span class="hljs-string">&quot; B: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(B)&lt;&lt;<span class="hljs-string">&quot; C: &quot;</span><br>&lt;&lt;<span class="hljs-keyword">sizeof</span>(C)&lt;&lt;<span class="hljs-string">&quot; D: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(D)&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303252043199.png" alt="image-20230325204358151"></p><h4 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h4><ul><li>联合体内存要求至少为最长元素的长度</li><li>同时，内存大小必须为所有成员的整数倍</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><br>union A&#123;<br><span class="hljs-built_in">char</span> a;<br><span class="hljs-built_in">int</span> b[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">long</span> c;<br>&#125;;<br><span class="hljs-comment">/*结果为16.首先A至少为12，因为3个int长度为12，其次长度必须为8的倍数，因为long的长度为8。故最终结果为16</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;short: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">short</span>)&lt;&lt;<span class="hljs-string">&quot; int: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>)<br>&lt;&lt;<span class="hljs-string">&quot; long: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;A: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(A)&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303252044239.png" alt="image-20230325204433214"></p><h4 id="指定对齐方式"><a href="#指定对齐方式" class="headerlink" title="指定对齐方式"></a>指定对齐方式</h4><p>使用<code>#pragma pack(n)</code> 指定对齐方式。</p><p>当指定对齐方式时，上述的各种类型的对齐字节为自身对齐值与指定对齐值中的较小值。</p><p>对于结构体和联合体，整体的大小仍然是去正常分析的情况与指定的方式取较小值。</p><p>例子1： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">short</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">short</span> c;<br>&#125;;<br><span class="hljs-comment">//如果没有指定以2对齐，sizeof(A)=12</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2)</span><br><span class="hljs-comment">//指定为2对齐，结果为2+4+2=8</span><br></code></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">short</span> b;<br><span class="hljs-type">long</span> c;<br><span class="hljs-type">char</span> d[<span class="hljs-number">2</span>];<br>&#125;;<br><span class="hljs-comment">//正常分析的结果为 4+2+(2)+8+2+(6)=24 .(2)为short b后填充的，(6)为整体填充的，为了结果对8整除</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-comment">//指定为4对齐，则结果为4+2+(2)+8+2+(2)=20. 因为min&#123;8,4&#125;=4,故整体只要为4的倍数就可以了</span><br><br></code></pre></td></tr></table></figure><h2 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h2><div class="note note-info">            <p>我觉得这是一个很无聊的问题，这个问题再stack overflow上的讨论争论也比较大。</p><p>以下是我觉得比较合理的问答。</p>          </div><p>空类的大小为1.</p><p>原因：以下三个原因其实是一个意思，只是表达方式不太同。</p><ul><li>为了确保两个不同对象的地址不同。</li><li>C++ 标准要求类型相同的两个对象地址必须不同。</li><li>发生这种情况的原因归结为正确实施标准，C++ 其中一条标准是“任何对象在内存中的地址都不应与任何其他变量相同”确保这一点的最简单方法是什么？确保所有类型都具有非零大小。为了实现这一点，编译器向没有数据成员和虚函数的结构和类添加一个虚拟字节，使它们的大小为 1 而不是 0，然后保证它们具有唯一的内存地址</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，顾名思义就是同一种事物在不同情况下表现出不同的形态。</p><p>C++中的多态可以分为<strong>静态多态</strong>和<strong>动态多态</strong>两种</p><ul><li>静态多态：函数重载和泛型编程（模板编程）</li></ul><h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><p>大部分情况下提到C++的多态指的是第二种动态多态。动态多态是通过在基类方法前加上<code>virtual</code> 关键字，使得该函数成为虚函数，然后子类可以重写该方法。这样包含虚方法的类就具有了多态性：</p><ul><li>通过基类指针调用虚函数时，若指针指向的基类对象，则调用基类的方法，若指向的是子类指针，则调用相应的子类方法。</li><li>通过基类引用调用虚函数时，若引用的对象是基类对象，则调用基类方法，若引用对象是子类，则调用相应的子类方法。</li></ul><div class="note note-warning">            <p>如果基类中有虚函数，那么应该将基类的虚构函数也定义为虚函数。</p><p>原因：如果不那么做，基类指针指向子类，然后<code>delete</code>该指针时，调用的是基类的析构函数，这会导致子类的析构函数没有被调用。</p><p>而如果把基类的析构函数定义为虚函数，则<code>delete</code> 该指针会调用子类的析构函数，子类析构完成会自动调用基类的析构函数，这样才能保证子类和基类的资源都被释放。 </p>          </div><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>再基类的纯虚函数声明的后面加上<code>=0</code>。该虚函数成为纯虚函数，该基类成为抽象类。</p><ul><li>纯虚函数在基类中声明但不定义，而要求所有的派生类一定要定义这个虚函数的实现。</li><li>具有纯虚函数的基类成为抽象类，抽象类不能实例化，但可以定义抽象类的指针或引用来对子类进行管理</li><li>如果子类中只声明而没有实现纯虚函数，那么这个子类还是一个抽象类，依然不能实例化</li></ul><h4 id="虚函数指针和虚函数表"><a href="#虚函数指针和虚函数表" class="headerlink" title="虚函数指针和虚函数表"></a>虚函数指针和虚函数表</h4><p>C++通过虚函数指针和虚函数表来实现，</p><p>每一个有虚函数的类，或者有虚函数的类的子类，都有一个虚函数表，虚函数表中列出了该类的虚函数的实现地址。这个虚函数表在编译期就建立，存储在了数据区段的<code>.rodata</code>子段。</p><p>这些类的每一个对象都有一个指向虚函数表的指针。当通过基类指针调用虚函数时，会根据指针实际指向的对象中的虚表指针去找到对应的虚函数表，在表中找到函数实现。</p><p>一些<strong>tips</strong>:</p><ol><li><p>虚表和虚表指针建立时间：</p><ul><li><p>虚函数表在编译期建立，虚表指针一般作为类的第一个成员变量，虚表指针在基类构造函数之后，子类构造函数之前进行初始化。</p></li><li><p>构造函数的调用过程：进入构造函数体之前，如果存在虚函数，虚表指针被初始化。如果存在构造函数的初始化列表，则执行初始化列表。然后进入构造函数体执行构造。</p></li></ul></li><li><p>哪些函数不能声明为虚函数</p><ul><li><p>友元函数，它不是类成员函数</p></li><li><p>静态成员函数，它没有this指针，没有this指针就无法访问虚表指针，也就找不到虚函数的实现</p></li><li><p>构造函数、复制构造函数以及赋值操作符重载可以但不建议声明为虚函数</p></li></ul></li><li><p>派生类虚表如何建立</p><ul><li>先将基类的虚表复制一份</li><li>如果子类对基类中的虚函数进行了重写，则将子类的虚表相应位置替换为子类的函数实现地址</li><li>如果子类新增了自己的虚函数，则按照其声明次序，放在上述虚表的后面</li></ul></li></ol><p>从类中直接获取虚函数表的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vAfunc1</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;vAfunc1&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vAfunc2</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;vAfunc2&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Afunc</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;Afunc: &quot;</span>&lt;&lt;data1&lt;&lt;endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> data1;<br>&#125;;<br><br><span class="hljs-keyword">using</span> Func=<span class="hljs-built_in">void</span>();<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>A a;<br><span class="hljs-keyword">auto</span> t1=(<span class="hljs-type">int64_t</span> *)(&amp;a);<span class="hljs-comment">//对a的地址强制转换</span><br><span class="hljs-keyword">auto</span> t2=(<span class="hljs-type">int64_t</span> *)*t1;<span class="hljs-comment">//对a的第一个数据解引用，取得虚表</span><br><span class="hljs-keyword">auto</span> t3=(Func *)*t2;<span class="hljs-comment">//虚表的第一个元素。是a的第一个虚函数</span><br><span class="hljs-built_in">t3</span>();<br><span class="hljs-keyword">auto</span> t4=(Func *)*(t2+<span class="hljs-number">1</span>);<span class="hljs-comment">//虚表的第二个元素。</span><br><span class="hljs-built_in">t4</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">vAfunc1</span><br><span class="hljs-comment">vAfunc2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="RTTI-运行时类型判别"><a href="#RTTI-运行时类型判别" class="headerlink" title="RTTI 运行时类型判别"></a>RTTI 运行时类型判别</h2><p>当一个函数的传入参数是一个基类指针（引用）时，我们可能需要知道这个基类指针参数指向的到底指向的是哪一种子类。</p><p>这就需要用到虚表中第一个函数的前面存放的一个<code>type_info</code></p><p>可以直接从<code>type_info</code>中获取类的类型信息，但那样太麻烦，C++提供了可以直接使用的库函数<code>typeid()</code>可以返回指针和引用所指的实际类型。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">void</span> test(<span class="hljs-type">A</span> *a)&#123;<br><span class="hljs-keyword">if</span>(typeid(*a)==typeid(<span class="hljs-type">A</span>))&#123;<br><span class="hljs-type">A</span> *pa=reinterpret_cast&lt;<span class="hljs-type">A</span> *&gt;(a);<br>pa-&gt;func1();<br>&#125;<br><span class="hljs-keyword">if</span>(typeid(*a)==typeid(<span class="hljs-type">B</span>))&#123;<br><span class="hljs-type">B</span> *pb=reinterpret_cast&lt;<span class="hljs-type">B</span> *&gt;(a);<br>pb-&gt;func2();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dynamic_cast&lt;type *&gt;(e)</code> 将基类的指针或引用安全的转成其子类的指针和引用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">B:<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">A</span>&#123;&#125;;<br>B b;<br><br>A *pa=dynamic_cast&lt;A *&gt; (&amp;b);<span class="hljs-comment">//返回正常的A*</span><br><span class="hljs-comment">//下面这行代码pa尽管是一个A*指针，但它指向的内存大小是能容纳B类的，故能正常转换</span><br>B *pb=dynamic_cast&lt;B *&gt; (pa);<span class="hljs-comment">//返回正常的B* </span><br><br>A a;<br><span class="hljs-comment">//A类的内存小于B类的内存，下面的操作会返回nullptr</span><br>B *ppb=dynamic_cast&lt;B *&gt;(&amp;a);<span class="hljs-comment">//返回nullptr</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列1-存储持续性、作用域、链接性</title>
    <link href="/2023/03/25/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%971-%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%93%BE%E6%8E%A5%E6%80%A7/"/>
    <url>/2023/03/25/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%971-%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%93%BE%E6%8E%A5%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h2><p>即变量再内存中的存在时间。C++中有三类存储持续性，C++11新增了一种。</p><ul><li>自动存储持续性：<ul><li>存储在栈区。进入代码块前存储，离开代码块就自动销毁</li><li>包括函数内部定义的局部变量和<code>register</code>修饰的寄存器变量</li><li><code>register</code>起初表示期望编译器将该变量存入寄存器以提高性能，但不强制要求编译器这样做。因此现在的编译器都是自己决定什么时候将局部变量存入寄存器，目前绝大部分的编译器会忽略这个关键字。</li></ul></li><li>静态存储持续性<ul><li>存储在数据段和BSS段。程序开始前建立，程序结束才销毁<ul><li>数据段：已初始化的非0的全局变量和已初始化为非0的static变量</li><li>BSS段：未初始化的全局变量和未初始化的static变量，初始化为0的全局变量和初始化为0的static变量</li><li>上述描述的证明程序及截图见下面有关注释。</li></ul></li><li>有外部链接、内部链接、无链接3种<ul><li>静态外部链接：全局变量（一个文件定义，其它文件<code>extern</code>引入声明)</li><li>静态内部链接：static 全局变量（只能定义所在的翻译单元使用）</li><li>静态无链接：static 局部变量（只能在定义所在的代码块内使用）</li></ul></li></ul></li><li>动态存储持续性<ul><li>用new申请的内存会一直存在，直到使用delete进行释放</li></ul></li><li>线程持续性：C++11引入<ul><li>使用<code>thread_local</code>声明，则其生命周期与所属的线程一样长</li></ul></li></ul><h2 id="有关-bss和-data注释"><a href="#有关-bss和-data注释" class="headerlink" title="有关.bss和.data注释"></a>有关.bss和.data注释</h2><p>bss段和data段存储变量验证：<br>程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 这段代码看起来不够规范，例如没有include &lt;iostream&gt;</span><br><span class="hljs-comment">* 也没有return 0;  但我是故意的,尽量不要引入多余参数和操作有利于我们分析</span><br><span class="hljs-comment">* 如果include &lt;iostream&gt; 会导致.bss段多出一个不知道干嘛的数据</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> global_not_init;<span class="hljs-comment">//.BSS</span><br><span class="hljs-type">int</span> global_init_not_zero=<span class="hljs-number">1</span>;<span class="hljs-comment">//.DATA</span><br><span class="hljs-type">int</span> global_init_zero=<span class="hljs-number">0</span>;<span class="hljs-comment">//.BSS</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_global_not_init;<span class="hljs-comment">//.BSS</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_global_init_not_zero=<span class="hljs-number">2</span>;<span class="hljs-comment">//.DATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_global_init_zero=<span class="hljs-number">0</span>;<span class="hljs-comment">//.BSS</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_local_not_init;<span class="hljs-comment">//.BSS</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_local_init_not_zero=<span class="hljs-number">3</span>;<span class="hljs-comment">//.DATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_local_init_zero=<span class="hljs-number">0</span>;<span class="hljs-comment">//.BSS</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>g++ -c bss.cpp -o bss.o</code><br><code>objdump -x bss.o</code> 结果如下：<br><img src="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303251729547.png" alt="image.png"></p><div class="note note-success">            <p>总结：初始化为非0的全局变量和初始化为非0的static变量存在.data区，其它在.bss区</p>          </div><div class="note note-warning">            <p>bss段并不给该段的数据分配空间。程序运行后，系统给bss段的变量分配空间并自动初始化为0.<br>section table(节头表)中保存了bss段变量需要内存空间的大小总和，因此系统知道要分配多少内存该bss段。</p>          </div><p><code>objdump -h bss.o</code> .data段有3个int变量，故为12，.bss段有6个int故为24。（截图中数字为16进制）<br><img src="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303251728729.png" alt="image.png"></p><h2 id="补充C-函数存储位置"><a href="#补充C-函数存储位置" class="headerlink" title="补充C++ 函数存储位置"></a>补充C++ 函数存储位置</h2><ul><li><p>C++ 中，函数的定义放在代码区，包括类成员函数和一般函数。</p></li><li><p>类的成员函数不计入内存空间，这里的成员函数包括一般的、static的、内联的等。</p></li><li><p>但类中存在存在虚函数时，就需要维护一个指向虚函数表的指针。虚函数表详细内容系列2再来讨论。</p></li></ul><p>一个疑惑：类中没有函数信息，那类是怎么找到函数的呢？</p><ul><li>这个问题本身就有问题，不是类找到函数，而是函数找到类</li><li>当我们执行<code>classA.func(a,b)</code>时，可以不那么严谨的认为执行了<code>func(&amp;classA,a,b)</code></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域，即一个变量可以被引用的范围</p><ul><li><p>文件作用域（全局作用域）：在函数和代码块之外声明的变量具有全局作用域</p></li><li><p>局部作用域：在函数内部声明的变量具有局部作用域</p></li><li><p>在代码块内声明的变量具有块作用域。如for循环中声明的临时变量</p></li><li><p>类作用域：在类内部声明的变量。</p><div class="note note-info">            <p>变量的作用域不会因为加了static或const而改变。<br>部分博客认为static将全局变量的作用域改变了，我认为这种描述不好，这种说法大概是认为该变量的作用域由“多个文件“变为了”一个文件“，但我更偏向于认为，”一个文件“就是最大的作用域，其余的文件也是需要extern引入声明后才获得了作用域的。<br>这颇有点咬文嚼字的感觉，但我依然喜欢以下的表述：<br>static将全局变量的链接性由外部链接缩小为内部链接，但作用域仍然是一个文件。<br>const也能将全局变量的链接性由外部链接缩小为内部链接。同样作用域仍然是一个文件</p>          </div><h2 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h2><p>多个文件间的共享性质称为链接性。</p></li><li><p>自动存储类型无链接性（自动变量没有链接性）</p></li><li><p>静态存储类型有外部链接、内部链接、无链接3种</p><ul><li>静态外部链接：全局变量（一个文件定义，其它文件<code>extern</code>引入声明)</li><li>静态内部链接：static 全局变量（只能定义所在的翻译单元使用）</li><li>静态无链接：static 局部变量（只能在定义所在的代码块内使用）</li></ul></li><li><p>动态存储类型无链接性。指针可以是自动的或静态的，但指针所指向的用new申请的区域没有讨论链接性的意义。</p></li></ul><table><thead><tr><th>存储描述</th><th>持续性</th><th>作用域</th><th>链接性</th><th>如何声明</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>代码块</td><td>无</td><td>在代码块中</td></tr><tr><td>静态，无链接</td><td>静态</td><td>代码块</td><td>无</td><td>在代码块中,使用static</td></tr><tr><td>静态，内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>函数和代码块之外，用static</td></tr><tr><td>静态，外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>函数和代码块之外</td></tr></tbody></table><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>static 对全局变量<ul><li>将其由外部链接性缩减为内部链接性</li></ul></li><li>static 对普通函数<ul><li>将其由外部链接性缩减为内部链接性。不能被其它文件链接到</li></ul></li><li>static 对局部变量<ul><li>将其存储持续性（生命周期）由自动变为静态。即该变量会一直存在直到程序结束。</li></ul></li><li>static 类成员变量：<ul><li>所有该类的对象共享一个变量</li><li>若初始化为非0，存储在data段；否则在BSS段</li><li><code>const static int</code>可以在类内进行初始化，其它都要在类外初始化。</li><li>类外初始化 方法： <code>类名::变量名=初值</code></li><li>访问方式：<code>类名::变量名。或者 对象.变量名</code> </li></ul></li><li>static 类成员函数<ul><li>管理static类成员变量</li><li><code>类名::成员函数 。对象.成员函数</code></li><li>没有this指针，只能调用static的数据和static成员函数。</li></ul></li></ul><div class="note note-info">            <p>C语言的static变量会在编译期进行初始化，程序中有初始化为非0的，初始化为响应的值，否则初始化为0.</p><p>而C++由于引入了类和对象，对象的初始化需要调用构造函数，并不像C语言的初始化那么简单，因此C++规定所有的全局变量和static变量（也就是静态持续性变量）需要在首次使用时才进行初始化。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 基础指令</title>
    <link href="/2023/03/25/Linux%20%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/03/25/Linux%20%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="近期使用到的命令"><a href="#近期使用到的命令" class="headerlink" title="近期使用到的命令"></a>近期使用到的命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将a.cpp的内容复制到剪切板。结合windows与虚拟机的共享剪切板很好用</span><br><span class="hljs-built_in">cat</span> a.cpp | xclip -sel clip<br><span class="hljs-comment">#objdump 查看.o文件</span><br><span class="hljs-comment">#查看.data段,.bss段有多大</span><br>objdump -h a.o <br><span class="hljs-comment">#查看.data段和.bss段存放了哪些内容</span><br>objdump -x a.o<br><span class="hljs-comment">#将一篇很长的文件筛选出部分信息</span><br><span class="hljs-comment">#-E 为使用完全的正则表达式</span><br><span class="hljs-comment">#[system] 出现行及其下面两行。[system.cpu]出现的行及其下面两行</span><br>grep -E <span class="hljs-string">&quot;^\[(\w*)\]$|^\[(\w*)\.(\w*)\]$&quot;</span> -A 2 a.txt<br><br></code></pre></td></tr></table></figure><ul><li>whoami 显示当前登录的用户</li><li>hostname 显示当前机器的主机名</li><li>pwd 显示当前的工作目录绝对路劲<br><a name="goNBT"></a><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">.   当前目录<br>..  上一级目录<br>/   根目录<br>~   用户目录<br>-   上一次工作目录<br><br></code></pre></td></tr></table></figure><a name="OR86w"></a><h2 id="ls命令-打印目录文件及文件夹信息"><a href="#ls命令-打印目录文件及文件夹信息" class="headerlink" title="ls命令 : 打印目录文件及文件夹信息"></a>ls命令 : 打印目录文件及文件夹信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> [选项] [路径]<br><span class="hljs-built_in">ls</span> -a  显示隐藏文件<br><span class="hljs-built_in">ls</span> -l   显示详细信息<br><span class="hljs-built_in">ls</span> -hl  显示详细信息，包括人类可读的内存占用<br></code></pre></td></tr></table></figure><a name="COQAK"></a><h2 id="su-切换用户su-用户名"><a href="#su-切换用户su-用户名" class="headerlink" title="su 切换用户su - 用户名"></a>su 切换用户<code>su - 用户名</code></h2><a name="IHYp0"></a><h2 id="logout退出当前用户登录-logout"><a href="#logout退出当前用户登录-logout" class="headerlink" title="logout退出当前用户登录 logout"></a>logout退出当前用户登录 <code>logout</code></h2><a name="mUsEq"></a><h2 id="mkdir-新建文件夹"><a href="#mkdir-新建文件夹" class="headerlink" title="mkdir 新建文件夹"></a>mkdir 新建文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> [选项] [目录]<br><span class="hljs-built_in">mkdir</span> dir1创建文件夹<br><span class="hljs-built_in">mkdir</span> &#123;dir1,dir2,dir3&#125;创建多个文件夹<br><span class="hljs-built_in">mkdir</span> -p ./dir1/dir2/dir3 就算没有dir1,dir2，也可以递归创建出dir1,dir2,dir3<br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span>&#123;1..10&#125;   创建10个文件夹dir1,dir2,...,dir10<br></code></pre></td></tr></table></figure><a name="wCQGf"></a><h2 id="touch-创建普通文件、修改文件事件"><a href="#touch-创建普通文件、修改文件事件" class="headerlink" title="touch 创建普通文件、修改文件事件"></a>touch 创建普通文件、修改文件事件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> [选项] [文件名]<br><span class="hljs-built_in">touch</span> a.txt b.py c.cpp<br><span class="hljs-built_in">touch</span> text&#123;a..z&#125;.txt  main&#123;1..3&#125;.cpp<br><span class="hljs-built_in">touch</span> -t 03160910 a.txt 修改文件的修改时间为3月16日9点10分<br></code></pre></td></tr></table></figure><a name="Pv1Vo"></a><h2 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a>cp 复制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> [选项] 源文件 目标文件<br><span class="hljs-built_in">cp</span> a.txt b.cpp c.py ./dir/复制多个文件到目标文件夹<br><span class="hljs-built_in">cp</span> -r dir1 dir2 复制整个文件夹需要加上-r参数<br><span class="hljs-built_in">cp</span> -d a.out b.out 复制，保存软连接不变<br><span class="hljs-built_in">cp</span> -i 复制前询问，防止意外覆盖<br></code></pre></td></tr></table></figure><a name="jL2Dm"></a><h2 id="mv-移动文件、重命名文件"><a href="#mv-移动文件、重命名文件" class="headerlink" title="mv 移动文件、重命名文件"></a>mv 移动文件、重命名文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> [选项] [一个或多个源文件] 目标文件或目录<br><span class="hljs-built_in">mv</span> a.txt b.cpp ./dir/  移动一个或多个文件到目标目录<br><span class="hljs-built_in">mv</span> *.cpp ./dir/ <br><span class="hljs-built_in">mv</span> a.txt aa.txt 重命名文件<br></code></pre></td></tr></table></figure><a name="vsPL2"></a><h2 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a>rm 删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [选项] 文件<br><span class="hljs-built_in">rm</span> a.txt 删除文件<br><span class="hljs-built_in">rm</span> a.txt b.txt<br><span class="hljs-built_in">rm</span> text*.txt  <br><span class="hljs-built_in">rm</span> -r <span class="hljs-built_in">dir</span> 递归删除目录<br><span class="hljs-built_in">rm</span> -d dir0 只能用来删除空文件夹<br><span class="hljs-built_in">rm</span> -f abb* 强制删除所有以abb开头的文件<br><span class="hljs-built_in">rm</span> -r -f ./*   强制删除当前目录下的所有内容<br></code></pre></td></tr></table></figure><a name="o0Mey"></a><h2 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctrl+a 回到命令行开头<br>ctrl+e 命令行结尾<br>ctrl+l 清空<br>ctrl+d 从光标出删除一个字符<br></code></pre></td></tr></table></figure><a name="WfYQy"></a><h2 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.读取文件内容，写入另一个文件中<br><span class="hljs-built_in">cat</span> src.txt &gt; dest.txt重定向输出覆盖<br><span class="hljs-built_in">cat</span> src.txt &gt;&gt; dest.txt 重定向追加<br>2.重定向写入符<br><span class="hljs-built_in">cat</span> &lt; src.txt  <br>将文本内容拆分<br>xargs -n 3 &lt; src.txt 限制每行只能输出3个字符<br><span class="hljs-built_in">cat</span> &gt;&gt; dest.txt &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">cat -n a.txt 显示行号，参数-n</span><br></code></pre></td></tr></table></figure><a name="StbNt"></a><h2 id="cat-查看文本内容"><a href="#cat-查看文本内容" class="headerlink" title="cat 查看文本内容"></a>cat 查看文本内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看文本内容<br><span class="hljs-built_in">cat</span> file.txt<br>-b 对非空行显示行号<br>-n 对所有行显示行号<br>2. 多个文件合并<br><span class="hljs-built_in">cat</span> file1.txt file2.txt &gt; file3.txt<br>3.非交互式编辑或追加内容<br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; <span class="hljs-string">EOF 这是追加内容 EOF</span><br>4.清空文件内容<br><span class="hljs-built_in">cat</span> /dev/null &gt; file.txt<br><br></code></pre></td></tr></table></figure><a name="Q3qws"></a><h2 id="head-查看文件开头几行"><a href="#head-查看文件开头几行" class="headerlink" title="head 查看文件开头几行"></a>head 查看文件开头几行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> a.txt  查看前10行<br><span class="hljs-built_in">head</span> -n 5 a.txt 查看前5行<br><span class="hljs-built_in">head</span> -n -5 a.txt 查看倒数第5行之前所有<br></code></pre></td></tr></table></figure><a name="LYV36"></a><h2 id="tail-查看文件末尾几行"><a href="#tail-查看文件末尾几行" class="headerlink" title="tail 查看文件末尾几行"></a>tail 查看文件末尾几行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">能实时刷新显示a.txt的末尾变化<br><span class="hljs-built_in">tail</span> -F a.txt<br></code></pre></td></tr></table></figure><a name="llDrz"></a><h2 id="stat-查看文件详细信息"><a href="#stat-查看文件详细信息" class="headerlink" title="stat 查看文件详细信息"></a>stat 查看文件详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看文件详细信息<br>-f : 显示文件系统状态而非文件状态<br>-t : 以简洁方式输出<br></code></pre></td></tr></table></figure><a name="vaq5n"></a><h2 id="chmod-权限设置"><a href="#chmod-权限设置" class="headerlink" title="chmod 权限设置"></a>chmod 权限设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">r,w,x : 读、写、执行<br>用户-用户所在组-所有<br>111=7 可读可写可执行<br>110=6 可读可写不可执行<br>010=2 只可写<br><span class="hljs-built_in">chmod</span> 777 a.txt <br></code></pre></td></tr></table></figure><a name="ZKXQ0"></a><h2 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a>find 查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">find 路径 选项 文件名<br>搜索*.txt与*.cpp 但过滤a.*<br>-a 与；-o 或；-not 非<br>！！！注意空格！！！每个\(或\)的左后两边都要有空格。指令与指令之间也要有空格<br>find . \( -not -name <span class="hljs-string">&quot;a.*&quot;</span> \) -a \( -name <span class="hljs-string">&quot;*.txt&quot;</span> -o -name <span class="hljs-string">&quot;*.cpp&quot;</span> \) <br>根据正则表达式查找<br>find . -regex <span class="hljs-string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span><br>-ok 执行后面的指令，并询问是否确定执行&#123;&#125; 中的是find找到的内容 <br>-<span class="hljs-built_in">exec</span> 执行后面的指令，不询问<br>注意以\;结尾<br>删除*.txt并逐一询问是否确定删除<br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -ok <span class="hljs-built_in">rm</span> &#123;&#125; \;<br>合并所有*.txt到all.txt<br>find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.txt&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cat</span> &#123;&#125; &gt; all.txt \;<br>-<span class="hljs-built_in">type</span> f 文件 -<span class="hljs-built_in">type</span> d 文件夹<br>将30天前的<span class="hljs-built_in">log</span>文件移动到old目录<br>find . -<span class="hljs-built_in">type</span> f -mtime +30 -name <span class="hljs-string">&quot;*.log&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cp</span> &#123;&#125; old \;<br>-atime 访问时间<br>-ctime 改变事件 +30超过30天，-5 5天内，5 正好5天前<br></code></pre></td></tr></table></figure><a name="Sr17b"></a><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">? 匹配一个任意字符<br>* 匹配0个或多个任意字符<br>[] 匹配中括号中的任意一个字符，例如[abc]匹配a或b或c<br>[a-m] [2-4] 匹配范围内的任意一个字符<br>[^] 逻辑非。例如[a^1-9].txt   匹配a.txt,但不匹配a1.txt,a2.txt<br>^ 匹配行首<br>$ 匹配行尾<br></code></pre></td></tr></table></figure><a name="arZ3I"></a><h2 id="grep-搜索匹配并打印"><a href="#grep-搜索匹配并打印" class="headerlink" title="grep 搜索匹配并打印"></a>grep 搜索匹配并打印</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">在文件内搜索匹配<br>grep <span class="hljs-string">&quot;match_pattern&quot;</span> file1.txt file2.txt<br>递归搜索当前目录及所有子目录中的问价<br>grep -r <span class="hljs-string">&quot;match_pattern&quot;</span><br>正则匹配输出以数字开头的所有行<br>grep <span class="hljs-string">&quot;^[0-9].*&quot;</span> file.txt<br></code></pre></td></tr></table></figure><a name="HEj5C"></a><h2 id="tar-压缩和解压缩"><a href="#tar-压缩和解压缩" class="headerlink" title="tar 压缩和解压缩"></a>tar 压缩和解压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#=======================&quot;.tar&quot;格式=========================</span><br><span class="hljs-comment">#打包不会压缩</span><br>tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg<br><span class="hljs-comment">#解打包到当前目录</span><br>tar -xvf anaconda-ks.cfg.tar<br><span class="hljs-comment">#解打包到指定目录</span><br>tar -xvf anaconda-ks.cfg.tar -C /testdir/<br><br><span class="hljs-comment">#=====================&quot;.tar.gz&quot;格式=====================</span><br><span class="hljs-comment">#把/tmp/目录直接打包并压缩为&quot;.tar.gz&quot;格式</span><br>tar -zcvf tmp.tar.gz /tmp/<br><span class="hljs-comment">#解压缩并解打包&quot;.tar.gz&quot;格式文件</span><br>tar -zxvf tmp.tar.gz<br></code></pre></td></tr></table></figure><a name="KsbWb"></a><h2 id="cut-分割"><a href="#cut-分割" class="headerlink" title="cut 分割"></a>cut 分割</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.txt的每行的第4-7个字符<br><span class="hljs-built_in">cut</span> -c 4-7 a.txt<br><span class="hljs-built_in">cut</span> -c 5,6 a.txt 每行的第5个和第6个字符<br><span class="hljs-built_in">cut</span> -c -6 a.txt 每行的前6个字符<br>a.txt每行用:分割。取出分割结果的1-3个<br><span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f 1-3 a.txt<br><span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f 3- a.txt 分割结果的第三个到最后<br></code></pre></td></tr></table></figure><a name="hMHfX"></a><h2 id="paste-合并"><a href="#paste-合并" class="headerlink" title="paste 合并"></a>paste 合并</h2>与cut相反<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">两个文件按列合并<br><span class="hljs-built_in">paste</span> a.txt b.txt<br>按列合并，并用 : 连接<br><span class="hljs-built_in">paste</span> -d <span class="hljs-string">&quot;:&quot;</span> a.txt b.txt<br></code></pre></td></tr></table></figure><a name="D7hDp"></a><h2 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.对文件进行排序<br><span class="hljs-built_in">sort</span> a.txt 数字排在前面，字母排在后面<br><span class="hljs-built_in">sort</span> -r a.txt 逆序（从大到小）<br>2. 对文件每行按照第一个字符按照数字排序。如果第一个字符不是数字，就认为是数字0<br><span class="hljs-built_in">sort</span> -n a.txt 默认从小到大排序<br><span class="hljs-built_in">sort</span> -nr a.txt 从大到小排序<br>3.对排序结果去重<br><span class="hljs-built_in">sort</span> -u a.txt<br>4.指定分割符号,指定区域进行排序<br><span class="hljs-built_in">sort</span> -n -t <span class="hljs-string">&quot;.&quot;</span> -k 4 ip.txt<br></code></pre></td></tr></table></figure><a name="fOoXm"></a><h2 id="uniq-去重"><a href="#uniq-去重" class="headerlink" title="uniq 去重"></a>uniq 去重</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.去除连续出现的行<br><span class="hljs-built_in">uniq</span> a.txt<br><span class="hljs-built_in">uniq</span> -c a.txt 显示重复出现的次数<br>2.一般结合<span class="hljs-built_in">sort</span>使用<br><span class="hljs-built_in">sort</span> -n a.txt | <span class="hljs-built_in">uniq</span> -c<br>3.找出只出现一次的行<br><span class="hljs-built_in">sort</span> -n a.txt | <span class="hljs-built_in">uniq</span> -c -u<br></code></pre></td></tr></table></figure><a name="v5hCo"></a><h2 id="wc-单词统计"><a href="#wc-单词统计" class="headerlink" title="wc 单词统计"></a>wc 单词统计</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.统计文件的行数<br><span class="hljs-built_in">wc</span> -l a.txt<br>2.统计单词数量<br><span class="hljs-built_in">wc</span> -w a.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test1 test2&quot;</span> | <span class="hljs-built_in">wc</span> -w 结果为2两个单词<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;好 啊 不好&quot;</span> | <span class="hljs-built_in">wc</span> -w 结果为3<br>3.统计字符数(包括结尾的$符号<br><span class="hljs-built_in">wc</span> -m a.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test&quot;</span> | <span class="hljs-built_in">wc</span> -m  结果为5<br>4.输出最长行的字符数<br><span class="hljs-built_in">cat</span> a.txt | <span class="hljs-built_in">wc</span> -L<br></code></pre></td></tr></table></figure><a name="JwKbv"></a><h2 id="tr-从标准输入中替换、所见或删除字符，将结果写到标准输出"><a href="#tr-从标准输入中替换、所见或删除字符，将结果写到标准输出" class="headerlink" title="tr 从标准输入中替换、所见或删除字符，将结果写到标准输出"></a>tr 从标准输入中替换、所见或删除字符，将结果写到标准输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 替换一部分字符<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;my name is lumos&quot;</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[a-z]&#x27;</span> <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br><span class="hljs-comment">#MY NAME IS LUMOS</span><br>2.删除一部分字符 -d 选项<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;my name is lumos and i an 21 years old&quot;</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;a-z&#x27;</span><br><span class="hljs-comment">#21</span><br>3.把文件中的内容进行替换(把文件当作标准输入<br><span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt; a.txt<br>4.去除连续重复字符 -s选项<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;iii am lllumoos&quot;</span> | <span class="hljs-built_in">tr</span> -s  <span class="hljs-string">&#x27;ialo&#x27;</span><br><span class="hljs-comment">#i am lumos</span><br></code></pre></td></tr></table></figure><a name="UZMmi"></a><h2 id="xargs-管道命令，构造参数等"><a href="#xargs-管道命令，构造参数等" class="headerlink" title="xargs 管道命令，构造参数等"></a>xargs 管道命令，构造参数等</h2>简单的说就是，把其它命令给他的数据，传递给它后面的命令作为参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.txt:<br>1 2<br>3 4 5<br>1.多行连接输出<br>xargs &lt; a.txt<br><span class="hljs-comment">#1 2 3 4 5 </span><br>2.-n 每行最多输出原来的n行<br>xargs -n &lt; a.txt<br>3. -d 分割<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a,b,c&quot;</span> | xargs -d <span class="hljs-string">&quot;,&quot;</span> -n 2<br>3. -i &#123;&#125;替代传输的数据<br>将当前所有的txt文件，移动到<span class="hljs-built_in">dir</span>目录<br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> | xargs -i <span class="hljs-built_in">mv</span> &#123;&#125; <span class="hljs-built_in">dir</span>/<br>4. -I 用字符串替换数据<br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> | xargs -I alltxt <span class="hljs-built_in">mv</span> alltxt <span class="hljs-built_in">dir</span>/<br></code></pre></td></tr></table></figure><a name="j9Hxv"></a><h2 id="join-合并"><a href="#join-合并" class="headerlink" title="join 合并"></a>join 合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">只能对排序好的文件使用<br>将两个文件，按照某列为匹配字段进行合并<br>依照a文件的ID1段和b文件ID2段进行合并,指定分隔符为<span class="hljs-string">&quot; &quot;</span> <br><span class="hljs-built_in">join</span> -1 ID1 -2 ID2 -t <span class="hljs-string">&quot; &quot;</span> a.txt b.txt &gt; c.txt<br>a.txt<br>zhou 2000 1<br>li 2500 2<br>wan 2000 2<br>zhan 2600 2<br>b.txt <br>zhou c 1<br>zhan java 2<br>wan php 3<br><br>c.txt<br>1 zhou 2000 zhou c<br>2 li 2500 zhan java<br>2 wan 2000 zhan java<br>2 zhan 2600 zhan java<br></code></pre></td></tr></table></figure><a name="pi9eA"></a><h2 id="comm-比较文件内容"><a href="#comm-比较文件内容" class="headerlink" title="comm 比较文件内容"></a>comm 比较文件内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 比较文件内容<br><span class="hljs-built_in">comm</span> a.txt b.txt<br>-1 不输出文件1特有的行<br>-2 不输出文件2特有的行<br>-3 不输出两个文件共有的行<br>2.只显示两个文件共有部分<br><span class="hljs-built_in">comm</span> -12 a.txt b.txt<br></code></pre></td></tr></table></figure><a name="EI20q"></a><h2 id="diff-比较文件不同"><a href="#diff-比较文件不同" class="headerlink" title="diff 比较文件不同"></a>diff 比较文件不同</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">diff a.txt b.txt<br>-c 上下文模式，显示全部内文，并标出不同之处<br>-u 统一模式，以合并的方式来显示文件内容的不同<br></code></pre></td></tr></table></figure><a name="peBXG"></a><h2 id="df-查看磁盘占用情况"><a href="#df-查看磁盘占用情况" class="headerlink" title="df 查看磁盘占用情况"></a>df 查看磁盘占用情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span>是disk free的缩写<br><span class="hljs-built_in">df</span> [选项] 文件（磁盘）<br>1.显示磁盘使用情况<br><span class="hljs-built_in">df</span><br>2. 以inode模式显示<br><span class="hljs-built_in">df</span> -i<br>3.列出文件系统的类型<br><span class="hljs-built_in">df</span> -T<br></code></pre></td></tr></table></figure><a name="uoXcJ"></a><h2 id="du-查看文件和目录的占用情况"><a href="#du-查看文件和目录的占用情况" class="headerlink" title="du 查看文件和目录的占用情况"></a>du 查看文件和目录的占用情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a 显示目录中所有文件的大小<br>-h 以K,M,G为单位，提高信息可读性<br>-c 显示综合<br><span class="hljs-built_in">du</span> -h a.txt 文件a.txt的占用<br><span class="hljs-built_in">du</span> -ch a.txt b.txt 两个文件的占用及其总和<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

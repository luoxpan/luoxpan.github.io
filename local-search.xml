<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>董豪-深度学习入门与实践</title>
    <link href="/2024/11/03/deeplearning/%E8%91%A3%E8%B1%AA-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/11/03/deeplearning/%E8%91%A3%E8%B1%AA-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>https://www.bilibili.com/video/BV1pM411B7BK</p><h1 id="神经网络基础">神经网络基础</h1><h2 id="单层神经网络single-neuron">单层神经网络(Single Neuron)</h2><p>3 个input，一个output</p><p><span class="math inline">\(z=x_1w_1+x_2w_2+x_3w_3+b\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>x = np.array([<span class="hljs-number">0.5</span>,<span class="hljs-number">0.8</span>])<br>w = np.array([<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>])<br>b = <span class="hljs-number">0.3</span><br><br>z = np.dot(x,w)+b<br></code></pre></td></tr></table></figure><p>3个input，2个output</p><p><spanclass="math inline">\(z_1=x_1w_{11}+x_2w_{12}+x_3w_{13}+b_1\)</span></p><p><spanclass="math inline">\(z_2=x_1w_{21}+x_2w_{22}+x_3w_{23}+b_2\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>x = np.array([<span class="hljs-number">0.5</span>,<span class="hljs-number">0.8</span>])<br>w = np.array([[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>]])<br>b = np.array([<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>])<br><br>z = np.dot(x,w)+b<br></code></pre></td></tr></table></figure><h3 id="激活函数">激活函数</h3><p>上面的<span class="math inline">\(z\)</span>是一个线性函数，为了拟合非线性函数，引入激活函数。</p><p>输出值到[0,1]之间：sigmoid</p><p><span class="math inline">\(y=\frac{1}{1+e^{-z}}\)</span></p><p>输出值到[-1,1]之间：tanh</p><p><spanclass="math inline">\(y=\frac{e^z-e^{-z}}{e^z+e^{-z}}\)</span></p><p>输出值到任意区间：ReLU</p><p><span class="math inline">\(y=max(0,z)\)</span></p><p>leaky ReLU</p><p><span class="math inline">\(y=max(\alpha z,z)\)</span></p><p>多分类激活函数：softmax</p><p><spanclass="math inline">\(y_i=\frac{e^{z_i}}{\sum_{j=1}^{n}e^{z_j}}\)</span></p><h3 id="多层神经网络">多层神经网络</h3><p>多层神经网络就是多个单层神经网络叠加起来。</p><p>单层神经网络甚至无法完成XOR这样的任务，XOR是一个线性不可分问题，引入隐藏层，隐藏层提取出特征之后，再通过输出层完成分类，可以完成XOR任务。</p><p>更复杂的问题还需要引入更多隐藏层。</p><h2 id="损失函数">损失函数</h2><p>损失函数：网络输出和预测输出之间的差异。</p><p>逻辑回归的损失函数：交叉熵损失函数</p><p><spanclass="math inline">\(loss=-\frac{1}{m}\sum_{i=1}^{m}y_i\log(y&#39;_i)+(1-y_i)\log(1-y&#39;_i)\)</span></p><p>多分类的损失函数：交叉熵损失函数</p><p><spanclass="math inline">\(loss=-\frac{1}{m}\sum_{i=1}^{m}\sum_{j=1}^{n}y_{ij}\log(y&#39;_{ij})\)</span></p><p><span class="math inline">\(L_p\)</span>正则($L_p norm):衡量一个向量的幅度</p><p><span class="math display">\[\begin{aligned}&amp;\|x\|_{p}\:=\left(\sum_{k=1}^{K}|x_{k}|^{p}\right)^{\frac{1}{p}}\\&amp;\|x\|_{p}^{p}=\sum_{k=1}^{K}|x_{k}|^{p}\end{aligned}\]</span></p><p>扩展一下可以用来衡量两个向量之间的差距。</p><p><span class="math display">\[\mathcal{L}_{p}=\|\boldsymbol{y}-\boldsymbol{a}\|_{p}^{p}=\sum_{k=1}^{K}|\boldsymbol{y}_{k}-\boldsymbol{a}_{k}|^{p}\]</span></p><p>最常用的是<spanclass="math inline">\(L_2\)</span>正则损失，也就是MSE(均方差误差)。</p><p><span class="math display">\[\mathcal{L}_{M S E}=\frac{1}{m}\sum_{i=1}^{m}\left(\boldsymbol{y}_{i}-\boldsymbol{a}_{i}\right)^{2}\]</span></p><p><spanclass="math inline">\(L_1\)</span>正则损失函数，也就是MAE(平均绝对误差)。</p><p><span class="math display">\[\mathcal{L}_{M A E}=\frac{1}{m}\sum_{i=1}^{m}\left|\boldsymbol{y}_{i}-\boldsymbol{a}_{i}\right|\]</span></p><h2 id="梯度下降">梯度下降</h2><p>梯度下降：通过梯度下降算法，不断调整参数，使得损失函数最小化。</p><p>梯度下降的公式： <spanclass="math inline">\(w:=w-\alpha\frac{\partial\mathcal{L}}{\partialw}\)</span></p><p>梯度下降理论上只能找到局部最优解，但由于网络很深很大，再神经网络中一般不用担心局部最优的问题，但需要考虑鞍点问题。</p><h2 id="反向传播">反向传播</h2><p>反向传播：计算损失函数对每个参数的梯度。</p>$$<span class="math display">\[\begin{aligned}&amp;\text{1. Given:}\\&amp;\bullet\:a^l=f(z^l)=\frac1{1+e^{-z^l}}\\&amp;\bullet\:z^l=\boldsymbol{W}^{l^T}\boldsymbol{a}^{l-1}+\boldsymbol{b}^l\\&amp;\bullet\:\mathcal{L}=\frac12(\mathbf{y}-\boldsymbol{a}^L)^2\\&amp;\text{2. Then we can have the following derivatives:}\\&amp;\bullet\:\frac{\partial a^l}{\partialz^l}=f^{-1}(z^l)=\boldsymbol{a}^l\circ(1-\boldsymbol{a}^l)\\&amp;\bullet\:\frac{\partial \mathcal{L}}{\partial a^l}=(a^l-y)\\&amp;\bullet\frac{\partial\mathbf{z}^{l}}{\partialW^{l}}=\boldsymbol{a}^{l-1}\mathrm{and}\:\frac{\partial\mathbf{z}^{l}}{\partial\boldsymbol{b}^{l}}=1\\&amp;3.\text{Then the error of the output layer}\\&amp;\bullet\:\delta^L=\frac{\partial \mathcal{L}}{\partialz^L}=\frac{\partial \mathcal{L}}{\partial a^L}\frac{\partiala^L}{\partial z^L}=(a^L-y)\circ(a^L\circ(1-a^L))\\&amp;\text{4.Then the error of the other layers}l=\mathbf{1}...L-\mathbf{1}:\\&amp;\bullet\delta^{l}=\frac{\partial\mathcal{L}}{\partial\boldsymbol{z}^{l}}=\frac{\partial\mathcal{L}}{\partial\boldsymbol{z}^{l+1}}\frac{\partial\boldsymbol{z}^{l+1}}{\partial\boldsymbol{z}^{l}}=\delta^{l+1}\frac{\partial\boldsymbol{z}^{l+1}}{\partial\boldsymbol{z}^{l}}\\&amp;\quad\bullet\:z^{l+1}=W^{l+1^T}a^{l}+b^{l+1}\\&amp;\quad\bullet\:\frac{\partial z^{l+1}}{\partialz^{l}}=\boldsymbol{W}^{l+1^T}f^{-1}(z^{l})=\boldsymbol{W}^{l+1^T}\circ(\boldsymbol{a}^{l}\circ(1-\boldsymbol{a}^{l}))\\&amp;\bullet\:\delta^{l}=\frac{\partial\mathcal{L}}{\partialz^{l}}=\frac{\partial\mathcal{L}}{\partialz^{l+1}}\frac{\partial\boldsymbol{z}^{l+1}}{\partialz^{l}}=\boldsymbol{W}^{l+1^T}\delta^{l+1}\circ(\boldsymbol{a}^{l}\circ(1-\boldsymbol{a}^{l}))\\&amp;\text{5.The the gradientsare:}\\&amp;\bullet\:\frac{\partial\mathcal{L}}{\partial\boldsymbol{W}^{l}}=\frac{\partial\mathcal{L}}{\partial\boldsymbol{z}^{l}}\frac{\partial\boldsymbol{z}^{l}}{\partial\boldsymbol{W}^{l}}=\delta^{l}\frac{\partial\boldsymbol{z}^{l}}{\partial\boldsymbol{W}^{l}}=\delta^{l}\boldsymbol{a}^{l-1^T}\\&amp;\bullet\frac{\partial{\mathcal L}}{\partialb^{l}}=\frac{\partial{\mathcal L}}{\partialz^{l}}\frac{\partial\mathbf{z}^{l}}{\partial\boldsymbol{b}^{l}}=\delta^{l}\frac{\partial\mathbf{z}^{l}}{\partial\boldsymbol{b}^{l}}=\delta^{l}\\&amp;\text{6.Update parametersiteratively}\\&amp;W^{l}:=W^{l}-\alpha\:\frac{\partial\mathcal{L}}{\partial\boldsymbol{W}^{l}}\quadb^{l}:=b^{l}-\alpha\:\frac{\partial\mathcal{L}}{\partial\boldsymbol{b}^{l}}\end{aligned}\]</span><p>$$</p><p>为什么sigmoid函数会导致梯度消失？</p><p><span class="math display">\[\delta^{l}=\frac{\partial\mathcal{L}}{\partial\mathbf{z}^{l+1}}=\frac{\partial\mathcal{L}}{\partial\mathbf{z}^{l+1}}\frac{\partial\mathbf{z}^{l+1}}{\partial\mathbf{z}^{l}}=\delta^{l+1}\boldsymbol{W}^{l+1^T}\circ(a^{l}\circ(1-a^{l}))\]</span></p><p><spanclass="math inline">\(a^l\circ(1-a^l)\)</span>是sigmoid函数的导数，当<spanclass="math inline">\(a^l\)</span>接近0或1时，<spanclass="math inline">\(a^l\circ(1-a^l)\)</span>接近0，且这种现象在深层网络中会进一步放大，导致梯度消失。</p><h2 id="优化算法">优化算法</h2><h3 id="mini-batch-随机梯度下降sgd">mini-batch 随机梯度下降（SGD）</h3><p>每次迭代使用所有的数据来计算损失值和梯度，代价太大，速度慢。</p><p>每次迭代随机选取一个mini-batch来计算损失值，更新梯度。</p><h3 id="自适应学习率">自适应学习率</h3><p>学习率是超参数，需要手动设置，且难以选择。</p><p>自适应学习率算法会根据梯度的大小自动调整学习率，如Adam、RMSprop等。</p><h3 id="防止过拟合">防止过拟合</h3><p>解决过拟合问题的最直观的方法是增加数据集，但很多时候没有这么多训练数据，因此有了数据增强的方法。</p><p>正则化是一种防止过拟合的方法，通过在损失函数中添加一个正则化项来限制模型的复杂度。这种方法也称为权重衰减。</p><p>正则化：<spanclass="math inline">\(\mathcal{L}_{total}=\mathcal{L}+\lambda\|W\|\)</span></p><p>L1正则化：<spanclass="math inline">\(\|W\|_1=\lambda\sum_{i=1}^{n}\left|w_{i}\right|\)</span></p><p>L2正则化：<spanclass="math inline">\(\|W\|_2^2=\lambda\sum_{i=1}^{n}w_{i}^{2}\)</span></p><p>Dropout是一种防止过拟合的方法，通过在训练过程中随机丢弃一部分神经元来实现的。</p><p>Dropout可以看作是一种集成学习方法，每次迭代都会训练一个不同的模型，然后将这些模型的预测结果进行平均。</p><p>Dropout可以防止过拟合，但会增加训练时间。该方法基本只在全连接层中使用。</p><p>批量归一化：作用于层的内部，先将层的输出进行归一化，然后才进入激活层。注意再使用批量归一化的层的上一层不要加bias参数。</p><h1 id="卷积神经网络cnn">卷积神经网络（CNN）</h1><h2 id="动机">动机</h2><p>为什么需要为图像设计专门的神经网络？</p><p>因为一个图像上的数据点很多，如果使用全连接层，参数太多，计算量太大。</p><p>同时人们发现，图像的局部区域是高度相关的，因此可以使用卷积层来提取局部特征。</p><h2 id="卷积层">卷积层</h2><p>卷积层的作用是提取局部特征。</p><p>卷积层的基本思想是使用一个小的滑动窗口（称为卷积核）在输入数据上滑动，然后计算窗口内的数据与卷积核的乘积之和。</p><p>卷积核的大小是超参数，通常为3x3或5x5。</p><p>卷积层可以提取图像的边缘、纹理等特征。</p><p>padding和stride的计算：</p><figure><img src="https://s2.loli.net/2024/11/04/idPEM3f5ODKJom7.png"alt="idPEM3f5ODKJom7.png" /><figcaption aria-hidden="true">idPEM3f5ODKJom7.png</figcaption></figure><h2 id="池化层">池化层</h2><p>池化层的作用是进行特征聚合，减少参数数量。</p><p>池化层的基本思想是使用一个小的滑动窗口（称为池化核）在输入数据上滑动，然后取窗口内的最大值或平均值。</p><p>池化层可以减少特征的数量，同时保留重要的特征。</p><figure><img src="https://s2.loli.net/2024/11/04/r1T7I5qfhHgkMeA.png"alt="r1T7I5qfhHgkMeA.png" /><figcaption aria-hidden="true">r1T7I5qfhHgkMeA.png</figcaption></figure><h2 id="卷积神经网络的结构">卷积神经网络的结构</h2><p>卷积神经网络通常由多个卷积层、池化层和全连接层组成。</p><p>卷积层用于提取图像的局部特征，池化层用于进行特征聚合，全连接层用于进行分类。</p><p>经典的卷积神经网络结构包括LeNet、AlexNet、VGGNet、GoogLeNet和ResNet等。</p><h2 id="反卷积转置卷积">反卷积（转置卷积）</h2><p>反卷积是一种卷积操作的逆操作，用于将特征图恢复到原始大小。</p><h1 id="计算机视觉算法">计算机视觉算法</h1><h2 id="目标检测">目标检测</h2><h3 id="如何评价检测结果的好坏">如何评价检测结果的好坏？</h3><p>IoU（Intersection overUnion）表示预测框和真实框的交集与并集的比值。</p><figure><img src="https://s2.loli.net/2024/11/04/Wr1qZHsU8QIEnwA.png"alt="Wr1qZHsU8QIEnwA.png" /><figcaption aria-hidden="true">Wr1qZHsU8QIEnwA.png</figcaption></figure><p>目标检测的准确率和召回率是两个常用的评价指标。</p><p>准确率（Precision）表示预测为正样本中实际为正样本的比例。</p><p>TP表示真正例，FP表示假正例。TP 有东西且识别出东西的概率，FP没有东西但识别出东西的概率。</p><p><spanclass="math inline">\(Precision=\frac{\text{TP}}{\text{TP}+\text{FP}}\)</span></p><p>召回率（Recall）表示实际为正样本中被预测为正样本的比例。</p><p><spanclass="math inline">\(\text{Recall}=\frac{\text{TP}}{\text{TP}+\text{FN}}\)</span></p><p>FN 表示有东西但没识别出东西的概率。</p><p>mAP（Mean AveragePrecision）是目标检测任务中常用的评价指标，它考虑了每个类别的准确率和召回率。</p><h3 id="r-cnn">R-CNN</h3><p>R-CNN（Region-based Convolutional NeuralNetworks）是一种经典的目标检测算法。</p><p>R-CNN的基本思想是使用选择性搜索算法（SelectiveSearch）在图像中提取候选区域，然后对这些候选区域进行卷积神经网络的特征提取，最后使用支持向量机（SVM）进行分类。</p><p>步骤： 1. 使用选择性搜索算法在图像中找出2000个候选区域。 2.将每个候选区域缩放调整为指定大小 3.对缩放后的候选区域使用VGG进行卷积神经网络的特征提取。 4.使用SVM对特征进行分类，得到每个候选区域的类别和边框 5.一张图里没有2000个物品，所以还需要非极大值抑制（NMS）来去除重叠的候选区域。</p><p>R-CNN有许多不足： 1. 搜索算法很慢 2.无论什么大小的候选区域都缩放为指定大小，影响了特征提取的效果 3.在每个候选区域上使用VGG进行特征提取，计算量很大 4. 并非端到端训练</p><h3 id="sppnet">SPPNet</h3><p>SPPNet（Spatial Pyramid PoolingNetwork）是对R-CNN的改进，它解决了R-CNN的2、3问题。</p><p>提出了空间金字塔池化，把不同尺寸的候选区域映射到固定大小的特征向量，从而避免了缩放候选区域的问题。</p><p>将整张图作为输入，而不是每个候选区域都执行VGG网络。</p><p>SPP 的缺点： 1. 依然使用选择算法，速度慢 2.依然没有使用端到端训练</p><h3 id="fast-r-cnn">Fast R-CNN</h3><p>FastR-CNN是对R-CNN的改进，它将候选区域的特征提取和分类过程合并为一个网络，从而减少了计算量。</p><ol type="1"><li>提出了ROIPooling层，他是空间金字塔池化的简化版本，只有一个池化尺度</li><li>将分类和边框回归合并为一个神经网络，而不是使用传统机器学习SVM进行分类</li></ol><p>Fast R-CNN的缺点： 1. 依然使用选择算法</p><h3 id="faster-r-cnn">Faster R-CNN</h3><p>Faster R-CNN是对FastR-CNN的改进，它将候选区域的生成和特征提取过程合并为一个网络，从而进一步减少了计算量。</p><ol type="1"><li>提出了Region Proposal Network（RPN），用于生成候选区域</li><li>完全的端到端训练</li></ol><figure><img src="https://s2.loli.net/2024/11/04/fTx3boszd6ecF7u.png"alt="fTx3boszd6ecF7u.png" /><figcaption aria-hidden="true">fTx3boszd6ecF7u.png</figcaption></figure><h3 id="yolo">YOLO</h3><p>YOLO（You Only Look Once）是一种实时目标检测算法。</p><figure><img src="https://s2.loli.net/2024/11/04/PU4yExK62FaVstj.png"alt="PU4yExK62FaVstj.png" /><figcaption aria-hidden="true">PU4yExK62FaVstj.png</figcaption></figure><p>前面就是一堆卷积，关键在于理解最后的输出(7x7x30)。</p><p>7x7是网格大小，表示把一个图片分为7x7的网格。每个格子有一个30维的向量，这个向量里面就是这个网格的预测结果。</p><p>这30个参数分别表示什么？</p><p>其中10个分为两个部分，表示以这个网格为中心检测到的两个物体的边框坐标和置信度。可以看出它的一个假设是每个小框里面有两个物体。</p><figure><img src="https://s2.loli.net/2024/11/04/v7PZIBmsDOj3cVh.png"alt="v7PZIBmsDOj3cVh.png" /><figcaption aria-hidden="true">v7PZIBmsDOj3cVh.png</figcaption></figure><p>剩余20个参数预测这个边框属于哪一个类别。</p><p>注意： *一个cell预测的两个边框共用一个类别预测，在训练是会选取与标签IoU更大的一个边框负责回归该真实物体框，在测试时会选取置信度更高的一个边框，另一个被舍弃，因此7x9个cell最多只能预测49个物体。</p><p>最后YOLO算法还需要执行NMS算法去除重叠区域。</p><figure><img src="https://s2.loli.net/2024/11/04/f4PejKQSL2TuD1o.png"alt="f4PejKQSL2TuD1o.png" /><figcaption aria-hidden="true">f4PejKQSL2TuD1o.png</figcaption></figure><p>YOLO 的缺陷：</p><p>检测小物体效果不好，因为一个网格只能检测两个物体，所以小物体很容易被忽略。</p><h3 id="yolo-v2">YOLO v2</h3><p>预定义anchor，预定义很多边框尺寸，这些尺寸几乎可以覆盖各种类型物体的尺寸。</p><p>改进： 1. 将7x7个cell增加为13x13 2. 为每个cell预定义6个anchors 3.每个anchor有其对应的物体类别预测和边框回归预测</p><figure><img src="https://s2.loli.net/2024/11/04/yYxaMUmKQJjiszT.png"alt="yYxaMUmKQJjiszT.png" /><figcaption aria-hidden="true">yYxaMUmKQJjiszT.png</figcaption></figure><h2 id="图像分割">图像分割</h2><h3 id="fcn-全卷积网络">FCN （全卷积网络）</h3><p>全卷积网络（Fully ConvolutionalNetwork，FCN）是一种用于图像分割的神经网络。将图像分割分为Encoder和Decoder两部分。Encoder使用卷积层和池化层提取信息，Decoder使用反卷积层将信息恢复到原始大小。</p><figure><img src="https://s2.loli.net/2024/11/04/Atw6KIevoBuW249.png"alt="Atw6KIevoBuW249.png" /><figcaption aria-hidden="true">Atw6KIevoBuW249.png</figcaption></figure><p>FCN的细节效果很差，因为编码过程中丢失了太多信息，这些信息没有被反卷积层获取。</p><h3 id="u-net">U-Net</h3><p>U-Net的主要特点是使用了跳跃连接（skipconnection），将编码器和解码器之间的特征进行连接，从而保留了更多的图像信息。</p><figure><img src="https://s2.loli.net/2024/11/04/tlJhvO8TrMdeakP.png"alt="tlJhvO8TrMdeakP.png" /><figcaption aria-hidden="true">tlJhvO8TrMdeakP.png</figcaption></figure><p>后续的很多研究都通过加入跳跃连接来提升细节处的分割效果。</p><h1 id="生成对抗网络gan">生成对抗网络(GAN)</h1><h2 id="gan">GAN</h2><p>GAN网络分为生成器和判别器两部分，生成器负责生成图像，判别器负责判断图像是否真实。</p><p>判别器：真图判为1，假图判为0</p><p>生成器：生成尽可能真实的假图</p><p>GAN 的训练过程：</p><ol type="1"><li>判别器先训练，生成器固定</li><li>判别器训练后，生成器更新，生成器固定</li><li>重复1、2步骤</li></ol><h2 id="dcgan">DCGAN</h2><p>DCGAN（Deep Convolutional Generative AdversarialNetworks）是一种基于卷积神经网络的生成对抗网络。它使用卷积层和反卷积层来生成和判别图像。</p><h2 id="acgan">ACGAN</h2><p>ACGAN（Auxiliary ClassifierGAN）是一种改进的生成对抗网络，它引入了一个辅助分类器来帮助生成器生成更高质量的图像。辅助分类器在生成器生成图像后，对图像进行分类，从而指导生成器生成更符合分类器要求的图像。</p><h2 id="vae">VAE</h2><p>GAN 根据一个特征向量生成图像，但有时我们希望知道图像的特征向量。</p><p>VAE（VariationalAutoencoder）是一种生成模型，它可以将输入数据编码为特征向量，然后将特征向量解码为输出数据。VAE的主要思想是通过编码器将输入数据映射到潜在空间，然后通过解码器将潜在空间中的特征向量映射回输出数据。通过最小化输入图像和输出图像的差距，并限制潜在空间中的特征向量满足某些约束条件，从而找到特征向量。</p><figure><img src="https://s2.loli.net/2024/11/05/kH7InuhetyKVzD6.png"alt="kH7InuhetyKVzD6.png" /><figcaption aria-hidden="true">kH7InuhetyKVzD6.png</figcaption></figure><p>GAN包含一个生成器和一个判别器，而VAE只包含一个编码器和一个解码器。</p><p>所以新的想法产生，即给GAN加上编码器(Encoder)，这样就可以给GAN网络输入一张图片了。</p><h1 id="循环神经网络rnn">循环神经网络(RNN)</h1><h2 id="动机-1">动机</h2><p>序列数据：文本、时间序列、语音、视频等</p><h2 id="词汇表征">词汇表征</h2><p>One-hot编码：将每个单词表示为一个向量，向量中只有一个元素为1，其余元素为0。</p><p>词汇表很大，One-hot编码会非常稀疏。</p><p>词袋模型(bag ofwords)：将每个单词表示为一个向量，向量中每个元素表示该单词在文本中出现的次数。同样存在向量爆炸问题，且该表征方法忽略了单词的顺序。</p><h3 id="词嵌入word-embedding">词嵌入(Word Embedding)</h3><p>使用一个浮点数向量表征一个单词，相似的单词在向量空间中距离较近。</p><p>构建词嵌入矩阵，矩阵的每一行对应一个单词，每一列对应一个特征。例如一个5x3的词嵌入矩阵可以表征5个单词，每个单词用一个3维向量表示。</p><p>如何找到一个好的词嵌入矩阵呢？</p><p>理想的词嵌入矩阵：</p><ul><li>低维度。使用尽量少的浮点数来表征一个单词。</li><li>能够表达词汇的语义信息。例如，相似的单词在向量空间中距离较近。</li></ul><p>学习词嵌入矩阵的方法： 1. 无标签，使用大量文本数据进行自监督学习</p><p>Word2Vec：=Skip-gram/CBOW + NegativeSampling，前者通过上下文学习特征，后者加速训练。</p><p>CBOW：最大化上下文中间单词出现的概率。</p><p>如图所示，将bird的上下文<code>a,blue,on,the</code>作为输入，所有的输入都经过同一个词嵌入矩阵获得对应的词向量，然后求平均，最后通过一个softmax层输出中间单词的概率。这样，为了能正确预测中间的单词，词嵌入矩阵得到了训练。</p><figure><img src="https://s2.loli.net/2024/11/05/JzCZQSranVtfRsL.png"alt="JzCZQSranVtfRsL.png" /><figcaption aria-hidden="true">JzCZQSranVtfRsL.png</figcaption></figure><p>Skip-pram:与CBOW相反，通过中间单词预测上下文。</p><figure><img src="https://s2.loli.net/2024/11/05/oXlZCcJ4i3AzK1m.png"alt="oXlZCcJ4i3AzK1m.png" /><figcaption aria-hidden="true">oXlZCcJ4i3AzK1m.png</figcaption></figure><p>由于词汇很多，训练很慢。使用Negative Sampling加速训练。</p><p>NegativeSampling：在训练过程中，只更新一小部分词向量，而不是更新所有的词向量。</p><p>计算损失时，正样本数量少，负样本数量多，比如总共一万个单词，只有4个正样本（假设上下文只有四个），其余都是负样本。对于负样本其实我们不是很关心，所以只需要随机取N个负样本进行计算即可。</p><figure><img src="https://s2.loli.net/2024/11/05/ON6F8g5h7kQJBxf.png"alt="ON6F8g5h7kQJBxf.png" /><figcaption aria-hidden="true">ON6F8g5h7kQJBxf.png</figcaption></figure><h2 id="循环神经网络rnn-1">循环神经网络(RNN)</h2><h3 id="动机-2">动机</h3><p>RNN：处理序列数据，如文本、时间序列、语音、视频等。</p><p>RNN的输入是序列数据，输出也是序列数据。</p><p>RNN的隐藏层包含一个循环神经网络单元，该单元可以处理序列中的每个元素，并生成一个输出。</p><p>RNN当前层的输入为当前输入和上一层的输出。</p><figure><img src="https://s2.loli.net/2024/11/05/Xf4OUbiK3R2AQdY.png"alt="Xf4OUbiK3R2AQdY.png" /><figcaption aria-hidden="true">Xf4OUbiK3R2AQdY.png</figcaption></figure><h3 id="rnn缺陷">RNN缺陷</h3><p>当序列长度较长时，RNN的隐藏层单元只能记住序列中的部分信息，导致RNN难以处理长序列数据。</p><h2 id="长短期记忆网络lstm">长短期记忆网络(LSTM)</h2><p>LSTM：解决RNN的缺陷，可以处理长序列数据。</p><p>LSTM的隐藏层单元包含一个记忆单元和一个遗忘门，可以记住序列中的信息，并控制信息的遗忘程度。</p><p>LSTM的输出由当前输入、记忆单元和遗忘门共同决定。</p><h3 id="门函数gate-function">门函数(Gate Function)</h3><p>将Input Vector和GateVector点对点相乘，得到一个权重向量，该权重向量可以控制InputVector的输出程度。</p><h3 id="遗忘门forget-gate">遗忘门(Forget Gate)</h3><p>遗忘门的门向量由当前输入和上一层的输出共同决定。</p><p>遗忘门的输出是一个0到1之间的实数，表示记忆单元中信息的遗忘程度。</p><p><span class="math inline">\(f_t=\sigma(W_f \cdot x_t + U_f \cdoth_{t-1} + b_f)\)</span></p><figure><img src="https://s2.loli.net/2024/11/05/J8caHvPnAz25gt1.png"alt="J8caHvPnAz25gt1.png" /><figcaption aria-hidden="true">J8caHvPnAz25gt1.png</figcaption></figure><h3 id="输入门input-gate">输入门(Input Gate)</h3><p>同样，输入门也需要一个门向量，由当前输入和上一层的输出共同决定。</p><p>还要计算当前当前输入的信息，当前输入信息经过输入门之后与之前被遗忘门处理过的记忆单元相加，得到新的记忆单元。</p><p>输入门向量：</p><p><span class="math inline">\(i_t=\sigma(W_i \cdot x_t + U_i \cdoth_{t-1} + b_i)\)</span></p><p>信息向量：</p><p><span class="math inline">\(\tilde{c}_t=\tanh(W_c \cdot x_t + U_c\cdot h_{t-1} + b_c)\)</span></p><p>新的记忆单元：</p><p><span class="math inline">\(c_t = f_t \cdot c_{t-1} + i_t \cdot\tilde{c}_t\)</span></p><figure><img src="https://s2.loli.net/2024/11/05/ILZj9Ps27p5MHn1.png"alt="ILZj9Ps27p5MHn1.png" /><figcaption aria-hidden="true">ILZj9Ps27p5MHn1.png</figcaption></figure><h3 id="输出门output-gate">输出门(Output Gate)</h3><p>还需要计算新的输出。</p><p>输出门由当前输入和上一层的输出以及记忆单元决定。</p><p>输出门向量：</p><p><span class="math inline">\(o_t=\sigma(W_o \cdot x_t + U_o \cdoth_{t-1} + b_o)\)</span></p><p>新的输出：</p><p><span class="math inline">\(h_t = o_t \cdot \tanh(c_t)\)</span></p><figure><img src="https://s2.loli.net/2024/11/05/lqnfcXbeDuIFh36.png"alt="lqnfcXbeDuIFh36.png" /><figcaption aria-hidden="true">lqnfcXbeDuIFh36.png</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习基础代码</title>
    <link href="/2024/10/28/deeplearning/%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81/"/>
    <url>/2024/10/28/deeplearning/%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="线性代数">线性代数</h1>]]></content>
    
    
    <categories>
      
      <category>deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达深度学习</title>
    <link href="/2024/10/26/deeplearning/%E5%90%B4%E6%81%A9%E8%BE%BE_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/26/deeplearning/%E5%90%B4%E6%81%A9%E8%BE%BE_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>吴恩达的深度学习课程，该课程偏理论，和李沐的《动手深度学习》配合绝佳</p><h2 id="logistic-回归">1. logistic 回归</h2><p>logistic 回归：做二元分类的算法。</p><p>线性拟合 <span class="math inline">\(\hat{y}=\omega^Tx+b\)</span>，<spanclass="math inline">\(\hat{y}\)</span>表示分为1类的概率，但概率应该是0-1之间的数，所以引入sigmoid函数。</p><p><span class="math inline">\(\sigma(z)=\frac{1}{1+e^{-x}}\)</span></p><p>令<span class="math inline">\(\hat{y}=\sigma(\omega^Tx+b)\)</span>，则其取值在<spanclass="math inline">\(0-1\)</span>之间。</p><p>如何评价训练的好坏？</p><p>损失函数：<spanclass="math inline">\(l(\hat{y},y)=\frac{1}{2}(\hat{y}-y)^2\)</span></p><p>如何降低损失？</p><p>让<span class="math inline">\(\omega\)</span>和<spanclass="math inline">\(b\)</span>沿着梯度的反方向变化，即<spanclass="math inline">\(\omega\leftarrow\omega-\eta\nabla\omega\)</span>，<spanclass="math inline">\(\eta\)</span>是学习率。</p><p>如何计算梯度？</p><p>计算图（也称保留运算图）。通过正向计算和反向传播计算梯度。</p><h2 id="神经网络概览">2. 神经网络概览</h2><h3 id="激活函数">激活函数</h3><p>激活函数的选择经验：</p><ol type="1"><li><p>如果最后的输出层需要输出概率，则在该层选择<code>sigmoid</code>函数。</p></li><li><p>其他层默认使用<code>ReLU</code>函数。只是实践经验得出的，使用<code>ReLU</code>函数的训练速度比使用<code>tanh</code>函数和<code>sigmoid</code>函数快得多。</p></li><li><p>如果一定要在非输出概率层使用<code>sigmoid</code>函数，还不如使用<code>tanh</code>函数，因为<code>sigmoid</code>可能导致梯度消失。</p></li></ol><p>为什么需要使用非线性激活函数？</p><p>如果不使用非线性激活函数，则每层神经网络的输出都只是一个输入的线性相关变量，无论神经网络有多少层，都只能表示线性关系，无法表示复杂的非线性关系。</p><h3 id="权重初始化">权重初始化</h3><ol type="1"><li><p>不能全部初始化为0，这会导致隐藏层计算相同的函数。</p></li><li><p>权重初始化的值不能太大，否则可能导致激活函数饱和，减缓学习速度。原因：考虑<spanclass="math inline">\(\sigma(z)=\frac{1}{1+e^{-z}}\)</span>，当<spanclass="math inline">\(z\)</span>很大时，<spanclass="math inline">\(\sigma(z)\)</span>接近1，<spanclass="math inline">\(\sigma&#39;(z)\)</span>接近0，导致梯度很小，学习速度很慢。</p></li><li><p>当前主流的初始化方法是<code>Xavier</code>初始化,<code>Xavier</code>初始化的权重初始化值是均值为0，方差为<spanclass="math inline">\(\frac{2}{n_{in}+n_{out}}\)</span>的随机数，其中<spanclass="math inline">\(n_{in}\)</span>是输入的维度，<spanclass="math inline">\(n_{out}\)</span>是输出的维度。</p></li></ol><h3 id="偏差和方差">偏差和方差</h3><p>偏差(Bias):指的是模型预测的准确性。高偏差意味着模型太简单，在训练集和数据集上的表现不佳</p><p>方差(Variance):指的是模型对训练数据的敏感程度（稳定性）。高方差意味着模型过于复杂，在训练集上表现很好，但在数据集上表现不佳</p><p>过拟合：高方差，低偏差</p><p>欠拟合：高偏差，低方差</p><table><thead><tr><th>Train set error</th><th>Dev set error</th><th>结论</th></tr></thead><tbody><tr><td>1%</td><td>11%</td><td>过拟合</td></tr><tr><td>15%</td><td>16%</td><td>欠拟合</td></tr></tbody></table><p>策略选择：</p><p>一般而言，需要先保证训练集上的误差足够低，再考虑在数据集上的表现。即先实现低偏差，当偏差降到可接收时，考虑降低方差。</p><ol type="1"><li>高偏差：更大的网络结构，更多训练时间</li><li>高方差：更多数据，L2正则化，dropout，早停</li></ol><h3 id="正则化">正则化</h3><p>正则化：一种非常实用的减少方差的方法。在机器学习初期，偏差和方差的权衡很受关注，但在深度学习和大数据时代，通过适当的正则化后，更大的网络和更多的数据往往能带来偏差和方差的同时降低。</p><p>吴恩达：正则化也会出现偏差和方差权衡问题，偏差可能略有提高，但如果网络足够大，增幅通常不会太高。</p><h4 id="l2正则化">L2正则化：</h4><p>L2正则化前： <span class="math display">\[J(w,b)=\frac{1}{m} \sum_{i=1}^{m} L(\hat{y}^{(i)}, y^{(i)})\\w_i=w_i-\eta\frac{\partial J(w,b)}{\partial w_i}\]</span> L2正则化后： <span class="math display">\[J(w,b)=\frac{1}{m} \sum_{i=1}^{m} L(\hat{y}^{(i)},y^{(i)})+\frac{\lambda}{2m}||w||^2\\w_i=w_i-\eta\frac{\partial J(w,b)}{\partialw_i}-\eta\frac{\lambda}{m}w_i\]</span> L2正则化使得<spanclass="math inline">\(w_i\)</span>的值沿着梯度下降时，额外被惩罚了，使得<spanclass="math inline">\(w_i\)</span>的值变小，从而降低了模型的复杂度，减少了过拟合的风险。</p><p>为什么L2正则化可以减少过拟合？</p><p>考虑一个简单的二维散点拟合，当发生过拟合时，拟合图像可能非常弯曲（向过山车那样）。</p><p>L2正则化通过不让<spanclass="math inline">\(w_i\)</span>的值过大，从而让拟合图像更平滑，其实也就是较小了对噪声的敏感性，从而降低了过拟合的风险。</p><h4 id="dropout">dropout</h4><p>通过丢弃一些节点来降低模型复杂度，从而降低过拟合的风险。</p><p>常见的做法并不是真正的丢弃，而是让一些节点变为0，同时为了让期望不变，需要把保留的值增大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># d3.dype=bool,keep_prob=0.5</span><br>d3=np.random.rand(a3.shape[<span class="hljs-number">0</span>],a3.shape[<span class="hljs-number">1</span>])&lt;keep_prob <br>a3=a3*d3    <span class="hljs-comment"># 50%的节点变为0</span><br>a3=a3/keep_prob <span class="hljs-comment">#保留的节点变为2倍，总期望不变</span><br></code></pre></td></tr></table></figure><p>测试阶段，一般将<code>keep_prob</code>设置为1，即不丢弃任何节点。因为dropout涉及随机，测试阶段不想要随机性。当然，也可以在测试阶段使用dropout不为1，但需要多预测几次，取平均值作为最终结果。</p><p>dropout在计算机视觉领域广泛使用，在其他领域使用较少。因为计算机视觉数据较少，容易发生过拟合，而dropout正是解决该问题的好办法。</p><h4 id="其他正则化">其他正则化：</h4><p>数据增强：翻转、裁剪、缩放等，通过增加数据量来降低过拟合的风险。</p><p>早停：在验证集上的误差不再下降时停止训练。</p><h3 id="输入归一化">输入归一化</h3><p><span class="math display">\[x_i=\frac{x_i-\mu}{\sigma^2}\]</span> 输入归一化使成本函数更对称，梯度下降更容易到大最小值。 <imgsrc="https://s2.loli.net/2024/10/27/VdA4kpsQqyvNc9e.png"alt="图 0" /></p><p>执行归一化并不会产生什么危害，但可以加速训练，推荐始终使用。</p><h3 id="梯度消失和梯度爆炸">梯度消失和梯度爆炸</h3><p>深层神经网络中，由于梯度是累乘的，可能导致梯度消失或梯度爆炸。</p><p>梯度爆炸一般发生在深层网络和权重初始化过大时。合理的权重初始化和L2正则化可以较好的解决梯度爆炸。</p><p>实际上，在深度网络中，梯度消失比梯度爆炸更常见。尤其是使用<code>sigmoid,tanh</code>作为激活函数时。</p><p><code>Xavier</code>标准正态分布：均值为0，方差为<spanclass="math inline">\(\frac{2}{n_{in}+n_{out}}\)</span>的随机数。</p><p><code>torch.nn.init.xavier_normal_(tensor, gain=1)</code></p><p><code>gain</code>表示增益，默认为1，其大小由激活函数类型决定，例如：</p><p><code>nn.init.xavier_uniform_(w, gain=nn.init.calculate_gain(‘relu’))</code></p><h2 id="优化算法">优化算法</h2><h3 id="minibatch梯度下降">Minibatch梯度下降</h3><p>Mini-batch梯度下降:每次迭代使用一小批数据，而不是全部数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):<br>    mini_batch = random.sample(data, batch_size)<br>    <span class="hljs-comment"># 计算梯度</span><br>    <span class="hljs-comment"># 更新参数</span><br></code></pre></td></tr></table></figure><p>Mini-batch 的大小：</p><ol type="1"><li>size=1，即随机梯度下降（SGD）。失去向量化带来的加速，一次性只处理一个样本，单次迭代代价小，但要迭代很多次</li><li>size=m，即批量梯度下降。单次迭代代价太大，时间太长</li><li>选择一个介于1和m之间的值，即mini-batch梯度下降</li></ol><h3 id="指数加权平均">指数加权平均</h3><p>一般求平均： <span class="math inline">\(v_{\text {aver}}=\frac{y_1+\ldots+y_{100}}{100}\)</span></p><p>指数加权平均：一种平均值估计方法，好处时可以降低计算所需的内存。<span class="math display">\[v_t=\beta v_{t-1}+(1-\beta)y_t\]</span>使用指数加权平均，计算当前的平均估计值，只需要保存上一个平均估计值就行。</p><p>指数加权平均修正：</p><p>指数加权平均在估计初期和准确结果有较大偏差，修正的方法为在估计初期使用:</p><p><span class="math display">\[v_t=\frac{v_{t-1}}{1-\beta^t}\]</span></p><p>在实际的机器学习中，大多不进行修正，人们宁愿熬过初期，因为对后续结果往往没什么影响。</p><h3 id="动量梯度下降">动量梯度下降</h3><p>动量梯度下降几乎总是快于标准梯度下降法。其基本思想是计算梯度的指数加权平均，并利用该梯度更新权重。</p><p>在每次迭代中： 在当前mini-batch中计算 <spanclass="math inline">\(d_W\)</span> 和 <spanclass="math inline">\(d_b\)</span> ，然后更新参数： <spanclass="math display">\[\begin{aligned}&amp; v_{d W}=\beta v_{d W}+(1-\beta) d W \\&amp; v_{d b}=\beta v_{d b}+(1-\beta) d b \\&amp; W=W-\alpha v_{d W}, \quad b=b-\alpha v_{d b}\end{aligned}\]</span></p><p><span class="math inline">\(\beta\)</span>常用值为<spanclass="math inline">\(0.9\)</span></p><h3 id="rmsprop">RMSprop</h3><p>RMSprop算法是动量梯度下降的一个变体，其基本思想是计算梯度的平方的指数加权平均，并利用该梯度更新权重。</p><p>在每次迭代中： 在当前mini-batch中计算 <spanclass="math inline">\(d_W\)</span> 和 <spanclass="math inline">\(d_b\)</span> ，然后更新参数： <spanclass="math display">\[\begin{aligned}&amp; s_{d W}=\beta_2 s_{d W}+(1-\beta_2) d W^2 \\&amp; s_{d b}=\beta_2 s_{d b}+(1-\beta_2) d b^2 \\&amp; W=W-\alpha \frac{d W}{\sqrt{s_{d W}+\epsilon}}, \quad b=b-\alpha\frac{d b}{\sqrt{s_{d b}+\epsilon}}\end{aligned}\]</span> <span class="math inline">\(\epsilon\)</span>常用值为<spanclass="math inline">\(10^{-8}\)</span>，目的是避免除0操作。</p><p>RMSprop可以减小梯度的波动，使梯度下降更稳定。从公式上看的话，就是摆动大的参数的<spanclass="math inline">\(s\)</span>更大，于是更新的时候除以一个更大的数，使其变化得更慢。</p><p>RMSprop的另一个好处是，它允许你使用更大的学习率，这有利于提高训练速度。</p><h3 id="adam优化算法">Adam优化算法</h3><p>Adam优化算法是RMSprop和动量梯度下降的结合。其基本思想是计算梯度的指数加权平均，并利用该梯度更新权重。</p><p>在每次迭代中： 在当前mini-batch中计算 <spanclass="math inline">\(d_W\)</span> 和 <spanclass="math inline">\(d_b\)</span> ，然后更新参数： <spanclass="math display">\[\begin{aligned}&amp; v_{d W}=\beta_1 v_{d W}+(1-\beta_1) d W \\&amp; v_{d b}=\beta_1 v_{d b}+(1-\beta_1) d b \\&amp; s_{d W}=\beta_2 s_{d W}+(1-\beta_2) d W^2 \\&amp; s_{d b}=\beta_2 s_{d b}+(1-\beta_2) d b^2 \\&amp; \hat{v}_{d W}=\frac{v_{d W}}{1-\beta_1^t}, \quad \hat{v}_{db}=\frac{v_{d b}}{1-\beta_1^t} \\&amp; \hat{s}_{d W}=\frac{s_{d W}}{1-\beta_2^t}, \quad \hat{s}_{db}=\frac{s_{d b}}{1-\beta_2^t} \\&amp; W=W-\alpha \frac{\hat{v}_{d W}}{\sqrt{\hat{s}_{d W}+\epsilon}},\quad b=b-\alpha \frac{\hat{v}_{d b}}{\sqrt{\hat{s}_{d b}+\epsilon}}\end{aligned}\]</span></p><p>超参数选择： 1. <span class="math inline">\(\alpha\)</span>：需要选择2. <span class="math inline">\(\beta_1\)</span>：常用值为0.9 3. <spanclass="math inline">\(\beta_2\)</span>：常用值为0.999 4. <spanclass="math inline">\(\epsilon\)</span>：常用值为<spanclass="math inline">\(10^{-8}\)</span></p><p>实际使用Adam算法时，只需要指定学习率即可，其他参数一般使用默认值。</p><h3 id="学习率衰减">学习率衰减</h3><p>学习率衰减：在训练过程中逐渐减小学习率，使得模型在训练后期更加稳定。</p><p>学习率衰减的方法： 1. <spanclass="math inline">\(\alpha=\frac{1}{1+decayRate \timesepochNum}\)</span>，其中<spanclass="math inline">\(decayRate\)</span>是一个小于1的数，<spanclass="math inline">\(epochNum\)</span>是当前迭代的次数。 2. <spanclass="math inline">\(\alpha=\frac{k}{\sqrt{epochNum}}\alpha_0\)</span>，其中<spanclass="math inline">\(k\)</span>是一个常数，<spanclass="math inline">\(epochNum\)</span>是当前迭代的次数。 3. <spanclass="math inline">\(\alpha=0.95^{epochNum}\alpha_0\)</span>，其中<spanclass="math inline">\(epochNum\)</span>是当前迭代的次数。</p><p>学习率衰减可能加快训练，但并不一定是尝试的要点。之后会有更详细的系统性选择超参数的讨论。</p><h2 id="bn和softmax">BN和softmax</h2><p>正则化网络的作用是保证隐藏单元已使均值和方差标准化。这将有助于超参数的选择与模型稳定。</p><p><span class="math display">\[\begin{aligned}\mu &amp; =\frac{1}{m} \sum_i z^{(i)} \\\sigma^2 &amp; =\frac{1}{m} \sum_i\left(z^{(i)}-\mu\right)^2 \\z_{\text {norm }}^{(i)} &amp;=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\varepsilon}} \\\tilde{z}^{(i)} &amp; =\gamma z_{\text {norm }}^{(i)}+\beta\end{aligned}\]</span></p><p>BN层有两个可学习参数<spanclass="math inline">\(\beta,\gamma\)</span>，分别表示归一化后的均值和方差。注意这里的<spanclass="math inline">\(\beta,\gamma\)</span>是参数，而不是超参数，参数可以由梯度的反向传播自动更新，就像<spanclass="math inline">\(w,b\)</span>一样。如果需要，也可以将<spanclass="math inline">\(\beta,\gamma\)</span>强行设置为<spanclass="math inline">\(0,1\)</span>。这里的<spanclass="math inline">\(\gamma\)</span>和Adam算法中的<spanclass="math inline">\(\gamma\)</span>没有关系，只是两个论文作者都用了这个符号</p><p>BN（batch-norm）： <span class="math display">\[X\xrightarrow{w^{[1]},b^{[1]}} z^{[1]}\xrightarrow[BN]{\beta^{[1]},\gamma^{[1]}} \hat{z^{[1]}}\xrightarrow{a=g(\hat{z})} a^{[1]} \\\xrightarrow{w^{[2]},b^{[2]}} z^{[2]}\xrightarrow[BN]{\beta^{[2]},\gamma^{[2]}} \hat{z^{[2]}}\xrightarrow{a=g(\hat{z})} a^{[2]} \cdots\]</span></p><p>softmax是一种激活函数，可以将一个数值向量归一化为一个概率分布向量，且各个概率之和为1.Softmax层可以用作神经网络的最后一层，用于多分类的输出。</p><p><span class="math display">\[\operatorname{Softmax}\left(z_i\right)=\frac{\exp\left(z_i\right)}{\sum_j \exp \left(z_j\right)}\]</span> 为了防止数值溢出，实际使用常用等价公式：</p><p><span class="math display">\[M=max(z)\\\mathrm{Softmax}(z_i)=\frac{\exp(z_i-M)}{\sum_j\exp(z_j-M)}\]</span></p><h2 id="实践建议">实践建议</h2><ol type="1"><li><p>快速构建模型，快速迭代</p></li><li><p>训练数据和目标数据分布不同时，怎么处理。out-of-distribution</p><p>将目标数据分为“训练、开发、测试”三部分，第一部分合并入测试数据。</p><p>例如有10000张网络图片和1000张手机图片。最终目的是检测手机图片中的猫。则让网络图片和500张手机图片合并为数据集，剩余500张手机图片分为开发集和测试集。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11</title>
    <link href="/2024/10/06/CPP/CPP11/"/>
    <url>/2024/10/06/CPP/CPP11/</url>
    
    <content type="html"><![CDATA[<h2 id="关键字">关键字</h2><h3 id="auto-和-decltype"><code>auto</code> 和<code>decltype</code></h3><ul><li><p><code>auto</code>:自动类型推导。占位类型说明符，替换类型由初始化器推导得到。</p></li><li><p><code>decltype</code>:获取实体或表达式的类型。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T x, U y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><br><span class="hljs-comment">//C++14</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T x, U y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="default和delete"><code>default</code>和<code>delete</code></h3><ul><li><p><code>default</code>：显式地告诉编译器使用默认实现。</p></li><li><p><code>delete</code>：显式地禁用默认实现。</p></li></ul><p>可以<code>default</code>或<code>delete</code>的函数：默认构造函数、默认析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算发。</p><h3 id="final和override"><code>final</code>和<code>override</code></h3><ul><li><p><code>final</code>：指定某个<strong>虚函数</strong>不能在派生类中被覆盖；指定某个类不能被派生</p></li><li><p><code>override</code>：指定一个虚函数覆盖另一个虚函数</p></li></ul><h3 id="constexpr"><code>constexpr</code></h3><ul><li><code>constexpr</code>：声明一个值或函数可以在编译时计算，以提高程序性能。</li></ul><p>C++14和17放宽了对<code>constexpr</code>的限制</p><ul><li><p><code>C++14</code>：允许局部变量和循环，允许调用其他<code>constexpr</code>函数，允许用于<code>lambda</code>表达式</p></li><li><p><code>C++17</code>：允许<code>try,catch</code>，允许用于构造函数</p></li></ul><h3 id="nullptr"><code>nullptr</code></h3><p>传统C++的编译器可能将<code>NULL</code>和<code>0</code>视为同一东西，这可能导致重载特性发生混乱。在任何时候使用<code>nullptr</code>表示空指针。</p><h3 id="long-long-至少有64位的宽度"><code>long long</code> :至少有64位的宽度</h3><h3 id="explicit"><code>explicit</code></h3><p>禁用构造函数的隐式转换。注意：专用于构造函数。</p><h3id="alignof和alignas"><code>alignof</code>和<code>alignas</code></h3><ul><li><p><code>alignof</code>：查询类型的对齐要求</p></li><li><p><code>alignas</code>：指定类型或对象的对齐要求</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-comment">// 每个 struct_float 类型对象都将被对齐到 alignof(float) 边界</span><br><span class="hljs-comment">// （通常为 4）：</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-type">float</span>) struct_float<br>&#123;<br>    <span class="hljs-comment">// 定义在此</span><br>&#125;;<br> <br><span class="hljs-comment">// sse_t 类型的每个对象将对齐到 32 字节边界</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) <span class="hljs-type">sse_t</span><br>&#123;<br>    <span class="hljs-type">float</span> sse_data[<span class="hljs-number">4</span>];<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout<br>        &lt;&lt; <span class="hljs-string">&quot;alignof(struct_float) = &quot;</span> &lt;&lt; <span class="hljs-built_in">alignof</span>(struct_float) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;sizeof(sse_t) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">sse_t</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;alignof(sse_t) = &quot;</span> &lt;&lt; <span class="hljs-built_in">alignof</span>(<span class="hljs-type">sse_t</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="功能特性">功能特性</h2><h3 id="右值引用">右值引用</h3><p>右值引用通过使用<code>&amp;&amp;</code>引用右值，从而直接访问即将销毁的对象，而不是他们的拷贝。配合移动语义可以实现代码优化。</p><p>为了减少函数传参的拷贝代价，可设置函数形参为引用，然而这种引用为左值引用，当函数实参传入一个右值时，依然会产生拷贝代价。为了解决这个问题，引入了右值引用的概念，通过将函数形参设置为右值引用，可以实现具有移动能力的函数，例如移动构造函数、移动赋值运算符等，这些函数可以接收右值（例如无名的临时对象），且不会产生拷贝代价。</p><p>关于右值引用延长临时对象的生存期的说法：这种说法不算准确，临时对象的生存期由其作用域决定，正确的说法应该是<strong>右值引用允许临时对象的资源在销毁前被“借用”或“转移”</strong>，而不是延长其生存期。</p><p>右值引用的主要用途</p><ul><li><p>移动构造、移动赋值运算符</p></li><li><p>其他需要使用右值构造对象的函数，例如<code>std::vector</code>的<code>push_back()</code>等。</p></li><li><p>使用右值引用和<code>std::forward</code>能够将参数完全不变的转发给另一个函数。完美转发通常与模板和<code>std::forward</code>函数一起使用。</p></li><li><p>返回值优化。由编译器完成，通过右值引用，将函数的局部变量高效无拷贝地返回给接收变量。</p></li></ul><h3 id="智能指针">智能指针</h3><ul><li><p><code>std::unique_ptr</code></p></li><li><p><code>std::shared_ptr</code></p></li><li><p><code>std::weak_ptr</code></p></li></ul><h3 id="基于范围的for循环">基于范围的for循环</h3><h3 id="lambda表达式">lambda表达式</h3><h3 id="委托构造函数和继承构造函数">委托构造函数和继承构造函数</h3><p>委托构造函数允许一个类的构造函数调用另一个构造函数，从而减少代码重复。</p><p>继承构造函数允许派生类直接继承基类的构造函数，从而简化代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 委托构造</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br>    ClassName::<span class="hljs-built_in">ClassName</span>(param_type param) : <span class="hljs-built_in">other_constructor</span>(param) &#123;<br>        <span class="hljs-comment">// 其他初始化代码</span><br>    &#125;<br><br>    ClassName::<span class="hljs-built_in">ClassName</span>() : <span class="hljs-built_in">ClassName</span>(default_param) &#123;<br>        <span class="hljs-comment">// 使用默认参数值调用另一个构造函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 继承构造</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Base::<span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-comment">// 初始化代码</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base; <span class="hljs-comment">// 继承构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="花括号初始化器和初始化列表">花括号初始化器和初始化列表</h3><p>原来的使用<code>()</code>调用构造函数初始化会带来语义二义性。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Foo f=<span class="hljs-built_in">Foo</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>请问<code>Foo(10)</code>是一个对象初始化还是一个函数呢？在原来的C++里，编译器首先将<code>Foo(10)</code>解析为函数调用，当找不到对应函数时，才会将其解析为对象的初始化。</p><p>使用花括号进行初始化就能解决二义性。只要用<code>&#123;&#125;</code>就一定是初始化，而不是函数调用了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Foo f=Foo&#123;<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//这一定是对象初始化</span><br></code></pre></td></tr></table></figure>使用花括号进行初始化又叫列表初始化。注意和后面的初始化列表区分。</p><p>列表初始化是指使用<code>&#123;&#125;</code>进行初始化，而初始化列表是指定义一个形参为<code>std::initializer_list&lt;&gt;</code>的构造函数，以用于初始化对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>    <span class="hljs-built_in">MyClass</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; init) &#123;<br>        <span class="hljs-comment">// 初始化逻辑...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 其他成员...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><br>MyClass myc1=MyClass&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//调用MyClass(int x,int y);</span><br>MyClass myc2&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//调用MyClass(std::initializer_list&lt;int&gt;);</span><br></code></pre></td></tr></table></figure><h3 id="有作用域枚举">有作用域枚举</h3><p>没有作用域的枚举可能带来难以发现的bug，例如 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AColor</span><br>&#123;<br>    kRed,kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BColor</span><br>&#123;<br>    kWhite,kBlack<br>&#125;;<br><br><span class="hljs-keyword">if</span>(kRed==kWhite)<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;红色居然等于白色!!!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>C++11后使用枚举，请使用<code>enum class</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">AColor</span><br>&#123;<br>    kRed,kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">BColor</span><br>&#123;<br>    kWhite,kBlack<br>&#125;;<br><span class="hljs-keyword">if</span>(AColor::kRed==BColor::kWhite) <span class="hljs-comment">//编译失败</span><br><br></code></pre></td></tr></table></figure><h2 id="库功能特性">库功能特性</h2><h3 id="随机数-random">随机数 <code>random</code></h3><h3 id="正则表达式regex">正则表达式<code>regex</code></h3><h3 id="时间chrono">时间<code>chrono</code></h3><h3 id="并发支持库">并发支持库：</h3><ul><li><p><code>std::thread</code></p></li><li><p><code>std::mutex</code></p></li><li><p><code>std::lock</code></p></li><li><p><code>std::atomic</code></p></li><li><p><code>std::condition_variable</code></p></li><li><p><code>std::future</code></p></li><li><p><code>std::call_once</code></p></li></ul><h2 id="新增算法">新增算法</h2><p><code>all_of</code>,<code>any_of</code>,<code>none_of</code></p><p><code>find_if_not</code>,<code>copy_if</code></p><p><code>itoa</code>:对容器内的元素按序递增</p><p><code>minmax_element</code>:返回最大元素和最小元素的位置</p><p><code>is_sorted</code></p>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D 数学</title>
    <link href="/2024/09/06/math/3D%E6%95%B0%E5%AD%A6/"/>
    <url>/2024/09/06/math/3D%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="坐标系">坐标系</h1><p>笛卡尔坐标系 <span class="math inline">\((x,y,z)\)</span></p><p>圆柱体坐标系 <span class="math inline">\((r,\theta,z)\)</span> <spanclass="math display">\[\begin{align*}x&amp;=r\cos\theta\\y&amp;=r\sin\theta\end{align*}\]</span> 球坐标系 <span class="math inline">\((r,\theta,\phi)\)</span><span class="math display">\[\begin{align*}x&amp;=r\sin\phi\cos\theta \\y&amp;=r\sin\phi\sin\theta \\z&amp;=r\cos\phi\end{align*}\]</span></p><h1 id="向量vector">向量（<spanclass="math inline">\(vector\)</span>）</h1><p>Point: <spanclass="math inline">\(p_1=(x_1,y_1,z_1),p_2=(x_2,y_2,z_2)\)</span></p><p>Vector: <span class="math inline">\(v=p_2-p_1\)</span>,方向为<spanclass="math inline">\(p_1\)</span>指向<spanclass="math inline">\(p_2\)</span></p><p>向量操作：</p><p>加法、减法：平行四边形法则</p><p>向量的模：<spanclass="math inline">\(|v|=\sqrt{x^2+y^2+z^2}\)</span></p><p>向量的平方模（平方长度）:<spanclass="math inline">\(v=x^2+y^2+z^2\)</span></p><p>向量归一化：<spanclass="math inline">\(v_n=\frac{v}{|v|}=\frac{v}{\sqrt{x^2+y^2+z^2}}\)</span></p><h2 id="点乘内积">点乘（内积）</h2><p>点乘结果为标量，为两个向量对应分量乘积的和，表示一个向量的长度与另一个向量在该向量方向上投影长度的和。</p><p><span class="math inline">\(a\cdot b=a_xb_x+a_yb_y+a_zb_z=|a|\cdot|b|\cos\theta\)</span>，（<spanclass="math inline">\(\theta\)</span>为<spanclass="math inline">\(a,b\)</span>向量的夹角）。</p><p><span class="math display">\[\begin{align*}a\cdot b&amp;=0~,~向量垂直\\a\cdot b&amp;&gt;0~,~向量夹角小于90^{。} \\a\cdot b&amp;&lt;0~,~向量夹角大于90^{。} \\a\cdot b&amp;=|a||b|~,~向量平行且同向\\a\cdot b&amp;=-|a||b|~,~向量平行且反向\end{align*}\]</span></p><h2 id="叉乘外积">叉乘（外积）</h2><p><span class="math inline">\(a\timesb=(a_yb_z-a_zb_y,a_zb_x-a_xb_z,a_xb_y-a_yb_x)\)</span></p><p>更好记忆的计算方式为：</p><p><span class="math display">\[\mathbf{a} \times \mathbf{b} = \begin{vmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\a_x &amp; a_y &amp; a_z \\b_x &amp; b_y &amp; b_z\end{vmatrix}\]</span></p><p><span class="math inline">\(|a\times b|=|a||b|\sin\theta\)</span></p><p><span class="math inline">\(a\times b\)</span>的方向：左手坐标系中，食指为<spanclass="math inline">\(a\)</span>的方向，中指为<spanclass="math inline">\(b\)</span>的方向，则大拇指为<spanclass="math inline">\(a\times b\)</span>的方向。</p><p>注意叉乘的交换律，需要添加负号：<span class="math inline">\(a\timesb=-b\times a\)</span></p><h2 id="向量发射">向量发射</h2><p>入射向量<span class="math inline">\(v\)</span>关于法向量<spanclass="math inline">\(n\)</span>反射结果为<spanclass="math inline">\(u\)</span>,注意，默认法向量已经被归一化了。 <imgsrc="https://s2.loli.net/2024/09/28/DlnQ4a5SANpCHfY.png"alt="图 2" /></p><p><span class="math display">\[\begin{align}\vec{N}&amp;=(-\vec{v}\cdot \vec{n})- \vec{n}=-(\vec{v}\cdot\vec{n})*\vec{n} \\\vec{d}&amp;=\vec{v}+\vec{u} ; =&gt; \vec{u}=\vec{d}-\vec{v}\\\frac{\vec{d}}{2}&amp;=\vec{v}+\vec{N}\overset{由(1)}{=}\vec{v}-(\vec{v}\cdot\vec{n})*\vec{n}\\&amp;由(2),(3)得\vec{u}=\vec{v}-2*(\vec{v}\cdot \vec{n})*\vec{n}\\\end{align}\]</span></p><h2 id="向量练习题">向量练习题</h2><p>**Q1*- ：如何判断两个圆形是否碰撞？</p><p><span class="math display">\[\begin{align*}|O_1-O_2|&amp;&gt;r_1+r2~;~不相交\\|O_1-O_2|&amp;=r_1+r_2~;~相切\\|O_1-O_2|&amp;&lt;r_1+r_2~;~相交\\\end{align*}\]</span> 注：编程时，计算<spanclass="math inline">\(|O_1-O_2|^2，(r_1+r_2)^2\)</span>比较即可。</p><p>**Q2*- : 如何计算一个三角形(顶点分别为<spanclass="math inline">\(a,b,c\)</span>)的法向量</p><p><span class="math inline">\(n=norm((\vec{a}-\vec{b})\times(\vec{c}-\vec{b}))\)</span></p><p>**Q3*- : 如何计算三角形的面积</p><p><span class="math inline">\(|(\vec{a}-\vec{b})\times(\vec{c}-\vec{b}) |/ 2\)</span></p><p>**Q4*- : 如何判断npc(<spanclass="math inline">\(q\)</span>)在玩家(<spanclass="math inline">\(p\)</span>)前进(forward)方向(<spanclass="math inline">\(v\)</span>)的左边。</p><p>npc位置为<span class="math inline">\(q\)</span>，玩家位置为<spanclass="math inline">\(p\)</span>,玩家前进方向为<spanclass="math inline">\(v\)</span>,玩家的上方(up)为<spanclass="math inline">\(u\)</span> <imgsrc="https://s2.loli.net/2024/09/28/1IrFsZSdO6lyoUh.png"alt="图 3" /></p><p>在左手系坐标中，<span class="math inline">\([(q-p)\times\vec{v}]\cdot \vec{u}&gt;0\)</span>，则在左边。<spanclass="math inline">\(&lt;0\)</span>则在右边，<spanclass="math inline">\(=0\)</span>，说明npc在玩家前进方向。</p><h1 id="u3d-的向量">U3D 的向量</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#">Vector3 v1=(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>Vector3 v2=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 加法</span><br>Vector3 addRes=v1+v2;<br><span class="hljs-comment">// 减法</span><br>Vector3 subRes=v1-v2;<span class="hljs-comment">//表示v2指向v1的向量</span><br><br><span class="hljs-comment">//标量乘法</span><br>Vector3 mulRes=v1*<span class="hljs-number">2</span>;<br><span class="hljs-comment">//标量除法</span><br>Vector3 divRes=v2/<span class="hljs-number">3</span>;<br><br><span class="hljs-comment">//点乘</span><br><span class="hljs-built_in">float</span> dotRes=Vector3.Dot(v1,v2);<br><span class="hljs-comment">//叉乘</span><br>Vector3 crossRes=Vector3.Cross(v1,v2);<br><br><span class="hljs-comment">//归一化</span><br>v1.Normalize();<span class="hljs-comment">//v1进行归一化</span><br>Vector3 normalizedRes=v2.normalized;<span class="hljs-comment">//v2本身并没有改变。且normalized是一个属性，而不是方法，即不需要()</span><br><br><span class="hljs-comment">//向量的模（长度）</span><br><span class="hljs-built_in">float</span> magnitude=v2.magnitude;<br><br><span class="hljs-comment">//向量的模平方（平方长度）,没有开方运算</span><br><span class="hljs-built_in">float</span> sqrMagnitude=v2.sqrMagnitude; <br><br><span class="hljs-comment">//向量反射</span><br><span class="hljs-comment">//v1是入射向量，v2为法向量，必须将v2归一化</span><br>Vector3 reflectionRes=Vector3.Reflect(v1,v2.normalized);<br><br><span class="hljs-comment">//向量投影，将v1投影到v2上的结果</span><br>Vector3 projectedRes=Vector3.Project(v1,v2);<br></code></pre></td></tr></table></figure><h1 id="矩阵">矩阵</h1><h2 id="矩阵基础">矩阵基础</h2><p>转置、加法、减法、标量乘法、标量除法</p><p><strong>矩阵乘法</strong>:</p><ul><li><span class="math inline">\(A*B\)</span>合法要求A的列数=B的行数</li><li><span class="math inline">\(A_{4\times 3}*B_{3\times 5}=C_{4\times5}\)</span></li><li><span class="math inline">\(A*B\neqB*A,(A*B)^T=B^T*A^T\)</span></li></ul><p><span class="math inline">\(I\)</span>为单位矩阵，<spanclass="math inline">\(M*I=I*M=M\)</span></p><p>可逆矩阵：<span class="math inline">\(M*M^{-1}=I\)</span></p><p>正交矩阵：<span class="math inline">\(M^{-1}=M^{T}\)</span></p><h2 id="转换矩阵移动旋转伸缩">转换矩阵（移动、旋转、伸缩）</h2><p>转换矩阵能够作用与点或向量，使其实现变换，常用的三种转换矩阵：移动、旋转、伸缩。（translation,rotation,scaling）</p><p>注：unity中的向量为列向量，转换矩阵要乘在左边</p><p>转换矩阵为<span class="math inline">\(4\times4\)</span>矩阵，因为我们一般在对点或向量进行转换时会使用齐次坐标。所谓的齐次坐标就是在原来的三个维度上加上一维，这样我们就能把平移操作也使用矩阵乘法来进行，而不是要单独对其进行加法操作。</p><p>齐次坐标带来的三个好处：BV1viY7nP</p><p><strong>转换矩阵的逆矩阵可以抵消原始转换矩阵的效果。</strong></p><p>可以连续乘多个转换矩阵进行变换，一般的变换顺序为<strong>SRT(Scale,Rotation,Translation)</strong></p><h3 id="scale-matrix">Scale Matrix</h3><p><span class="math display">\[\begin{align*}   S &amp;= \begin{bmatrix}   s_x &amp; 0 &amp; 0 &amp; 0 \\   0 &amp; s_y &amp; 0 &amp; 0 \\   0 &amp; 0 &amp; s_z &amp; 0 \\   0 &amp; 0 &amp; 0 &amp; 1 \\   \end{bmatrix}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}S^{-1}&amp;== \begin{bmatrix}   \frac{1}{s_x} &amp; 0 &amp; 0 &amp; 0 \\   0 &amp; \frac{1}{s_y} &amp; 0 &amp; 0 \\   0 &amp; 0 &amp; \frac{1}{s_z} &amp; 0 \\   0 &amp; 0 &amp; 0 &amp; 1 \\   \end{bmatrix}\end{align*}\]</span></p><p><span class="math display">\[S\cdot \begin{bmatrix} x\\ y\\ z\\ 1 \end{bmatrix}=\begin{bmatrix} xt_x\\ yt_y\\ zt_z\\ 1 \end{bmatrix}\]</span></p><h3 id="rotation-matrix">Rotation Matrix</h3><p>旋转矩阵的性质：</p><ul><li>逆矩阵等于矩阵的转置</li><li>哪一列有"1"，就是关于哪一列的旋转。例如第一列有1，则关于x旋转；第二列有1，则关于y旋转</li></ul><p>绕X轴旋转:</p><p><span class="math display">\[\begin{align*}R_x(\theta) = \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos(\theta) &amp; -\sin(\theta) &amp; 0 \\0 &amp; \sin(\theta) &amp; \cos(\theta) &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix} \\R_x^{-1}(\theta)=R_x(-\theta)=R_x(\theta)^T\end{align*}\]</span></p><p>绕Y轴旋转:</p><p><span class="math display">\[\begin{align*}R_y(\theta) = \begin{bmatrix}\cos(\theta) &amp; 0 &amp; \sin(\theta) &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-\sin(\theta) &amp; 0 &amp; \cos(\theta) &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix} \\R_y^{-1}(\theta)=R_y(-\theta)=R_y(\theta)^T\end{align*}\]</span></p><p>绕Z轴旋转:</p><p><span class="math display">\[\begin{align*}R_z(\theta) = \begin{bmatrix}\cos(\theta) &amp; -\sin(\theta) &amp; 0 &amp; 0 \\\sin(\theta) &amp; \cos(\theta) &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\\R_z^{-1}(\theta)=R_z(-\theta)=R_z(\theta)^T\end{align*}\]</span></p><h3 id="translation-matrix">Translation Matrix</h3><p>$$ <span class="math display">\[\begin{align*}T &amp;= \begin{bmatrix}   1 &amp; 0 &amp; 0 &amp; t_x \\   0 &amp; 1 &amp; 0 &amp; t_y \\   0 &amp; 0 &amp; 1 &amp; t_z \\   0 &amp; 0 &amp; 0 &amp; 1 \\   \end{bmatrix} \\T^{-1}&amp;=\begin{bmatrix}   1 &amp; 0 &amp; 0 &amp; -t_x \\   0 &amp; 1 &amp; 0 &amp; -t_y \\   0 &amp; 0 &amp; 1 &amp; -t_z \\   0 &amp; 0 &amp; 0 &amp; 1 \\   \end{bmatrix}\end{align*}\]</span> $$</p><p><span class="math display">\[T\cdot \begin{bmatrix} x\\ y\\ z\\ 1 \end{bmatrix}=\begin{bmatrix} x+t_x\\ y+t_y\\ z+t_z\\ 1 \end{bmatrix}\]</span></p><p>齐次坐标：<span class="math inline">\(\begin{bmatrix} x\\ y\\ z\\\omega \end{bmatrix}\)</span>；对于点向量，我们需要移动，令<spanclass="math inline">\(\omega=1\)</span>；对于方向向量，我们不希望移动矩阵对其生效，则令<spanclass="math inline">\(\omega=0\)</span>。</p><p>Point Vector:<span class="math inline">\(\begin{bmatrix} x\\ y\\ z\\1 \end{bmatrix}\)</span></p><p>Direction Vector : <span class="math inline">\(\begin{bmatrix} x\\y\\ z\\ 0\end{bmatrix}\)</span>,向量没有移动属性，向量不管放在那里都不会改变</p><h1 id="四元数">四元数</h1>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在没有管理员权限的Linux上部署SD-WebUI</title>
    <link href="/2024/09/06/other/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASDWebUI/"/>
    <url>/2024/09/06/other/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASDWebUI/</url>
    
    <content type="html"><![CDATA[<h1id="在没有管理员权限的linux上部署sd-webui">在没有管理员权限的Linux上部署SD-WebUI</h1><h2 id="情况说明">1. 情况说明</h2><ul><li>拥有Windows 下的VSCode</li><li>拥有远程Linux服务器账号，<strong>无管理员权限</strong>：IP,端口，用户名，密码</li><li>服务器设置了防火墙，国外及一部分国内无法访问</li></ul><h2 id="windows下载xftp">2. Windows下载Xftp</h2><p>从Windows下载需要的文件，通过Xftp传到服务器</p><p>操作很简单，下载-安装-连接（输入IP,PORT,NAME,PASSWARD）-拖动文件传输即可</p><figure><img src="https://s2.loli.net/2024/09/13/2JwdtSfLmubv9RQ.png"alt="图 0" /><figcaption aria-hidden="true">图 0</figcaption></figure><h2 id="windows-下载秋叶整合包">3. Windows 下载秋叶整合包</h2><p>https://space.bilibili.com/12566101</p><h2 id="通过xftp将下载下来的整合包传到服务器">4.通过Xftp将下载下来的整合包传到服务器</h2><p>整合包解压好后，可以删除其下的python文件夹，这里面的都是windows用的，Linux用不了</p><h2 id="linux下载安装anaconda">5. Linux下载安装anaconda</h2><p>Windows 下载(注意是下载Linux版本)</p><p>https://www.anaconda.com/download</p><p>通过Xftp 传到Linux /home/name/download</p><p><code>bash Anaconda3-(版本号)-Linux-x86_64.sh</code></p><p>打开<code>~/.bashrc</code>文件，添加如下内容 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 2024.9.13 新增 conda 加入环境变量</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:你的conda安装目录/anaconda3/bin<br></code></pre></td></tr></table></figure></p><p>运行 <code>source ~/.bashrc</code>，关闭当前终端，重启一个终端，运行<code>conda init</code></p><p>创建conda环境</p><p><code>conda create -n sd python==3.10.6</code></p><p>启动环境</p><p><code>conda activate sd</code></p><p><strong>非常重要：之后的所有操作都要在sd环境中</strong></p><h2id="重要cuda驱动支持版本-toolkit版本-pytorch版本-需要对应">重要：CUDA驱动支持版本-toolkit版本-pytorch版本需要对应</h2><p>CUDA驱动版本：执行<code>nvidia-smi</code>输出的CUDA版本号。这个只要服务器上装了N卡驱动就是有的，如果没有，只能联系管理员。</p><p>toolkit版本：执行<code>nvcc --version</code>输出的版本号。如果显示未安装，别急，后面会装。</p><p>pytorch版本：pytorch版本。</p><p>上述三个版本需要对应：</p><p>CUDA是什么版本就去装什么版本的toolkit，然后根据这个版本去选择合适的pytorch版本。pytorch对应关系，见后面。</p><h2 id="linux-安装cudatoolkit">6. Linux 安装cudatoolkit</h2><p>首先查看显卡驱动版本：</p><p><code>nvidia-smi</code> 查看显卡最高支持CUDA版本</p><figure><img src="https://s2.loli.net/2024/09/14/RHJtYWeoClcLEhS.png"alt="图 1" /><figcaption aria-hidden="true">图 1</figcaption></figure><p>在CUDA 官网找到对应cudatoolkit:https://developer.nvidia.com/cuda-toolkit-archive</p><p><a href="https://s2.loli.net/2024/09/14/6T3Z8L2DbXGSwHe.png">图2</a></p><p>将wget 后面的链接复制到浏览器，使用浏览器下载.run文件</p><figure><img src="https://s2.loli.net/2024/09/14/96xZzlePB8EF347.png"alt="图 3" /><figcaption aria-hidden="true">图 3</figcaption></figure><p>将下载好的文件使用Xftp传到服务器上。</p><p>注意：安装cudatoolkit时，请在sd环境中（sd就是之前condacreate那个环境，你的可能不叫这个名）</p><p>如果你和我一样没有管理员权限，只想白嫖实验室GPU玩，则不能按照官方默认的方式进行安装，无管理员权限安装方式如下：</p><p>安装cudatoolkit :参考：https://blog.csdn.net/piapia12138/article/details/128872867 和https://blog.csdn.net/hpqztsc/article/details/108516291</p><p>假设安装目录为/home/name/programs/cuda-12.4</p><p>则创建软链接：<code>ln -s /home/name/programs/cuda-12.4 /home/name/programs/cuda</code></p><p>这样做的好处是以后如果要用cuda-11.8,直接把删除上面的软链接，重新链接到cuda-11.8就行了。</p><p>链接好后，将下面的内容加入到<code>~/.bashrc</code>中，然后<code>source ~/.bashrc</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#2024.09.13 新增 cuda toolkit</span><br><span class="hljs-comment">#使用多版本时，可以使用软连接指定使用的版本</span><br><span class="hljs-built_in">export</span> CUDA_HOME=<span class="hljs-variable">$CUDA_HOME</span>:/home/lxp/programs/cuda<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/home/lxp/programs/cuda/bin<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/home/lxp/programs/cuda/lib64<br></code></pre></td></tr></table></figure><h2 id="安装pytorch">7. 安装pytorch</h2><p><strong>第n遍强调：在之前创建的conda虚拟环境中进行操作</strong></p><p>根据上面安装的CUDA toolkit版本选择合适的pytorch</p><p>注意：我建议使用pip下载，因为我用conda使用清华镜像源下载不了。</p><p>首先要更改pip的下载源：<code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>选择合适的下载命令：</p><p>https://pytorch.org/get-started/previous-versions/</p><figure><img src="https://s2.loli.net/2024/09/14/ZCgzUEledMp8yD1.png"alt="图 4" /><figcaption aria-hidden="true">图 4</figcaption></figure><h2 id="运行launch.py">8. 运行<code>launch.py</code></h2><p><code>python launch.py</code> :如果没有GPU的相关报错，说明上面的步骤没问题了。</p><p>接下来出现的问题基本都是网络的问题。如果你的网络可以访问github等网站，则后续很多步骤都可以跳过。</p><p>如果你和我一样，服务器使用了防火墙，连很多国内IP都访问不了，则只能通过在windows上下载后，传到服务器的方法。</p><h2 id="下载安装-clip">9. 下载安装 clip</h2><p>首先找到秋叶整合包目录下<code>/moudles/launch_utils.py</code>将里面的<code>https://github.com</code>替换为<code>https://ghp.ci/https://github.com</code></p><p>然后运行<code>python launch.py</code>,如果clip和open-clip成功下载并安装，则可以了。</p><p>如果服务器无法访问该链接，则将<code>launch_utils.py</code>中clip和open-clip的相应链接复制到windows系统的浏览器中进行下载。</p><figure><img src="https://s2.loli.net/2024/09/14/F3GHMNpVt29mloO.png"alt="图 5" /><figcaption aria-hidden="true">图 5</figcaption></figure><p>如果这个链接在windows中都无法下载，说明<code>https://ghp.ci</code>挂了。进入<code>https://ghp.ci</code>看看，一般会有新的代理地址。</p><p>下载后传到服务器上任意目录。</p><p>解压，并进入解压后的目录，执行<code>python setup.py install</code>。（又又又强调，执行这个命令的时候一定要在专门创建的虚拟环境中，实际上上面所有在终端执行的操作都<em>一定</em>要在虚拟环境中。</p><p>这个过程可能会失败，显示某个包安装失败，没关系，<code>ctrl+c</code>停止，然后单独<code>pip install</code>该包即可，前面已经将pip改为清华源了，因此单独执行<code>pip install</code>应该是没问题的。</p><h2 id="下载安装-open-clip">10. 下载安装 open-clip</h2><p>和步骤9 相同。只是这次下载和安装的是open-clip。</p><p>如果装好clip和open-clip后，安装gpfan失败，则同样的方式安装gpfan</p><p>只要在<code>launch_utils.py</code>中无法正确下载的才需要这样装，后面因为pip安装失败的，单独使用修改过镜像源的pip安装就行。</p><h2 id="使用镜像源安装requirements_versions.txt">11.使用镜像源安装requirements_versions.txt</h2><p>上面的clip和open-clip安装成功后，安装requirements:<code>pip install -r requirements_versions.txt</code></p><h2 id="安装完成后运行">12. 安装完成后，运行</h2><p>这时候应该就能运行，然后根据端口打开webui了，但绘图还是不行。</p><p>因为缺少<code>clip-vit-large-patch14</code></p><h2 id="下载安装clip-vit-large-patch14">13.下载安装<code>clip-vit-large-patch14</code></h2><p>在windows下，从huggingface:https://huggingface.co/openai/clip-vit-large-patch14/tree/main下载所有文件放在clip-vit-large-patch14中。</p><p>注意，<code>.json</code>文件下载下来后可能会变为<code>.json.txt</code>，要修改为原来的后缀</p><p>将文件夹传输SD项目的根目录（即，xx/stable-diffusion-webui/）下的openai文件夹内即可。<code>openai\clip-vit-large-patch14</code>内包括<code>pytorch_model.bin</code>等文件</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第六章</title>
    <link href="/2024/06/29/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2024/06/29/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-继承与面对对象设计">第六章 继承与面对对象设计</h1><h2id="条款32确定你的public继承塑模出is-a关系">条款32：确定你的public继承塑模出is-a关系</h2><ul><li>public继承意味这<strong>is-a</strong>。适用于baseclasses身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也是一个base class对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>&#123;<br>    <br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span> : <span class="hljs-keyword">public</span> Bird&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> : <span class="hljs-keyword">public</span> Bird&#123;<br>    <br>&#125;;<br><br></code></pre></td></tr></table></figure><h2id="条款33避免遮掩继承而来的名称">条款33：避免遮掩继承而来的名称</h2><ul><li>derived classes 内的名称会遮蔽baseclasses内的名称。在public继承下从来没有人希望如此。</li><li>为了让被遮掩的名称再见天日，可适用using声明式或转交函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::mf1;<span class="hljs-comment">//让Base class内名为mf1的所有东西让Derived class内可见</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>&#123;Base::<span class="hljs-built_in">mf3</span>();&#125;<span class="hljs-comment">//转交函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//</span><br>Derived d;<br><span class="hljs-type">int</span> x;<br>d.<span class="hljs-built_in">mf1</span>();<span class="hljs-comment">//调用Derived class内的mf1</span><br>d.<span class="hljs-built_in">mf1</span>(x);<span class="hljs-comment">//调用Base class内的mf1(int)</span><br>d.<span class="hljs-built_in">mf2</span>();<span class="hljs-comment">//调用Base class内的mf2</span><br>d.<span class="hljs-built_in">mf3</span>();<span class="hljs-comment">//调用Derived class内的mf3</span><br>d.<span class="hljs-built_in">mf3</span>(x);<span class="hljs-comment">//调用Base class内的mf3(double)</span><br></code></pre></td></tr></table></figure><h2id="条款34区分接口继承和实现继承">条款34：区分接口继承和实现继承</h2><ul><li>接口继承和实现继承不同。在public继承下，derived classes 总是继承base class 的接口。</li><li>pure virtual 函数只具体指定接口继承。</li><li>简朴的（非纯）impure virtual函数只具体指定接口继承，并提供默认实现。</li><li>non-pure virtual 函数具体指定接口继承以及强制性实现继承。</li></ul><h2id="条款35考虑virtual函数以外的其他选择">条款35：考虑virtual函数以外的其他选择</h2><ul><li>适用non-virtual interface(NVI) 手法，那是TemplateMethod模式的一个变种。它以public non-virtual成员函数包裹较低访问性的virtual函数。</li><li>将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。</li><li>以tr1::function成员变量替换virtual函数，因而允许适用任何可调用物搭配一个兼容于需求的签名式。</li><li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。</li></ul><h2id="条款36绝不重新定义继承而来的non-virtual函数">条款36：绝不重新定义继承而来的non-virtual函数</h2><ul><li>绝对不要重新定义继承而来的non-virtual函数。</li></ul><h2id="条款37绝不重新定义继承而来的缺省参数值">条款37：绝不重新定义继承而来的缺省参数值</h2><ul><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数--唯一应该覆写的东西--是动态绑定的。</li></ul><h2 id="条款383940">条款38、39、40</h2><ul><li>通过复合塑模出has-a或“根据某物实现出”</li><li>明智而审慎地适用private继承：private继承意味着“is-implemented-in-terms-of”关系，而不是“is-a”关系。它通常比复合的级别低。</li><li>明智而审慎地适用多重继承：多重继承比单一继承复杂，它可能导致新的歧义性，以及对virtual继承的需要。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第五章</title>
    <link href="/2024/06/27/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2024/06/27/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-实现">第五章 实现</h1><h2id="条款26尽可能延后变量定义式的出现时间">条款26：尽可能延后变量定义式的出现时间</h2><ul><li>尽可能延后变量定义式的出现时间，直到真正需要它的时候再进行定义。这样做可增加程序的清晰度并改善程序效率。</li></ul><h2 id="条款27尽量少做转型动作">条款27：尽量少做转型动作</h2><ul><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免<code>dynamic_cast</code>。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li><li>如果转型是必要的，试着将它隐藏在某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码。</li><li>宁可使用C++-style的类型转换，也不要使用旧式的类型转换。</li></ul><h2id="条款28避免返回handles指向对象内部成分">条款28：避免返回handles指向对象内部成分</h2><ul><li>避免返回handles（包括references、指针、迭代器）指向对象内部成分。遵守这个条款可增加封装性，帮助<code>const</code>成员函数的行为像个<code>const</code>，并将发生“虚吊号码牌”的可能性降至最低。</li></ul><h2id="条款29为异常安全而努力是值得的">条款29：为“异常安全”而努力是值得的</h2><h2id="条款30透彻理解inline的里里外外">条款30：透彻理解“inline"的里里外外</h2><ul><li>将大多数<code>inline</code>函数限制在小型、被频繁调用的函数身上。</li></ul><h2id="条款31将文件间的编译依存关系降至最低">条款31：将文件间的编译依存关系降至最低</h2><ul><li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handleclasses和Interface classes。</li><li>程序头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。</li></ul><p>Handle classes: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Person.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthdate, <span class="hljs-type">const</span> Address&amp; address);<br>    ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function">std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">Date <span class="hljs-title">getBirthdate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonImpl</span>;<br>    std::unique_ptr&lt;PersonImpl&gt; impl_;<br>&#125;;<br><br><span class="hljs-comment">// Person.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>::PersonImpl &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthdate, <span class="hljs-type">const</span> Address&amp; address)<br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">birthdate_</span>(birthdate), <span class="hljs-built_in">address_</span>(address) &#123;&#125;<br>    ~<span class="hljs-built_in">PersonImpl</span>() &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <span class="hljs-function">Date <span class="hljs-title">getBirthdate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> birthdate_; &#125;<br>    <span class="hljs-function">Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> address_; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    Date birthdate_;<br>    Address address_;<br>&#125;;<br><br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthdate, <span class="hljs-type">const</span> Address&amp; address)<br>    : <span class="hljs-built_in">impl_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PersonImpl</span>(name, birthdate, address)) &#123;&#125;<br><br><br>Person::~<span class="hljs-built_in">Person</span>() &#123;&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">Person::getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> impl_-&gt;<span class="hljs-built_in">getName</span>(); &#125;<br><br><span class="hljs-function">Date <span class="hljs-title">Person::getBirthdate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> impl_-&gt;<span class="hljs-built_in">getBirthdate</span>(); &#125;<br><br><span class="hljs-function">Address <span class="hljs-title">Person::getAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> impl_-&gt;<span class="hljs-built_in">getAddress</span>(); &#125;<br></code></pre></td></tr></table></figure></p><p>Interface classes:基于接口 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// IPerson.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPerson</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IPerson</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Date <span class="hljs-title">getBirthdate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// Person.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> : <span class="hljs-keyword">public</span> IPerson &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonE</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthdate, <span class="hljs-type">const</span> Address&amp; address)<br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">birthdate_</span>(birthdate), <span class="hljs-built_in">address_</span>(address) &#123;&#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <span class="hljs-function">Date <span class="hljs-title">getBirthdate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> birthdate_; &#125;<br>    <span class="hljs-function">Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> address_; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    Date birthdate_;<br>    Address address_;<br>&#125;;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;IPerson.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-function">std::unique_ptr&lt;IPerson&gt; <span class="hljs-title">createPerson</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthdate, <span class="hljs-type">const</span> Address&amp; address)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Person&gt;(name, birthdate, address);<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第四章</title>
    <link href="/2024/06/21/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2024/06/21/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-设计与声明">第四章 设计与声明</h1><h2id="条款18让接口容易被正确使用不易被误用">条款18：让接口容易被正确使用，不易被误用</h2><ul><li>好的接口很容易被正确使用，不容易被误用。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> : day_(d) &#123;</span><br>        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">1</span> || d &gt; <span class="hljs-number">31</span>) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Day out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> day_;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> : month_(m) &#123;</span><br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1</span> || m &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Month out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> month_;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> : year_(y) &#123;</span><br>        <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Year out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> year_;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Month&amp; m, <span class="hljs-type">const</span> Day&amp; d, <span class="hljs-type">const</span> Year&amp; y);<br>        <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款19设计-class-犹如设计-type">条款19：设计 class 犹如设计type</h2><ul><li>Class 的设计就是 type 的设计。</li></ul><p>设计规范：</p><ol type="1"><li>新type的对象应该如何被创建和销毁？（构造函数和析构函数）</li><li>对象的初始化和对象的赋值该有什么样的差别？（构造函数和赋值操作符的区别）</li><li>新type的对象如果被passed byvalue，应该如何被拷贝？（拷贝构造函数和拷贝赋值操作符）</li><li>什么是新type的“合法值”？</li><li>新typde需要配合某个继承图系吗？</li><li>新type需要什么样的转换？</li><li>什么样的操作符和函数适合于新type？</li><li>什么样的标准函数应该被驳回？那些正是需要声明为private的。</li><li>谁该取用新type的成员？</li><li>什么是新type的“未声明接口”？</li><li>新type有多么一般化？如果需要定义一整个types家族，应该定义一个性的classtemplate。</li></ol><h2id="条款20宁以pass-by-reference-to-const替换pass-by-value">条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><ul><li>尽量以 pass-by-reference-to-const 替换pass-by-value。前者通常比较高效，并可避免切割问题。</li><li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。</li></ul><p>所谓的切割问题，是指当一个derivedclass对象以by-value方式传递给一个base class函数时，baseclass的copy构造函数会被调用，而原来derived class对象的那些特化性质（区别于base class的性质）就会丢失。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//返回窗口的名字</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//显示窗口内容</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span> : <span class="hljs-keyword">public</span> Window&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//显示窗口内容，并带有滚动条</span><br>&#125;;<br><br><span class="hljs-comment">// 不正确的做法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span></span>&#123;<br>    std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    w.<span class="hljs-built_in">display</span>();<br>&#125;<br><br>windowWithScrollBars wws;<br><span class="hljs-built_in">printNameAndDisplay</span>(wws); <span class="hljs-comment">// 没有达到预期效果，wws的性质丢失了，显示的窗口是没有滚动条的</span><br><br><span class="hljs-comment">// 正确的做法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(<span class="hljs-type">const</span> Window&amp; w)</span></span>&#123;<br>    std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    w.<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2id="条款21必须返回对象时别妄想返回其reference">条款21：必须返回对象时，别妄想返回其reference</h2><ul><li>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个localstatic对象。</li><li>一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>()*rhs.<span class="hljs-built_in">numerator</span>(), lhs.<span class="hljs-built_in">denominator</span>()*rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2id="条款22将成员变量申明为private">条款22：将成员变量申明为private</h2><ul><li>切记将成员变量声明为private，这将赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li><li>protected并不比public更具封装性，因为客户仍然可以访问protected成员。</li></ul><h2id="条款23宁以non-membernon-friend替换member函数">条款23：宁以non-member、non-friend替换member函数</h2><ul><li>宁可使用non-member、non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。</li></ul><h2id="条款24若所有参数都需要类型转换则为此采用non-member函数">条款24：若所有参数都需要类型转换，则为此采用non-member函数</h2><ul><li>如果需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member函数。</li></ul><h2id="条款25考虑写出一个不抛异常的swap函数">条款25：考虑写出一个不抛异常的swap函数</h2><ul><li><p>当<code>std::swap</code>对你的类型效率不高时，提供一个<code>swap</code>成员函数，并确定这个函数不抛异常。</p></li><li><p>如果你提供了一个member <code>swap</code> ，也该提供一个non-member<code>swap</code>用于调用前者。对于classes(而非templates)，也请特化<code>std::swap</code>。</p></li><li><p>调用<code>swap</code>时，请使用<code>using std::swap</code>,然后调用<code>swap</code>并且不带任何命名空间修饰。</p></li></ul><p>这一条款比较复杂，建议阅读原文：第四章 条款25.</p>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第三章</title>
    <link href="/2024/06/20/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2024/06/20/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="资源管理">资源管理</h1><h2 id="条款13以对象管理资源">条款13：以对象管理资源</h2><ul><li>为防止资源泄露，请使用RAII对象，它们再构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的RAII calsses 分别是 <code>tr1::shared_ptr</code> 和<code>auto_ptr</code>。前者通常是较佳选择，因为其<code>copy</code>行为比较直观。若选择<code>auto_ptr</code>，复制动作会使被复制指针指向<code>null</code>。</li><li>本条款重点在于让读者对RAII的概念有所了解，关于智能指针的使用，需要参考后续更多条款。</li></ul><h2id="条款14在资源管理类中小心使用拷贝构造函数和赋值运算符copying行为">条款14：在资源管理类中小心使用拷贝构造函数和赋值运算符（<code>copying</code>行为)</h2><ul><li>复制 RAII对象必须一并复制它所管理的资源，所以资源的<code>copying</code>行为决定RAII对象的<code>copying</code>行为。</li><li>普遍而常见的RAII class<code>copying</code>行为是：抑制<code>copying</code>，施行引用计数法（referencecounting）。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(Mutex* pm)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex* pm)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Lock</span>(Mutex* pm)<br>        :<span class="hljs-built_in">mutexPtr</span>(pm) <span class="hljs-comment">//以某个Mutex初始化shared_ptr</span><br>            &#123; <br>                <span class="hljs-built_in">lock</span>(mutexPtr.<span class="hljs-built_in">get</span>()); <br>            &#125;<br><br>    ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mpMutex.<span class="hljs-built_in">get</span>()); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;Mutex&gt; mutexPtr;  <span class="hljs-comment">//使用shared_ptr,施行引用计数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure> ##条款15：在资源管理类中提供对原始资源的访问</li><li>APIs 往往要求访问原始资源，所以每一个RAII class都应该提供一个方法来访问原始资源。</li><li>对原始资源的访问可能经由显示转化或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。</li><li>例如，<code>std::fstream</code>提供了<code>rdbuf()</code>方法来访问底层的<code>std::streambuf</code>对象，而<code>std::shared_ptr</code>等智能指针则提供了<code>get()</code>方法获取原始指针资源。</li></ul><h2id="条款16成对使用new和delete时要采取相同的形式">条款16：成对使用new和delete时要采取相同的形式</h2><ul><li>对于<code>new[]</code>和<code>delete[]</code>形式，请使用相同的形式。</li><li>例如，如果使用<code>new[]</code>，则必须使用<code>delete[]</code>来释放数组。</li><li>同样，如果使用<code>new</code>，则必须使用<code>delete</code>来释放对象。</li></ul><h2id="条款17以独立语句将newed-对象置入智能指针">条款17：以独立语句将newed对象置入智能指针</h2><ul><li>以独立语句将newed对象置入智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</li></ul><p>上述条款似乎有点难理解。直接看例子!! <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priotity</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">precessWidget</span><span class="hljs-params">(std::shared_ptr&lt;Widget&gt; pw,<span class="hljs-type">int</span> priority)</span></span>;<br><br><span class="hljs-comment">//错误用法,下面的做法，一旦priority()发生异常，pw将无法释放，造成内存泄露</span><br><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),<span class="hljs-built_in">priority</span>()); <br><br><span class="hljs-comment">//正确用法</span><br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-built_in">processWidget</span>(pw,<span class="hljs-built_in">priority</span>()); <br></code></pre></td></tr></table></figure>在上述的错误做法中，操作序列为： 1. <code>new Widget</code>分配内存，并构造<code>Widget</code>对象。 2. <code>priority()</code>调用 3. 调用<code>std::shared_ptr</code>构造函数。一旦<code>priority()</code>发生异常，<code>new Widget</code>分配的内存将无法释放，造成内存泄露。</p>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epub电子书制作指南</title>
    <link href="/2024/04/13/other/epub%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%B6%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <url>/2024/04/13/other/epub%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%B6%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="sigil">sigil</h2><p>sigil是一款epub电子书制作软件。</p><p>Dobby据说是原多看阅读App（现小米阅读）的指定epub编辑器。</p><h2 id="使用程序自动进行处理">使用程序自动进行处理</h2><p>说明：</p><ol type="1"><li>程序会首先对txt文档进行整理，把一些不该分段的地方进行合并。然后去除每个段落的前后空格。结果输出到<code>filename_paragraphing.txt</code>中暂存</li><li>程序读取<code>filename_paragraphing.txt</code>中的内容。逐行进行处理。</li><li>根据卷名和章节名，对文章进行拆分，并转换为诸多<code>.xhtml</code>文本，存放在<code>Text</code>文件夹中。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br>    <br><span class="hljs-comment">#1. 段落整理。把应该在一行的合并到一行，然后行与行之间用空行隔开</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">paragraphing</span>(<span class="hljs-params">in_file_path,out_file_path</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(in_file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        lines = f.readlines()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        line.strip()    <span class="hljs-comment">#去除前后空格</span><br>    new_lines = []<br>    punctuation_marks=[<span class="hljs-string">&#x27;，&#x27;</span>,<span class="hljs-string">&#x27;。&#x27;</span>,<span class="hljs-string">&#x27;；&#x27;</span>,<span class="hljs-string">&#x27;！&#x27;</span>,<span class="hljs-string">&#x27;？&#x27;</span>]<br>    skip_next = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)):<br>        <span class="hljs-keyword">if</span> skip_next:<br>            skip_next = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(lines[i])==<span class="hljs-number">0</span>):<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> re.search(<span class="hljs-string">r&#x27;卷|章|节&#x27;</span>, lines[i]):   <span class="hljs-comment">#当前行为卷或章节名</span><br>            new_lines.append(lines[i])<br>        <span class="hljs-keyword">elif</span> i+<span class="hljs-number">1</span>&gt;=<span class="hljs-built_in">len</span>(lines):    <span class="hljs-comment">#最后一行,没有下一行了</span><br>            new_lines.append(lines[i])<br>        <span class="hljs-keyword">elif</span> re.search(<span class="hljs-string">r&#x27;卷|章|节&#x27;</span>, lines[i + <span class="hljs-number">1</span>]): <span class="hljs-comment">#下一行是卷或章节名</span><br>            new_lines.append(lines[i])<br>        <span class="hljs-keyword">elif</span>(re.search(<span class="hljs-string">r&#x27;.*?[\u4e00-\u9fa5]\n&#x27;</span>,lines[i]) <span class="hljs-keyword">and</span> re.search(<span class="hljs-string">r&#x27;[\u4e00-\u9fa5].*?&#x27;</span>,lines[i+<span class="hljs-number">1</span>])):<br>            <span class="hljs-comment">#由用户选择是否合并，直接回车则合并。如果输入标点符号，则在第一行加入标点符号，不合并</span><br>            <span class="hljs-comment"># 让用户选择是否要合并这两行</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;#####################################&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;直接回车则合并。&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入标点符号(。；？！)则在第一行末尾加上输入的标点，不合并。&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入逗号(，),则第一行添加逗号，合并&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入其他字符(空格或字母)，不合并。&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;#####################################&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Line 1: &quot;</span>, lines[i].strip(<span class="hljs-string">&#x27;\n&#x27;</span>))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Line 2: &quot;</span>, lines[i+<span class="hljs-number">1</span>].strip(<span class="hljs-string">&#x27;\n&#x27;</span>))<br>            choice = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;是否合并两行? : &quot;</span>)<br>            <span class="hljs-keyword">if</span> choice.lower() == <span class="hljs-string">&#x27;&#x27;</span>:<br>                new_lines.append(lines[i].strip(<span class="hljs-string">&#x27;\n&#x27;</span>)+lines[i + <span class="hljs-number">1</span>])<br>                skip_next = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> choice.lower() <span class="hljs-keyword">in</span> punctuation_marks:<br>                new_lines.append(lines[i].strip(<span class="hljs-string">&#x27;\n&#x27;</span>)+choice.lower()+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                skip_next = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span> :<br>                new_lines.append(lines[i])<br>        <span class="hljs-keyword">else</span>:<br>            new_lines.append(lines[i])<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(out_file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(<span class="hljs-string">&#x27;&#x27;</span>.join(new_lines))<br><br><span class="hljs-comment"># 处理分卷标题</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">chapters</span>(<span class="hljs-params">in_file_path</span>):<br><br>    sigil_split_mark=<span class="hljs-string">&quot;&quot;&quot;&lt;hr class=&quot;sigil_split_marker&quot; /&gt;&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(in_file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        lines = f.readlines()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        line.strip()    <span class="hljs-comment">#去除前后空格</span><br>    new_lines=[]<br>    chapters_lines=[]<br>    juan_num=<span class="hljs-number">0</span><br>    zhang_num=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)):<br>        line=lines[i]<br>        new_line=line<br>        <span class="hljs-keyword">if</span>(re.search(<span class="hljs-string">r&#x27;.*?第[一二三四五六七八九零十百千万\d]*卷.*?&#x27;</span>,line)):<br>            out_file_path = <span class="hljs-string">&quot;chapter&quot;</span> + <span class="hljs-string">&quot;_&quot;</span>+<span class="hljs-built_in">str</span>(juan_num) +<span class="hljs-string">&quot;_&quot;</span>+<span class="hljs-built_in">str</span>(zhang_num)+ <span class="hljs-string">&quot;xhtml&quot;</span><br>            chapter_file(chapters_lines,out_file_path)<br>            juan_num=juan_num+<span class="hljs-number">1</span><br>            zhang_num=<span class="hljs-number">1</span><br>            chapters_lines=[]<br>            new_line=<span class="hljs-string">&quot;&quot;&quot;&lt;h1 class=&quot;auxiliary-title1&quot;&gt;&quot;&quot;&quot;</span><br>            new_line=new_line+line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)+<span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span><br>            <span class="hljs-comment"># new_lines.append(new_line)</span><br>            <span class="hljs-built_in">print</span>(new_line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>))<br>        <span class="hljs-keyword">elif</span>(re.search(<span class="hljs-string">r&#x27;.*?第[一二三四五六七八九零十百千万\d]*章.*?&#x27;</span>,line)):<br>            out_file_path = <span class="hljs-string">&quot;chapter&quot;</span> + <span class="hljs-string">&quot;_&quot;</span>+<span class="hljs-built_in">str</span>(juan_num) +<span class="hljs-string">&quot;_&quot;</span>+<span class="hljs-built_in">str</span>(zhang_num)+ <span class="hljs-string">&quot;xhtml&quot;</span><br>            chapter_file(chapters_lines,out_file_path)<br>            zhang_num=zhang_num+<span class="hljs-number">1</span><br>            chapters_lines=[]<br>            new_line=<span class="hljs-string">&quot;&quot;&quot;&lt;h2 class=&quot;bodycontent-prefix-text-top&quot;&gt;&quot;&quot;&quot;</span><br>            new_line=new_line+line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)+<span class="hljs-string">&quot;&lt;/h2&gt;&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span><br>            <span class="hljs-comment"># new_lines.append(new_line)</span><br>            <span class="hljs-built_in">print</span>(new_line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>))<br>        <span class="hljs-keyword">else</span>:<br>            new_line=<span class="hljs-string">&quot;&quot;&quot;&lt;p class=&quot;bodycontent-text&quot;&gt;&quot;&quot;&quot;</span><br>            new_line=new_line+line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)+<span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span><br>            new_line = re.sub(<span class="hljs-string">r&#x27;“([^”]*)”&#x27;</span>, <span class="hljs-string">r&#x27;&lt;span class=&quot;kaiti&quot;&gt;“\1”&lt;/span&gt;&#x27;</span>, new_line)<br><br>        chapters_lines.append(new_line)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">chapter_file</span>(<span class="hljs-params">lines,out_file_path</span>):<br>    xhtml_start=<span class="hljs-string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-string">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;</span><br><span class="hljs-string">&quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>    xhtml_title=<span class="hljs-string">&quot;&lt;title&gt;\n&quot;</span>+lines[<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;&lt;/title&gt;&quot;</span><br>    xhtml_start=xhtml_start+xhtml_title<br>    xhtml_start=xhtml_start+<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;link href=&quot;../Styles/stylesheet.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    xhtml_end=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    out_path=os.path.join(<span class="hljs-string">&quot;Text&quot;</span>,out_file_path)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(out_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(<span class="hljs-string">&#x27;&#x27;</span>.join(xhtml_start))<br>        f.write(<span class="hljs-string">&#x27;&#x27;</span>.join(lines))<br>        f.write(<span class="hljs-string">&#x27;&#x27;</span>.join(xhtml_end))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    txt_file_path=<span class="hljs-string">&#x27;女侠且慢.txt&#x27;</span><br>    base_name, ext = os.path.splitext(txt_file_path)<br>    paragraphing_file_path = base_name + <span class="hljs-string">&quot;_paragraphing&quot;</span> + ext<br>    <span class="hljs-comment">#paragraphing(txt_file_path,paragraphing_file_path)</span><br>    chapters(paragraphing_file_path)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Google-CPP风格指南</title>
    <link href="/2024/03/21/CPP/Google-CPP%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <url>/2024/03/21/CPP/Google-CPP%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="google-cpp风格指南">Google-CPP风格指南</h1><h2 id="命名规则">命名规则</h2><ol type="1"><li>通用规则：命名要有描述性，少用缩写</li><li>文件命名：小写+下划线 <code>my_logger.h</code></li><li>类型命名：给个单词首字母大写，不包含下划线<code>MyExcitingClass</code></li><li>变量（包括函数参数）和数据成员名一律小写，单词之间用下划线连接<code>string table_name</code></li><li>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样,但要接下划线.<code>string table_name_</code></li><li>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样,不用像类那样接下划线</li><li>常量命名：以“k"开头，大小写混合。<code>const int kDaysInWeek</code></li><li>函数命名：取值和设值与变量名匹配<code>int count()</code>,<code>void set_count()</code>，小写+下划线</li><li>函数命名：常规函数使用大小写混合（驼峰命名）<code>AddTableEntry()</code></li></ol><h2 id="头文件">1. 头文件</h2><ol type="1"><li>使用<code>#define</code>防护符</li><li>代码文件引用了其他地方定义的符号时，该文件应该直接导入（include)提供该符号的声明头文件</li><li>尽量避免使用前向声明</li><li>只把10行以下的小函数定义为内联（inline)</li><li>推荐按照以下顺序导入头文件：配套的头文件，C语言系统库头文件，C++标准库头文件，其他库头文件，本项目的其他头文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FOO_SERVER_FOOSERVER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO_SERVER_FOOSERVER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;foo/server/fooserver.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;base/basictypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;foo/server/bar.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;third_party/absl/flags/flag.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//FOO_SERVER_FOOSERVER_H</span></span><br></code></pre></td></tr></table></figure><h2 id="作用域">2. 作用域</h2><ol type="1"><li>遵守命名空间命名规则</li><li>用注释给命名空间收尾</li></ol><p>目前没有接触较大的项目，使用作用域的机会较小。以后用到再来学习。</p><h3 id="类">3. 类</h3><ol type="1"><li>不在构造函数中做太多逻辑相关的初始化，考虑使用Init或工厂模式</li><li>编译器提供的默认构造函数不会对变量进行初始化,如果定义了其他构造函数, 编译器不再提供,需要编码者自行提供默认构造函数;</li><li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li><li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为<code>private</code> 且无需实现;</li><li>仅在作为数据集合时使用 <code>struct</code>;</li><li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承,子类重载的虚函数也要声明 <code>virtual</code> 关键字,虽然编译器允许不这样做;</li><li>避免使用多重继承, 使用时, 除一个基类含有实现外,其他基类均为纯接口;</li><li>接口类类名以 <code>Interface</code> 为后缀,除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数,不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为<code>protected</code>;</li><li>为降低复杂性, 尽量不重载操作符, 模板,标准类中使用时提供文档说明;</li><li>存取函数一般内联在头文件中;</li><li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt;<code>private</code>;</li><li>函数体尽量短小, 紧凑, 功能单一;</li></ol><h3 id="智能指针">4. 智能指针</h3><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中.如果其他地方要使用这个对象, 最好传递它的拷贝,或者传递一个不用改变所有权的指针或引用. 倾向于使用<code>std::unique_ptr</code> 来明确所有权传递, 例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;Foo&gt; <span class="hljs-title">FooFactory</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FooConsumer</span><span class="hljs-params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>如果没有很好的理由, 则不要使用共享所有权.这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显,并且操作的对象是不可变的（比如说<code>std::shared_ptr&lt;const Foo&gt;</code> ）时候, 才能这么做.如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p><h3 id="cpplint">5. Cpplint</h3><p><code>cpplint.py</code> 是一个用来分析源文件,能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报,但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>,或在上一行加 <code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p><p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>.如果你参与的项目没有提供, 你可以单独下载 <ahref="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p><h3 id="其他c特性">6. 其他C++特性</h3><h4 id="右值引用">右值引用</h4><p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用<code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code>来表示将值从一个对象移动而不是复制到另一个对象.</p><h4 id="函数重载">函数重载</h4><p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用<code>AppendString()</code> 和 <code>AppendInt()</code> 等，而不是一口气重载多个 <code>Append()</code>.</p><h4 id="缺省函数">缺省函数</h4><p>不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p><h4 id="类型转换">类型转换</h4><p>使用C++的类型转换，而不是使用C风格。例如<code>static_cast&lt;&gt;()</code></p><h4 id="const-用法">const 用法</h4><p>强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用C++11 推出的 constexpr 更好。</p><h4 id="其他">其他</h4><ol type="1"><li>不要使用变长数组和<code>alloca()</code>，使用<code>vector&lt;&gt;</code>,<code>unique_ptr&lt;T[]&gt;</code>等替换</li><li>不要使用C++异常</li><li>不要使用运行时类型识别（RAII）</li><li>不要使用流，使用<code>printf(),fprintf(stderr,..)</code>等替代。</li><li>尽量以内联函数，枚举和常量代替预处理宏。</li></ol><h2 id="pimplprivate-implementation">Pimpl（private Implementation)</h2><p>pimpl的优点：</p><ul><li>核心数据成员被隐藏：核心数据成员被隐藏，不必暴露在头文件中，对使用者透明，提高了安全性</li><li>降低编译依赖，提高编译速度</li><li>接口与实现分离</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//csocket_client.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span> <span class="hljs-comment">//for std::unique_ptr  </span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSocketClient</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSocketClient</span>():<span class="hljs-built_in">m_pImpl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;());<br>    ~<span class="hljs-built_in">CSocketClient</span>();<br><br>    <span class="hljs-comment">//其他功能函数</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span>                  <span class="hljs-title class_">Impl</span>;<br>    std::unique_ptr&lt;Impl&gt;   m_pImpl;<br>&#125;;<br><br><span class="hljs-comment">//csocket_client.cpp</span><br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">CSocketClient</span>::Impl<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-comment">//方法的具体实现</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//其他方法省略...</span><br>    <br><span class="hljs-keyword">public</span>:<br>SOCKET                          m_hSocket;<br>    <span class="hljs-type">short</span>                           m_nPort;<br>    <span class="hljs-type">char</span>                            m_szServer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">long</span>                            m_nLastDataTime;        <span class="hljs-comment">//最近一次收发数据的时间</span><br>    <span class="hljs-type">long</span>                            m_nHeartbeatInterval;   <span class="hljs-comment">//心跳包时间间隔，单位秒</span><br>    CRITICAL_SECTION                m_csLastDataTime;       <span class="hljs-comment">//保护m_nLastDataTime的互斥体 </span><br>    HANDLE                          m_hSendDataThread;      <span class="hljs-comment">//发送数据线程</span><br>    HANDLE                          m_hRecvDataThread;      <span class="hljs-comment">//接收数据线程</span><br>    std::string                     m_strSendBuf;<br>    std::string                     m_strRecvBuf;<br>    HANDLE                          m_hExitEvent;<br>    <span class="hljs-type">bool</span>                            m_bConnected;<br>    CRITICAL_SECTION                m_csSendBuf;<br>    HANDLE                          m_hSemaphoreSendBuf;<br>    HWND                            m_hProxyWnd;<br>    CNetProxy*                      m_pNetProxy;<br>    <span class="hljs-type">int</span>                             m_nReconnectTimeInterval;    <span class="hljs-comment">//重连时间间隔</span><br>    <span class="hljs-type">time_t</span>                          m_nLastReconnectTime;        <span class="hljs-comment">//上次重连时刻</span><br>    CFlowStatistics*                m_pFlowStatistics;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第二章</title>
    <link href="/2023/10/19/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/10/19/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="了解-c-默默编写并调用了哪些函数">5. 了解 C++默默编写并调用了哪些函数</h2><ul><li>编译器可以暗自为 class 创建 default 构造函数,copy 构造函数,copyassignment 操作符,以及析构函数.</li><li>如果你打算在一个"内含<code>reference</code>成员"的 class内支持赋值操作,则必须自己定义复制构造函数和赋值操作符.同样,拥有 const成员变量的类也必须自己定义复制和赋值函数. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//以下只是一个例子,真实场景中应尽量避免定义类成员函数为引用.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameObject</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NameObject</span>(string&amp; name,<span class="hljs-type">const</span> T&amp; value);<br><br><span class="hljs-keyword">private</span>:<br>    string &amp;name_value_;<br>    <span class="hljs-type">const</span> T object_value_;<br>&#125;;<br><span class="hljs-comment">//上面的情况请提供自定义的复制构造函数和赋值运算符重载.</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="若不想使用编译器自动生成的函数就该明确拒绝">6.若不想使用编译器自动生成的函数,就该明确拒绝</h2><ul><li>如果你不希望某个对象具有复制的功能,应使用<code>delete</code>拒绝编译器自动帮你生成复制函数.</li><li>将copy和 copy assignment 函数声明为 private,且不提供实现也可以,但没有使用<code>delete</code>直观 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>()&#123;&#125;<br>    ~<span class="hljs-built_in">HomeForSale</span>()&#123;&#125;<br><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;)=<span class="hljs-keyword">delete</span>;<br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;)=<span class="hljs-keyword">delete</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="为多态基类声明-virtual-析构函数">7. 为多态基类声明 virtual析构函数</h2><p>C++ 明确指出,当 derived class 对象经由一个 base class 指针被删除,而该base class 带着一个 non-virtual析构函数时,其结果未定义.实际执行的通常情况是 base class中的资源被释放,但 drived class 中的资源没被销毁. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeKeeper</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicClock</span>:<span class="hljs-keyword">public</span> TimeKeeper&#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>TimeKeeper* ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">delete</span> dtk; <span class="hljs-comment">//此时能正确调用派生类和基类的析构函数.</span><br></code></pre></td></tr></table></figure> *带多态性质的 base class 应该声明一个 virtual 析构函数.如果 class带有任何 virtual 函数,它就应该拥有一个 virtual 析构函数. * class的设计目的如果不是作为 base class 使用,或不是为了具备多态性,就不该声明virtual 析构函数 *可以使用<code>virtual ~ClassName() = 0</code>来生成一个纯虚类,此时需要给纯虚析构函数一个定义,不过什么都不用做.<code>ClassName::~ClassName()&#123;&#125;</code></p><h2 id="别让异常逃离析构函数避免在析构函数中出现异常">8.别让异常逃离析构函数(避免在析构函数中出现异常)</h2><ul><li>析构函数绝对不要吐出异常.如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下他们(不传播)或结束程序.</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么 class应该提供一个普通函数(而非在析构函数中)执行该操作. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>        db.<span class="hljs-built_in">close</span>();<br>        closed=<span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>        <span class="hljs-keyword">if</span>(!closed)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                db.<span class="hljs-built_in">close</span>():<br>            &#125;<span class="hljs-built_in">catch</span>()&#123;<br>                <span class="hljs-comment">//...</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DBConnection db;<br>    <span class="hljs-type">bool</span> closed;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="绝不在构造和析构过程中调用-virtual-函数">9.绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造和析构期间不要调用 virtual 函数,因为这类调用从不下降至 derivedclass (比起当前执行构造函数和析构函数的那层)</p><h2 id="令-operator-返回一个-reference-to-this">10. 令 operator=返回一个 reference to *this</h2><ul><li>令赋值操作符返回一个 reference to *this,这是为了实现"连锁赋值"<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Widget&amp; oprator=(<span class="hljs-type">int</span> rhs)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> ## 11. 在operator= 中处理"自我赋值"小心潜在的"自我赋值"导致的错误. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 一份不安全的operator= 实现版本</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;          <br>    pb=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);  <span class="hljs-comment">//如果rhs==*this就出问题了</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 两种解决办法:</li></ul><ol type="1"><li>"证同测试" <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;rhs ) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//证同测试</span><br>    <span class="hljs-keyword">delete</span> pb;          <br>    pb=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);  <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>实现"异常安全性" <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Bitmap* pOrig=pb;   <span class="hljs-comment">//记住原来的pb</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<span class="hljs-comment">//执行赋值</span><br>    <span class="hljs-keyword">delete</span> pOrig;<span class="hljs-comment">//删除原先的pb</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure> ## 12.复制对象时勿忘其每一个成分</li></ol><ul><li>copying 函数应该确保复制"对象内所有的成员变量"及"所有 base class成分</li><li>不要尝试一某个 copying 函数实现另一个 copying函数.应该将共同机能放进第三个函数中,并由两个 copying 函数共同调用.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">PriorityCustomer::<span class="hljs-built_in">PrioriytCustomer</span>(<span class="hljs-type">const</span> PriotiryCustomer&amp; rhs)<br>:<span class="hljs-built_in">Customer</span>(rhs), <span class="hljs-comment">//调用base class 的copy 构造函数</span><br><span class="hljs-built_in">priority</span>(rhs.priotiry)<br>&#123;<br><br>&#125;<br>PriorityCustomer&amp; <br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Priorityj&amp; rhs)&#123;<br>    Customer::<span class="hljs-keyword">operator</span>=(rhs);<br>    priority = rhs.priotity;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 读书笔记-第一章</title>
    <link href="/2023/10/17/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/10/17/CPP/effective%20c++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-读书笔记">Effective C++ 读书笔记</h1><h2 id="视-c-为一个语言联邦">1. 视 C++ 为一个语言联邦</h2><p>C++的四个次语言:</p><ul><li><strong>C</strong> .</li><li><strong>Object-Oriented C++ .</strong> 面对对象</li><li><strong>Template C++</strong> 模板,泛型编程</li><li><strong>STL</strong>. 标准模板库</li></ul><h2 id="尽量以constenuminline替换define">2.尽量以const,enum,inline替换#define</h2><ul><li>对于单纯变量,最好以 const 对象或 enums 替换#define</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用 const 替换 #define </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NumOfMonths=<span class="hljs-number">12</span>;<br><span class="hljs-comment">// 编译期不需要知道常量值时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostEstimate</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> FudgeFactor;<span class="hljs-comment">//位于头文件中  </span><br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> CostEstimate::FudgeFactor=<span class="hljs-number">1.35</span>;<span class="hljs-comment">//位于实现文件中</span><br><br><span class="hljs-comment">// 编译期需要知道常量值可以用 enum hack 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns=<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于形似函数的宏,使用 inline <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(a&gt;b?a:b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="尽可能使用-const">3.尽可能使用 const</h2><ul><li><code>const</code> 修饰指针<ul><li><code>const</code> 在星号左边表示被指物为常量<code>const Widget* w; Widget const * w;</code> w指向一个常量</li><li><code>const</code> 在星号右边表示指针自身为常量<code>Widget * const w</code> w这个指针为常量,不能改变它的指向</li><li><code>const</code>同时出现在左边和右边表示被指物和指针两者都是常量</li></ul></li><li><code>const</code> 修饰智能指针<ul><li>直接使用<code>const</code>表示智能指针本身为常量(不能指向其他对象):<ul><li><code>const vector&lt;int&gt;::iterator ite=vec.begin()</code></li></ul></li><li>使用<code>const_iterator</code>表示常量的智能指针(不能改变指针指向的对象):<ul><li><code>vector&lt;int&gt;::const_iterator ite=vec.cbegin()</code></li></ul></li></ul></li><li><code>const</code> 修饰函数<ul><li><code>const</code> 在最左边表示返回值为常量<code>const A func(A&amp; a1,const A&amp; a2) &#123;...&#125;</code></li><li><code>const</code>在右边表示该函数不会改变传入的参数<code>A func(A&amp; a1,const A&amp; a2) const &#123;...&#125;</code></li></ul></li><li><code>const</code> 成员函数不可以更改对象内任何<code>non-static</code> 成员变量,但有时候我们希望某些变量可以在<code>const</code>成员函数中改变,此时可以用<code>mutable</code>修饰成员变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *pText;<br>    <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!lengthIsValid)&#123;<br>        <span class="hljs-comment">//mutable 的成员变量能在const成员函数中修改</span><br>        textLength=std::<span class="hljs-built_in">strlen</span>(pText); <br>        lengthIsValid=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>const 函数可以调用 non-const 函数,甚至可以使用 const函数来实现同名的 non-const 函数 ,从而避免代码重复.</li><li><strong>不要在 const 函数中调用 non-const函数,即使你感觉没问题</strong></li></ul><h2 id="确定对象被使用前已先被初始化">确定对象被使用前已先被初始化</h2><ul><li>为内置型对象进行手工初始化,因为C++不保证初始化他们</li><li>构造函数最好使用成员初值列(member initializationlist),而不要在构造函数本体内进行赋值操作.初值列列出的成员变量,其排列次序应该和他们在class中的声明次序相同</li><li>为免除"跨编译单元之初始化次序"问题,请以local static 对象替换non-local-static 对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 不推荐的做法</span><br>ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std::string&amp; name,<span class="hljs-type">const</span> std::string&amp; address,<br>                <span class="hljs-type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">以下这些是赋值而不是初始化</span><br><span class="hljs-comment">*/</span><br>    theName=name;<br>    theAddress=address;<br>    thePhones=phones;<br>    numTimesConsulter=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++规定,对象的成员变量的初始化动作发生在进入构造函数本体之前,在上面的构造函数中,<code>theName, theAddress,thePhones</code>等变量都不是初始化,而是被赋值.真正的初始化发生在进入构造函数之前,这导致这种实现对一个自定义对象先调用 default构造函数进行初始化,然后立刻对他们赋予新值,这导致之前的 default构造毫无意义. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 推荐的做法</span><br>ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std::string&amp; name,<span class="hljs-type">const</span> std::string&amp; address,<br>                <span class="hljs-type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones):<br>    <span class="hljs-built_in">theName</span>(name),<br>    <span class="hljs-built_in">theAddress</span>(address),<br>    <span class="hljs-built_in">thePhones</span>(phones),<br>    <span class="hljs-built_in">numTimesConsulter</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 以上使用初值列对成员对象进行初始化</span><br>&#123; &#125;<br></code></pre></td></tr></table></figure></p><p>对 local static 对象进行简单包装,将其转换为 static对象可以解决一些初始化次序问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123;...&#125;;<br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> FileSystem fs;<br>    <span class="hljs-keyword">return</span> fs;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span>&#123;...&#125;;<br>Directory::<span class="hljs-built_in">Directory</span>(params)<br>&#123;<br>    ...<br>    std::<span class="hljs-type">size_t</span> disks=<span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();<br>    ...<br>&#125;<br><span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Directory td;<br>    <span class="hljs-keyword">return</span> td;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp随机数</title>
    <link href="/2023/10/10/CPP/cpp%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2023/10/10/CPP/cpp%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp-随机数">CPP 随机数</h1><p>传统的使用<code>rand()</code>产生随机数有许多缺点，例如受最大最小值限制，随机数分布不均匀等。C++11提供了对随机数的更好的支持。目前，向获得较好的随机数可以有一下三个步骤：</p><ul><li>使用<code>random_device</code>利用硬件生成随机种子，这种方法使用硬件，开销大，一般只用来产生随机种子</li><li>使用上述的随机种子作为随机数生成器的参数构造生成器，常用且较好的生成器为<code>std::mt19937</code></li><li>使用<code>uniform_int_distribution</code>等给生成器限定范围</li></ul><p>实例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 注意windows下使用random_device不能使用mingw-gcc做编译器,linux下是正常的</span><br><span class="hljs-comment">* windows下要用random_device就使用msvc编译</span><br><span class="hljs-comment">* 如果windows下就是要用mingw-gcc,那么可以用: </span><br><span class="hljs-comment">* std::mt19937 rng(time(NULL));</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/* linux mingw-gcc*/</span><br>    <span class="hljs-comment">// std::random_device rnd; //利用硬件实现生成随机种子,效率低,所以只用来生成种子</span><br>    <span class="hljs-comment">// std::mt19937 rng(rnd()); //linux</span><br><br>    <span class="hljs-comment">/* windows mingw-gcc或msvc */</span><br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-literal">NULL</span>))</span></span>; <span class="hljs-comment">//windows   利用随机种子rnd生成的更好的随机数生成器</span><br><br>    <span class="hljs-comment">/* 均匀分布 */</span><br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//限制类型和范围,且随机数均匀分布</span><br>    <span class="hljs-function">std::uniform_real_distribution&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">unf</span><span class="hljs-params">(<span class="hljs-number">0.0f</span>,<span class="hljs-number">10.0f</span>)</span></span>; <span class="hljs-comment">//浮点随机数,随机数均匀分布</span><br>    <span class="hljs-function">std::uniform_real_distribution&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">und</span><span class="hljs-params">(<span class="hljs-number">10.0f</span>,<span class="hljs-number">20.0f</span>)</span></span>; <span class="hljs-comment">//double随机数,均匀分布</span><br>    <span class="hljs-comment">/* 正太分布 */</span><br>    <span class="hljs-comment">// std::normal_distribution&lt;int&gt; uni(50,100);</span><br>    <span class="hljs-comment">// std::normal_distribution&lt;float&gt; unf(0.0f,10.0f);</span><br>    <span class="hljs-comment">// std::normal_distribution&lt;double&gt; und(10.0f,20.0f);</span><br>    <span class="hljs-type">int</span> random_int=<span class="hljs-built_in">uni</span>(rng);<br>    <span class="hljs-type">float</span> random_float=<span class="hljs-built_in">unf</span>(rng);<br>    <span class="hljs-type">double</span> random_double=<span class="hljs-built_in">und</span>(rng);<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;random_int: &quot;</span>&lt;&lt;random_int&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;random_float: &quot;</span>&lt;&lt;random_float&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;random_double: &quot;</span>&lt;&lt;random_double&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">// 生成随机数组</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    std::<span class="hljs-built_in">generate</span>(<span class="hljs-built_in">begin</span>(a),<span class="hljs-built_in">end</span>(a),[&amp;]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">uni</span>(rng);&#125;);<br><br>    std::vector&lt;<span class="hljs-type">float</span>&gt; b;<br>    std::<span class="hljs-built_in">generate_n</span>(std::<span class="hljs-built_in">back_inserter</span>(b),<span class="hljs-number">10</span>,[&amp;]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">unf</span>(rng);&#125;);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v:a)&#123;<br>        std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v:b)&#123;<br>        std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br>    <br>    <span class="hljs-comment">// 从数组中随机取数</span><br>    std::vector&lt;std::string&gt; vec_str &#123;<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;cherry&quot;</span>,<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>&#125;;<br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">size_t</span>&gt; <span class="hljs-title">uns</span><span class="hljs-params">(<span class="hljs-number">0</span>,vec_str.size())</span></span>;<br>    std::cout&lt;&lt;vec_str[<span class="hljs-built_in">uns</span>(rng)]&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux C++编译与调试</title>
    <link href="/2023/04/07/Linux/Linux%20C++%E7%BC%96%E8%AF%91%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <url>/2023/04/07/Linux/Linux%20C++%E7%BC%96%E8%AF%91%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="g-编译">g++ 编译</h3><ul><li><code>vim show.cpp</code> #ifndef SHOW_CPP_ #define SHOW_CPP_#include void show(){ std::cout&lt;&lt;"hello world"&lt;&lt;endl; }#endif //end SHOW_CPP_</li><li><code>:n main.cpp</code> #ifndef MAIN_CPP_ #define MAIN_CPP_ voidshow(); int main(void){ show(); int i=0;//故意留的warning return 0;}</li><li>g++编译</li></ul><p>:w 保存 Ctrl+z 暂时挂起（fg命令行恢复） 执行编译命令：</p><p><code>g++ main.cpp show.cpp -o main</code></p><p>编译成功则执行 <code>./main</code>运行可执行程序</p><p>若编译不成功输入fg恢复vim窗口，Debug后重试</p><h4 id="g语法基础">g++语法基础</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">g++ -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> &gt; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.i</span> <span class="hljs-comment">//预处理并结果放入main.i，也可以命名为main.txt等</span><br>g++ -S <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.i</span> -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.s</span> <span class="hljs-comment">//生成汇编文件，这个不太常用</span><br>g++ -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> <span class="hljs-comment">//预处理，编译和汇编，将程序做成obj文件，上述命令生成main.o和show.o</span><br>g++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> <span class="hljs-comment">//直接生成可执行文件，默认明明为a.out   ./a.out即可执行</span><br>g++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span>  <span class="hljs-comment">//和上面一样直接生成可执行文件，但被我们命名为main ./main即可执行</span><br>g++ -g <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> show<span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span> <span class="hljs-comment">//直接生成可执行文件并重命名为main,但-g保留了调试信息，可以使用gdb进行调试</span><br></code></pre></td></tr></table></figure><p>总结：g++ [-E|-S|-c] [-g] file1.h file1.cpp file2.cpp -o myName 或者g++ [-E|-S|-c] [-g] -o myName file1.h file1.cpp file2.cpp 也就是 【-o生成名】放前放后都可以，但都要在[-E|-S|-c] [-g]后面</p><h3 id="makefile-文件基础">makefile 文件基础</h3><p>每次输入g++语法命令太麻烦，用makefile文件来更方便的编译文件。makefile的基础就是： 目标：依赖 运行指令当依赖不存在时，去后面找依赖的生成，即该依赖作为目标的语句。当依赖都存在且依赖比目标新的时候，执行“运行指令”生成最新的目标文件。高阶内容需要时自查，下面这个例子可以应付目前大多数项目了。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj=main.o show.o <span class="hljs-comment">#可以理解为重命名</span><br><span class="hljs-section">main:<span class="hljs-variable">$(obj)</span></span><br>g++ -g -o main <span class="hljs-variable">$(obj)</span> <span class="hljs-comment">#加-g是为了可以用gdb调试</span><br><span class="hljs-section">main.o: (*.h)# 上面的例子没有.h文件，如果有，要加上</span><br>g++ -g -c main.cpp<br><span class="hljs-section">string.o:(*.h)</span><br>g++ -g -c string.cpp<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean #虚目标，理解为makefile不会直接运行clean下面的命令</span><br><span class="hljs-section">clean:  #终端输入 make clean时，下面命令开始执行</span><br>-rm main *.o <span class="hljs-comment">#删除生成的文件，方便重编译</span><br>clear <span class="hljs-comment">#清空终端</span><br>ls <span class="hljs-comment">#列出当前目录</span><br></code></pre></td></tr></table></figure></p><p>更方便的makefile模板</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGET := main<br>SOURCE_DIR   := src<br>INCLUDE_DIR  := <span class="hljs-keyword">include</span><br>OBJECT_DIR   := obj<br>BIN_DIR      := bin<br><br>CC := g++<br>CCFLAGS := -g -Wall -std=c++11<br><br>SRCFILES     := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(SOURCE_DIR)</span>/*.cpp)</span><br>INCLUDES     := <span class="hljs-variable">$(INCLUDE_DIR)</span><br>OBJECTS      := $(SRCFILES:<span class="hljs-variable">$(SOURCE_DIR)</span>/%.cpp=<span class="hljs-variable">$(OBJECT_DIR)</span>/%.o)<br><br><span class="hljs-section">all: <span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span></span><br><br><span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span>: <span class="hljs-variable">$(OBJECTS)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CCFLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(OBJECTS)</span><br><br><span class="hljs-variable">$(OBJECT_DIR)</span>/%.o: <span class="hljs-variable">$(SOURCE_DIR)</span>/%.cpp<br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CCFLAGS)</span> -I<span class="hljs-variable">$(INCLUDES)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:run clean</span><br><br><span class="hljs-section">run:</span><br><span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-section">clean:</span><br>rm <span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(TARGET)</span> <span class="hljs-variable">$(OBJECTS)</span><br><br><br></code></pre></td></tr></table></figure><h3 id="gdb-调试基础">gdb 调试基础</h3><p>用带-g指令的g++生成可执行文件后，使用gdb ./main 启动gdb调试<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">b main  <span class="hljs-regexp">//m</span>ain函数起点设置断点<br>b main.cpp:<span class="hljs-number">25</span> <span class="hljs-regexp">//m</span>ain.cpp文件的<span class="hljs-number">25</span>行处设置断点<br>run  <span class="hljs-regexp">//</span>运行程序，要运行起来才能调试<br>start <span class="hljs-regexp">//</span>开始单步调试<br>layout src <span class="hljs-regexp">//</span>显示源代码，这个比较直观，就和使用IDE一样了<br>n  <span class="hljs-regexp">//</span>下一行<br>s  <span class="hljs-regexp">//</span>进入函数<br>c  <span class="hljs-regexp">//</span>跳到下一个断点<br>p var <span class="hljs-regexp">//</span>打印var的值（信息）基础指令<br></code></pre></td></tr></table></figure></p><ul><li>启动<code>gdb</code> #1.没有参数情况：gdb+可执行程序 gdb ./main#2.带参数：gdb --args 可执行程序 + args gdb --args ./main 2 #2是参数#int main(int args,char* argv[]); #3.连接已经运行的程序 gdp -p PID#终端ps -x 查看进程PID sudo gdp -p PID</li><li>查看源码 #1.list 列出部分源码 list | l #2.列出往上的10行源码 list-10 #3.所有源代码 layout src</li><li>运行程序 #1.使用run运行程序 run</li><li>设置断点 #1.b 函数名 b main #2.b 文件名:行号 b main.cpp:10</li><li>查看断点 info breakpoints info b</li><li>删除断点 #1.删除指定断点 delete num delete 3#删除第三个断点，第几个可以用info查看 #2.删除所有代码 delete回车之后输入y确认删除所有断点</li><li>单步执行 #1.运行一行,不进入函数 next n | next #2.进入函数 step s |step #3.按机器指令执行一次 ni si</li><li>查看变量 #查看、打印变量 p p var_name</li><li>监控变量 #1.监控变量，如果发生变化就通知 watch var#2.监控变量，达到条件通知 watch var if var==1#var变量变为1的时候通知我们 #3.查看所有watchpoints info watchpoint</li><li>跳出函数,循环 finish</li><li>退出 quit</li></ul><h4 id="gdb-补充">gdb 补充</h4><ul><li>查看堆栈信息 x /20aw $sp#当前堆栈的20条信息，以ASCII码宽字符形式打印</li><li>记录回溯 反向调试 #1.记录一个执行点，运行几步后返回 record#记录当前位置 #使用record后可以反向调试 #往前走一行reverse-next,真正的程序肯定不能逆向，当调试程序是可以的 reverse-n |reverse-next reverse-s | reverse-step #反向调试到调用当前函数的位置reverse-finish #每次输入reverse很麻烦，如果需要始终反向走，使用set setexec-direction reverse #反向调试可能会影响性能，不用是尽快结束 recordstop</li><li>执行终端指令 #gdb调试下也可以执行终端命令 shell 命令 (gdb)shell ls(gdb)shell cat -n test.cpp #-n是显示行号</li><li>日志功能 #开启日志功能，可以把调试全过程记录下来 set logging on</li><li>调试core文件#程序发生段错误等原因挂掉，可能无法调试.out二进制文件，需要调试core文件#core文件不会默认生成 ulimit -a #查看限制 core file size 默认是0 ulimit-c unlimited #解除占用后重新使用 g++ -g main.cpp#此时就会生成core文件，再用gdb调试 gdb ./main core文件#core文件的名字用ll可查看 #如果没有生成core文件，使用ulimit -a看看是不是权限被限制了。</li><li>调试正在运行的程序 #后台运行 ./a.out&amp; #查看进程号 ps -ef ps -ef| grep a.out #调试正在运行的程序 gdb -p PID</li></ul><h3 id="cmake">cmake</h3><p>基础CMakeLists.txt <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#指定最低版本</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-comment">#项目名</span><br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-comment">#需生成的可执行文件</span><br>add_excutable(add add.cpp num.cpp)<br><span class="hljs-comment">#也可以用;分割</span><br>add_excutable(sub sub.cpp;num.cpp)<br></code></pre></td></tr></table></figure> 进阶</p><ol type="1"><li>通过在CMake里定义变量来更方便的指定可执行文件的.cpp文件。</li><li>通过<code>set(CMAKE_CXX_STANDARD 17)</code>指定CPP标准</li><li><code>set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin)</code>指定可执行程序的输出路径<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#set 设置变量，CMake里的变量都是string类型</span><br><span class="hljs-comment">#相当 于string ADD_SRC=&quot;add.cpp num.cpp&quot;</span><br><span class="hljs-keyword">set</span>(ADD_SRC add.cpp num.cpp)  <br><span class="hljs-comment">#相当于string SUB_SRC=&quot;sub.cpp;num.cpp&quot;</span><br><span class="hljs-keyword">set</span>(SUB_SRC sub.cpp;num.cpp)<br><span class="hljs-comment">#使用变量</span><br>add_excutable(add <span class="hljs-variable">$&#123;ADD_SRC&#125;</span>)<br>add_excutable(sub <span class="hljs-variable">$&#123;SUB_SRC&#125;</span>)<br><span class="hljs-comment">#指定CPP标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-comment">#设置输出文件夹</span><br><span class="hljs-keyword">set</span>(HOME /home/lumos/<span class="hljs-keyword">project</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;HOME&#125;</span>/bin)<br></code></pre></td></tr></table></figure></li><li>搜索源文件,使用<code>aux_source_directory</code>搜索源文件</li><li>使用<code>include_directories</code>添加头文件 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(HOME /home/lumos/<span class="hljs-keyword">project</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;HOME&#125;</span>/bin)<br><span class="hljs-comment">#添加头文件目录</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment">#搜索源文件，注意第一个参数为源文件目录，第二个参数为结果存放的变量名</span><br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)<br>add_excutable(app <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><br><span class="hljs-comment">#另一种搜索方式</span><br><span class="hljs-comment">#注意这里用的CMAKE_CURRENT_SOURCE_DIR和上面的PROJECT_SOURCE_DIR在只有一个CMakeLists.txt是一样的。</span><br><span class="hljs-comment">#file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP 面试100问</title>
    <link href="/2023/04/06/CPP/CPP%E9%9D%A2%E8%AF%95100%E9%97%AE/"/>
    <url>/2023/04/06/CPP/CPP%E9%9D%A2%E8%AF%95100%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="cpp-100问">CPP 100问</h1><p>问题来源: B站up主:计算机视觉与OpenCV https://b23.tv/fPgu9kg</p><p>答案:自己整理总结</p><h3 id="include-双引号与尖括号的区别">1.include双引号与尖括号的区别</h3><ul><li>双引号优先在当前目录查找</li><li>尖括号直接从预设的系统目录中搜索,主要用于包含标准库文件</li></ul><h3 id="常量指针和指针常量的区别">2.常量指针和指针常量的区别</h3><ul><li>常量指针<code>const int *p</code>:指向常量的指针,表示不可用p更改所指向的内存区域的值.</li><li>指针常量<code>int* const p</code>:指针本身为常量,即指针不可改变指向</li></ul><h3 id="cpp-常用新特性">3.CPP 常用新特性</h3><ol type="1"><li>auto 类型推导</li><li>基于范围的 for 循环.</li><li>lambda 表达式</li><li>智能指针:<code>unique_ptr,shared_ptr,weak_ptr</code></li></ol><p>lambda 表达式: *<code>[捕获列表](参数列表) mutable(可选) noexcept -&gt; 返回类型&#123;/*代码块*/&#125;</code>*捕获列表:<code>[]</code>无捕获,<code>[x,&amp;y]</code>按值捕获x,按引用捕获y,<code>[&amp;]</code>按引用捕获所有外部变量,<code>[=]</code>按值捕获所有外部变量,<code>[&amp;,x]</code>除了x按值捕获,其余按引用捕获* mutable 修饰符:lambda 按值捕获的变量是const的,使用mutable修饰符可以在代码块中修改按值捕获的变量.<strong>但外部的变量并没有改变,如果想要lambda修改外部变量的值,请使用引用捕获</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> lambda = [x]() <span class="hljs-keyword">mutable</span> &#123; x += <span class="hljs-number">1</span>; &#125;;  <span class="hljs-comment">// 使用了mutable，因此可以修改x的值</span><br><span class="hljs-built_in">lambda</span>();<br>cout&lt;&lt;x&lt;&lt;endl;<span class="hljs-comment">//还是0,外部的x并没有变化</span><br></code></pre></td></tr></table></figure></p><h3id="智能指针的使用有哪些需要注意的点">4.智能指针的使用有哪些需要注意的点</h3><ol type="1"><li><p>避免<code>shared_ptr</code>的循环引用.使用<code>weak_ptr</code>打破循环引用.</p></li><li><p>注意线程安全:<code>shared_ptr</code>不是线程安全的,如果在一个线程中复制<code>shared_ptr</code>,在另一个线程中删除,可能会导致问题</p></li></ol><h4 id="unique_ptr">unique_ptr</h4><p><code>unique_ptr</code> 是一个独享所有权的智能指针,它禁止了拷贝操作.使用场景:</p><ol type="1"><li><p>资源独占:确保一段内存或资源在同一时间只能被一个引用或指针持有时,使用<code>unique_ptr</code></p></li><li><p>函数返回动态内存:如果函数需要返回一个动态分配的对象,使用<code>unique_ptr</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>&#125; <span class="hljs-comment">// 这样返回的对象不需要手动释放</span><br></code></pre></td></tr></table></figure></p></li><li><p>类的pImpl惯用法:如果想要使用pImpl技术隐藏类的实现细节,<code>unique_ptr</code>是一个很好的选择<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>();<br>    ~<span class="hljs-built_in">MyClass</span>();<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Impl</span>; <span class="hljs-comment">// 前向声明</span><br>    std::unique_ptr&lt;Impl&gt; pImpl; <span class="hljs-comment">// 使用unique_ptr保存Impl对象的指针，避免头文件中引入Impl的定义</span><br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="shared_ptr">shared_ptr</h4><p><code>shared_ptr</code>是一个共享所有权的指针指针,可以有多个shared_ptr指向同一块内存，内部通过引用计数来管理内存的释放。当最后一个指向内存的shared_ptr被销毁时，内存将自动被释放。shared_ptr适合在需要共享所有权的场景中使用</p><p><code>shared_ptr</code>的使用场景 1.共享所有权:多个指针对同一个对象进行管理,可以选择<code>shared_ptr</code>,比如,一个程序的不同部分,有多个函数或对象需要共享对同一个动态分配对象的访问.</p><ol start="2" type="1"><li>关联容器与智能指针:如果你想在关联容器(例如<code>std::map</code>)中存储指向动态分配对象的指针，同时又希望这些对象在不再需要时能被自动删除，你应该考虑使用<code>shared_ptr</code>。</li></ol><h4 id="weak_ptr">weak_ptr</h4><p><code>weak_ptr</code>用来解决<code>shared_ptr</code>可能造成的循环引用问题.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeFriend</span><span class="hljs-params">(std::shared_ptr&lt;Person&gt; newFriend)</span> </span>&#123; <br>        friends.<span class="hljs-built_in">push_back</span>(newFriend); <br>        newFriend-&gt;<span class="hljs-built_in">beFriendedBy</span>(std::<span class="hljs-built_in">weak_ptr</span>&lt;Person&gt;(<span class="hljs-built_in">shared_from_this</span>())); <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">beFriendedBy</span><span class="hljs-params">(std::weak_ptr&lt;Person&gt; somePerson)</span> </span>&#123; weakFriends.<span class="hljs-built_in">push_back</span>(somePerson); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::__weak_ptr&lt;Person&gt;&gt; weakFriends; <br>    std::vector&lt;std::shared_ptr&lt;Person&gt;&gt; friends;<br>&#125;;<br></code></pre></td></tr></table></figure>在这个示例中，通过makeFriend函数，Person可以与新朋友建立朋友关系，新朋友保存为shared_ptr类型。相反，通过beFriendedBy函数，Person被其他人添加为朋友，记录为weak_ptr类型。这就打破了可能存在的循环参照，避免了内存泄露。</p><p>很多时候,循环引用难以发现,最好的办法是使用更好的类设计以避免<code>weak_ptr</code>的使用.例如,上面的Person 类的可读性简直是灾难的.</p><p>更好的类设计是把"朋友关系"单独作为一个类. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Friendship</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Friendship</span>(std::shared_ptr&lt;Person&gt; p1, std::shared_ptr&lt;Person&gt; p2) <br>        : <span class="hljs-built_in">person1</span>(p1), <span class="hljs-built_in">person2</span>(p2) &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;Person&gt; person1;<br>    std::shared_ptr&lt;Person&gt; person2;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeFriend</span><span class="hljs-params">(std::shared_ptr&lt;Person&gt; newFriend)</span> </span>&#123; <br>        friendships.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_shared</span>&lt;Friendship&gt;(<span class="hljs-built_in">shared_from_this</span>(), newFriend)); <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::shared_ptr&lt;Friendship&gt;&gt; friendships;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h3id="内存泄漏是什么有哪几种如何解决">5.内存泄漏是什么,有哪几种,如何解决?</h3><ol type="1"><li><p>内存泄漏是指程序中动态分配的堆内存,由于某些原因未释放,导致系统可用内存持续下降,从而影响系统性能甚至导致程序崩溃的事件.</p></li><li><p>内存泄漏的类型</p><ol type="1"><li>无用对象:忘记回收不在使用的内存</li><li>重复分配:在释放前,同一块内存被分配多次</li></ol></li><li><p>避免或解决内存泄漏的方法</p><ol type="1"><li>正确使用智能指针代替<code>new/delete</code>模式.如果一定要用<code>new/delete</code>请注意<code>new[]</code>应与<code>delete []</code>配对.</li><li>注意异常安全.如果一个函数在分配内存后抛出一个异常,则必须在适当的地方释放内存</li><li>内存池(对象池).在有大量小而短暂存在的对象的场合,使用对象池可以避免频繁申请和释放内存,同时也能降低内存泄漏的可能性.</li><li>使用内存检测工具如<code>valgrind</code>等帮助开发者定位内存泄漏.</li></ol></li></ol><h3 id="newdelete-与-mallocfree-的区别">6.new/delete 与 malloc/free的区别</h3><ol type="1"><li><p>new/delete为C++标准库提供的关键字,由<memory>头文件提供.malloc/free为C语言库函数.</p></li><li><p>malloc/free只负责内存的分配和释放,不会调用构造函数和析构函数.new/delete则可以</p></li><li><p>new支持根据类型分配内存,编译器可以根据类型计算所需的内存大小,而malloc则需要手动计算并指定所需的内存大小</p></li><li><p>new如果无法分配内存,会抛出异常,而malloc则只会返回NULL</p></li><li><p>new直接返回所需类型的指针,不需要类型转换.而malloc返回的是<code>void*</code>类型,需要进行类型转换.</p></li></ol><h3 id="什么是运行时多态">7. 什么是运行时多态？</h3><p>多态是面向对象编程中的一种特性，它允许我们使用一个接口来实现不同的功能。</p><p>多态分为静态多态和动态多态，也称为被编译时多态和运行时多态。静态多态是在编译时就已确定的多态性，主要包括函数重载，运算符重载和模板。</p><p>动态多态通过虚函数实现，主要在有继承关系的父类和子类中使用。当我们通过一个父类指针或引用调用一个虚函数时，实际上调用的函数是由指针或引用所指向的对象的类型决定的。</p><p>虚函数的工作机制：</p><p>每个有虚函数的类都有一个虚函数表，这个表是一个存储函数指针的数组。当一个类的函数被声明为虚函数时，编译器会在虚函数表中为这个函数分配一个入口。</p><p>每个多态类的对象都有一个指向虚函数表的指针，当我们通过基类指针或引用调用虚函数时，将通过这个虚表指针找到对应需要执行的函数。由于子类中声明的同名函数会覆盖从父类继承过来的虚函数表中的同名函数入口，所以，当我们通过基类指针或引用调用虚函数时，如果指针指向的是子类对象，则调用的就是子类的虚函数版本。</p><h3 id="红黑树有些什么性质">8. 红黑树有些什么性质。</h3><p>最基本的用于存储有序键值对的树形结构为二叉查找树，它的特点是每个节点的键大于所有左孩子的键，而小于所有右孩子的键。这种数据结构的查找、插入和删除的最优时间复杂度都是<spanclass="math inline">\(O(\logN)\)</span>，但当输入数据已排序是，所有操作的时间复杂度将退化为<spanclass="math inline">\(O(N)\)</span>。</p><p>为了解决二叉查找树在输入数据有序时性能退化的问题，提出二叉平衡树（AVL树），AVL要求每个节点的左右子树的高度差最多为1。但为了维护这种平衡性需要付出太多代价，尤其是在插入和删除时可能需要进行多次的树旋转操作。</p><p>红黑树则对AVL树的约束进行放松，它不要求严格的左右平衡，其通过维护5个性质保证红黑树“近似”平衡。其平衡主要体现在黑色平衡性，即任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。黑色平衡性使得红黑树的查找最坏时间复杂度仍然为<spanclass="math inline">\(O(\log N)\)</span></p><p>红黑树的5条性质啊： * 节点是红色或黑色 * 根节点必为黑色 *所有叶子节点是黑色 * 如果一个节点是红色的，那么它的子节点必须是黑色的 *从任意一个节点到其每个叶子节点的所有路径都包含相同数量的黑色节点</p><h3 id="请详细讲讲this指针">9. 请详细讲讲this指针</h3><p>在C++中，<code>this</code>是一个特殊的隐含指针，他被每个非静态成员函数隐含的拥有。当一个成员函数被调用时，系统自动将用于调用成员函数的对象的地址赋给<code>this</code>指针。所以，<code>this</code>指针指向调用该成员函数的那个对象。</p><p>注意： 1.<code>this</code>指针只是编译器的概念，在运行时并没有一个具体的地址能够代表<code>this</code>指针，并没有在物理内存中具体的存储位置</p><ol start="2" type="1"><li><p>静态成员函数不包含<code>this</code>指针，因为静态成员函数属于类本身，而不属于类的对象，它并不访问任何类的非静态成员和非静态方法。</p></li><li><p>不能用<code>this</code>指针调用静态成员变量，在成员函数（不管静态还是非静态）中使用静态成员变量直接用类名来访问<code>Example::static_var</code>。当然也可以用对象访问静态成员变量，但用类名访问可读性更好。</p></li><li><p>总而言之<code>this</code>指针用于在非静态成员函数中，用来访问非静态变量。</p></li></ol><h3 id="堆和栈的区别">10. 堆和栈的区别</h3><ol type="1"><li><p>堆和栈在操作系统中表示两种内存分配方式</p></li><li><p>栈是自动分配和释放内存的，由系统自动管理。堆的内存在需要主动申请和释放。</p></li><li><p>栈主要用于存储局部变量和函数调用的流程。堆的内存则更加自由，可以在运行时动态分配内存</p></li><li><p>栈是先进后出的数据结构，访问效率非常高，而堆则需要一定的开销来维护内存和寻找空闲内存块，访问效率相对较低。</p></li></ol><h3 id="mallocsbrkmmap">11. malloc(),sbrk(),mmap()</h3><p>sbrk():一个系统调用，用来改变数据段的大小，通常用于实现动态内存分配函数如malloc()。当malloc()无法在空闲链表中找到足够大小的内存块时，它就调用<code>sbrk()</code>来获取更多的内存。</p><p>mmap():一个系统调用，用来将一个文件或其他对象映射进内存中，也可以用来匿名内存映射。</p><p>malloc():一个标准C库函数。C库会维护一个空闲链表，调用malloc()可以从空闲链表中找出合适的内存并将其起始地址返回。</p><p>除了malloc(),还有calloc(),realloc(),free()等标准C库函数会访问和维护空闲链表。</p><h3 id="深拷贝和浅拷贝">12. 深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝的概念主要发生在对象发生复制行为时。</p><ol type="1"><li><p>浅拷贝是指在复制对象时，只会直接复制其成员变量本身，如果该成员是一个指针或引用，则会导致两个对象的指针或引用实际上指向了同一个地址，而没有把该地址处的值复制到新的内存给副本对象。</p></li><li><p>深拷贝则是复制对象本身，而且也会复制指针指向的地址数据。使副本对象与原对象的内存空间独立，两者状态不会受对方影响。</p></li><li><p>当成员变量包含指针或引用或其他类对象时，最好自己实现拷贝构造函数和赋值操作符重载。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序分析工具valgrind的使用</title>
    <link href="/2023/04/06/other/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind/"/>
    <url>/2023/04/06/other/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考《后台开发：核心技术与应用实践》第四章</p><h1 id="valgrind">valgrind</h1><p>一个C/C++程序分析器，其包括Memcheck,Callgrind,Cachegrind,Helgrind,Massif等工具</p><ul><li>Memcheck 内存检查器，能够发现绝大多数内存错误使用情况。</li><li>Callgrind 收集程序运行时的一些数据，建立函数调用关系图</li><li>Cachegrind 检查程序中缓存使用出现的问题</li><li>Helgrind 检查多线程程序中出现的竞争问题</li></ul><p>本文主要介绍使用valgrind进行内存检查。</p><h3 id="安装">安装</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install valgrind<br></code></pre></td></tr></table></figure><h3 id="使用">使用</h3><p>默认使用memcheck工具。如果要使用其它工具，用<code>--tool=tool name</code>指定.如<code>--tool=helgrind</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind ./main<br></code></pre></td></tr></table></figure><h3 id="示例">示例</h3><ol type="1"><li>使用未初始化的内存</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">/*<br> *使用未初始化的内存<br> */<br><span class="hljs-comment">#include &lt;iostream&gt;</span><br><br><span class="hljs-built_in">int</span> main()&#123;<br>        <span class="hljs-built_in">int</span> a[<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">int</span> i,s=<span class="hljs-number">0</span>;<br>        a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=a[<span class="hljs-number">3</span>]=a[<span class="hljs-number">4</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                s=s+a[i];<br>                <span class="hljs-keyword">if</span>(s==<span class="hljs-number">33</span>)&#123;<br>                        std::cout&lt;&lt;<span class="hljs-string">&quot;sum is 33&quot;</span>&lt;&lt;std::endl;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                        std::cout&lt;&lt;<span class="hljs-string">&quot;sum is not 33&quot;</span>&lt;&lt;std::endl;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>/* 运行结果<br>lumos@ubu:valgrind$ g++ test2.cpp -g -o test2<br>lumos@ubu:valgrind$ ./test2<br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><span class="hljs-built_in">sum</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">33</span><br><br>*/<br></code></pre></td></tr></table></figure><p>使用valgrind进行检查：</p><p><code>valgrid ./test2</code></p><figure><imgsrc="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/image-20230406162751586.png"alt="image-20230406162751586" /><figcaption aria-hidden="true">image-20230406162751586</figcaption></figure><ol start="2" type="1"><li>内存读写越界</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内存读写越界</span><br><span class="hljs-comment"> * pt只有四个元素，但后面的for循环使p指向了pt数组外的地址</span><br><span class="hljs-comment"> * 可能导致程序出现不可预期的错误</span><br><span class="hljs-comment"> * 这种错误很难用肉眼发现，但valgrind很容易的发现了问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> *pt=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(len*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-type">int</span> *p=pt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                p++;<br>        &#125;<br>        *p=<span class="hljs-number">5</span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;the value of p is &quot;</span>&lt;&lt;*p&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/image-20230406163722777.png"alt="image-20230406163722777" /><figcaption aria-hidden="true">image-20230406163722777</figcaption></figure><ol start="3" type="1"><li>动态内存管理错误</li></ol><p>常见的内存管理错误：</p><ul><li>申请与释放不一致。C使用malloc/free来申请和释放内存，C++使用new/delete。不可将两者混用。</li><li>申请和释放不一致。申请多少就释放多少，已经释放过的内存不能再次释放，没有释放的内存造成内存泄漏</li><li>释放后仍然读写。如果内存被释放后再访问，可能覆盖其它部分的信息，这是严重的错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *动态内存管理错误</span><br><span class="hljs-comment"> * 下面的代码包含了多种动态内存错误</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">char</span> *p=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">char</span> *pt=p;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>                p[i]=<span class="hljs-string">&#x27;z&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> p;<br>        pt[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;x&#x27;</span>;<br>        <span class="hljs-built_in">free</span>(pt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/image-20230406165225358.png" /></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>valgrind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列4-一些关键字</title>
    <link href="/2023/04/01/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%974-%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/04/01/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%974-%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><table><thead><tr><th>关键字</th><th>mutable</th><th>volatile</th></tr></thead><tbody><tr><td></td><td>1.最常见的用法：声明类成员变量是mutable的，</td><td></td></tr><tr><td>用法</td><td>意味着类中的const方法可以修改这个成员</td><td>用来修饰变量，告诉编译器不要对该变量做优化，总是从内存中读取该变量真正的值。</td></tr><tr><td></td><td>2.用于lambda表达式中，可以直接修改以值传递的变量</td><td>该关键字无法完成线程同步。</td></tr></tbody></table><table><thead><tr><th>关键字</th><th>register</th><th>explicit</th></tr></thead><tbody><tr><td>用法</td><td>C语言中，该关键字用来修饰局部变量，建议编译器将该值存入寄存器，</td><td>用于修饰类的构造函数，表示禁用隐式转换构造。</td></tr><tr><td></td><td>以获得更好的性能。但现代编译器大多会自行决定将哪些变量存入寄存器，故C++中的register其实没什么用</td><td>explicit A(int a)</td></tr><tr><td></td><td>register int a=2;</td><td></td></tr></tbody></table><table><thead><tr><th>关键字</th><th>default</th><th>delete</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>用法</td><td>让编译器自动生成默认构造函数，减少工作量</td><td>禁用类成员函数，一般用来在需要的时候禁用拷贝构造、移动构造、拷贝赋值，移动赋值。</td></tr><tr><td></td><td>class A{A()=default;}</td><td>class A{ A(const A&amp;)=delete;}</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>关键字</th><th>override</th><th>final</th></tr></thead><tbody><tr><td></td><td>放在函数声明后，用来显式的指明该函数时对基类中虚函数的重写。</td><td>放在类名后,表示该类禁止任何其他类继承它。</td></tr><tr><td>用法</td><td>void func() override { }</td><td>放在函数声明后，表示该函数禁止被重写。</td></tr><tr><td></td><td></td><td>class A final { }</td></tr><tr><td></td><td></td><td>void func() final { }</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//mutable 使用示例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::string m_name;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_DebugCount &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">//如果没有mutable,这个变量不能修改，因为该函数是const的</span><br>        m_DebugCount++;<br>        <span class="hljs-keyword">return</span> m_name;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Entity e &#123;<span class="hljs-string">&quot;lxp&quot;</span>&#125;;<br>    e.<span class="hljs-built_in">GetName</span>();<br>    <br>    <span class="hljs-type">int</span> x=<span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">auto</span> f1=[=]() <span class="hljs-keyword">mutable</span><br>    &#123;<br>        x++;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;x++: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-comment">//如果不用mutable，x按值传递，则不能直接作为左值，需要用临时变量y接收</span><br>    <span class="hljs-keyword">auto</span> f2=[=]() <br>    &#123;<br>        <span class="hljs-type">int</span> y=x;<br>        y++;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;x++: &quot;</span>&lt;&lt;y&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-comment">//f1和f2都不会改变x.因为是按值传递的</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;x is 8&quot;</span>&lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列3-强制类型转换</title>
    <link href="/2023/03/31/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%973-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/03/31/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%973-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>C++11提供了四类强制类型转换<code>static_cast,const_cast,dynamic_cast,reinterpret_cast</code>。如需要类型转换时，推荐使用这4中类型转换。</p><h2 id="总结使用原则">总结使用原则</h2><p>总结使用原则，具体介绍见下文。</p><ol type="1"><li>基本内置类型转换用<code>static_cast</code></li><li><code>void*</code>与任意类型指针的转换用<code>static_cast</code></li><li>存在继承，但不存在多态的类、类指针、类引用的上行转换，即子-&gt;父的转换用<code>static_cast</code></li><li>存在多态的类指针、类引用，不管上下行都用<code>dynamic_cast</code>。转换后检查结果是否为空</li><li>常量与非常量之间的转换。只用于将常量转换为非常量作为函数参数的情况</li><li>尽量不使用<code>reinterpret_cast</code></li><li>对于没有多态的类，也可以用<code>static_cast</code>来进行下行转换，但不安全，尽量不要使用。</li></ol><h2 id="static_cast">static_cast</h2><p>静态类型转换</p><p>支持的操作</p><ol type="1"><li>基本内置类型转换</li><li>任意类型指针转换都可以用<code>void*</code> 作为媒介</li><li>存在继承的类且没有多态的类之间的类型转换：上行（子-&gt;父）√下行（父-&gt;子)×</li><li>存在多态（自然存在继承）的类之间的类型转换：上行（子-&gt;父）可以，但失去多态性；下行（父-&gt;子）不可以</li><li>存在继承但没有多态的类指针/引用之间转换：随便转，但下行不安全</li><li>存在多态的类指针/引用之间的转换：随便转但某些下行不安全</li></ol><p>建议的操作：</p><ol type="1"><li>各种内置类型转换（各种C中的隐式转换都建议使用`<code>static_cast</code>代替</li><li>非空指针与<code>void *</code>之间的转换用<code>static_cast</code></li><li>不存在多态的类或类的指针或类的引用的上行转换用<code>static_cast</code></li></ol><h2 id="dynamic_cast">dynamic_cast</h2><p>将基类的指针/引用安全的转换为其派生类的指针或引用。只能在存在多态时使用。</p><ol type="1"><li>只有在派生类之间转换时才使用<code>dynamic_cast</code></li><li>基类必须有虚函数，因为<code>dynamic_cast</code>是运行时类型检查，需要运行时类型信息，而这个信息存在虚函数表中，虚函数表第一个函数指针的前面有一个<code>type_info</code>。</li></ol><h2 id="const_cast">const_cast</h2><p>常量转换。将常量指针或引用转换为非常量指针或引用。也可以将非常量转换为常量。</p><p>转换得到的非常量不是真正的非常量，依然不可修改（如果修改了，尽管编译不报错，运行时可能会段错误）。</p><p>非常量转换得到的常量也不是真正的常量。</p><p>唯一用途：函数重载（避免代码重复）。允许在某些时候将一个常量转换为非常量，作为函数参数传入。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;shorterstring(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)&#123;<br><span class="hljs-keyword">return</span> s1.size（）&lt;=s2.size（）?s1:s2;<br>&#125;<br><br><span class="hljs-built_in">string</span> &amp;shorterstring(<span class="hljs-built_in">string</span> &amp;s1,<span class="hljs-built_in">string</span> &amp;s2)&#123;<br><span class="hljs-built_in">auto</span> &amp;r=shorterstring(const_cast&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;&gt;(s1),<br>const_cast&lt;<span class="hljs-keyword">const</span> std:<span class="hljs-built_in">string</span> &amp;&gt;(s2));<br><span class="hljs-keyword">return</span> const_cast&lt;<span class="hljs-built_in">string</span> &amp;&gt;(r); <br>&#125;<br><br><span class="hljs-built_in">int</span> main()&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> s1,s2;<br><span class="hljs-built_in">string</span> shorterStr1=shorterString(s1,s2);<br><span class="hljs-built_in">string</span> s3,s4;<br><span class="hljs-built_in">string</span> shorterStr2=shorterString(s3,s4);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reinterpret_cast">reinterpret_cast</h2><p>为位运算的位模式提供低层次上的重新解释。</p><p>非常危险的操作，能不用就不用。</p><ol type="1"><li><code>reinterpret_cast&lt;type&gt;(expression)</code><code>type</code>与<code>expression</code>中至少有一个是指针/引用。</li><li>指针类型之间的转换可以直接使用<code>reinterpret_cast</code>，无需媒介。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux三剑客grep,sed,awk</title>
    <link href="/2023/03/30/Linux/Linux%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <url>/2023/03/30/Linux/Linux%E4%B8%89%E5%89%91%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="正则表达式">正则表达式</h2><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符<code>[ ] ( ) &#123; &#125; . * + ? ^ $ \\ &amp;#124;</code></td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><p>简写字符集</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td></td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td></td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td> 匹配数字： <code>[0-9]</code></td><td></td></tr><tr><td></td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td></td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td></td><td>匹配所有非空格字符： <code>[^\\s]</code></td></tr><tr><td> 匹配一个换页符</td><td></td></tr><tr><td></td><td>匹配一个换行符</td></tr><tr><td> 匹配一个回车符</td><td></td></tr><tr><td> 匹配一个制表符</td><td></td></tr><tr><td> 匹配一个垂直制表符</td><td></td></tr></tbody></table><h2 id="grep">grep</h2><ul><li><p>作用：筛选数据</p></li><li><p>格式： <code>grep [选项] [过滤规则] [路径]</code> 或<code>输出 | grep [选项] [过滤规则]</code></p></li><li><p>选项 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">-n : 显示行号<br>-o : 只显示匹配到的内容<br>-c : 显示总共匹配到多少行<br>-E : 使用正则表达式<br>-v : 反向查找，查找不存在指定字符的行<br>-R : 递归查找<br>-A n : 显示匹配到的行的后n行<br>-B n ：显示匹配到的行的前n行<br>-C n : 显示匹配到的行的前后各n行。<br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[system]<br>system.cpu<br>system.cache<br>[system.cpu]<br>system.cpu.type<br>system.cpu.freq<br>[system.cache]<br>system.cache.type<br>system.cache.clock<br>[system.cache.clock]<br>syystem.cache.clock.mic<br></code></pre></td></tr></table></figure></p></li><li><p>将上述<code>sys.ini</code>只显示[*]或[<em>.</em>]的行及其下面两行的指令</p></li></ul><p><code>cat sys.ini | grep -A 2 -E "^\[\w*\]$|^\[\w*\.\w*\]$"</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[system]<br>system.cpu<br>system.cache<br>[system.cpu]<br>system.cpu.type<br>system.cpu.freq<br>[system.cache]<br>system.cache.type<br>system.cache.clock<br></code></pre></td></tr></table></figure></p><ul><li><p>不含cpu的行 <code>cat sys.ini | grep -v "cpu"</code> ## sed流式编辑器</p></li><li><p>作用：主要用来修改文件</p></li><li><p>格式：<code>sed [选项 “[定位][指令]" [路径]</code></p><ul><li>不指定定位，则默认处理全文</li></ul></li><li><p>参数 <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-e : 允许多项编辑</span><br><span class="hljs-deletion">-n ：取消默认输出</span><br><span class="hljs-deletion">-i : 就地编辑文本</span><br><span class="hljs-deletion">-r : 支持扩展正则表达式。正则表达式放在//之间</span><br><span class="hljs-deletion">-f : 指定定位规则的文件</span><br></code></pre></td></tr></table></figure></p></li><li><p>指令 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">p:</span> 打印<br><span class="hljs-symbol">d:</span> 删除<br><span class="hljs-symbol">a:</span> 再当前行后添加一行或多行内容<br><span class="hljs-symbol">i:</span> 在当前行之前插入文本<br><span class="hljs-symbol">w:</span> 匹配到的行写入一个新的文件<br><span class="hljs-symbol">s:</span> 用一个字符替换成另一个字符<br><span class="hljs-symbol">c:</span> 用新文件替换当前行中的内容<br></code></pre></td></tr></table></figure> 掌握几个基础的就行。其它用到再查 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#会把第二行输出，然后把整个文本输出</span><br>sed <span class="hljs-string">&quot;2p&quot;</span> sys.ini<br><span class="hljs-comment">#只会输出第2行</span><br>sed -n <span class="hljs-string">&quot;2p&quot;</span> sys.ini<br><span class="hljs-comment">#只输出第3，7行</span><br>sed -n -e <span class="hljs-string">&quot;3p&quot;</span> -e <span class="hljs-string">&quot;7p&quot;</span> sys.ini<br><br><span class="hljs-comment">#删除第2行。-i就地编辑。如果没有-i只是暂时编辑，文件其实没变</span><br>sed -i <span class="hljs-string">&quot;2d&quot;</span> sys.ini<br><span class="hljs-comment">#第二行之前加入文本</span><br>sed <span class="hljs-string">&quot;2i 加到第二行之前&quot;</span> sys.ini<br>sed -i <span class="hljs-string">&quot;2i 加到第二行之前&quot;</span> sys.ini<br><span class="hljs-comment">#第二行之后加入文本</span><br>sed <span class="hljs-string">&quot;2a 加到第二行之后&quot;</span> sys.ini<br>sed -i <span class="hljs-string">&quot;2a 加到第二行之后&quot;</span> sys.ini<br></code></pre></td></tr></table></figure>## awk 文本处理工具</p></li><li><p>作用：处理文本，将文本按指定规则进行处理</p></li><li><p>格式 <code>awk [选项] '匹配规则和处理规则' [路径]</code></p></li><li><p>选项</p><ul><li><code>-F</code>设置输入字段分隔符，也可以用处理规则中的<code>BEGIN&#123;&#125;</code></li></ul></li><li><p>处理规则：</p><ul><li><code>BEGIN&#123;&#125;</code>处理文本之前设置变量</li><li><code>//</code>使用的匹配规则，正则表达式或字符串</li><li><code>&#123; &#125;</code>一条命令，可以是循环或判断</li><li><code>END&#123;&#125;</code>处理文本之后执行END中的指令</li></ul></li><li><p>awk中的变量 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$0</span>: 当前行<br>NR: 行号<br>NF: 总共保存的列数<br>FS: 输入字段分隔符，默认空格<br>OFS: 输出字段分隔符<br>RS: 设置的正则<br>RT: 正则匹配到的内容<br></code></pre></td></tr></table></figure></p></li></ul><p>awk的处理逻辑其实很简单，首先执行BEGIN{}中的内容，只要是设置输入分隔符FS和输出分隔符OFS，执行//中的匹配规则，找出符合匹配的行，这些行逐行的执行后面的处理指令。最后执行END{}中的指令，主要是输出一些自定义的变量自定义值等。</p><p>例子： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#以:为分割符，输出第3列和第5列 ,且中间用-连接</span><br>awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;-&quot;&#125;&#123;print $3,$5&#125;&#x27;</span> a.txt<br><span class="hljs-comment">#输出第4行到的8行</span><br>awk <span class="hljs-string">&#x27;&#123;if(NR&gt;=4&amp;&amp;NR&lt;=8)&#123;print $0&#125;&#125;&#x27;</span> a.txt<br><span class="hljs-comment">#格式化输出第1，2列和最后一列</span><br><span class="hljs-comment"># %s表示字符类型，%d表示数值类型，占15个位置，-表示左对齐，默认为右对齐。</span><br><span class="hljs-comment">#print 默认加换行，printf 没有自动换行，要自己加\n</span><br>awk -F: <span class="hljs-string">&#x27;&#123;printf &quot;|%-15s| %-10s| %-15s|\n&quot;, $1,$2,$NF&#125;&#x27;</span> /etc/passwd<br><br><span class="hljs-comment">#输出奇数行及其行号,分隔符为&quot;,&quot;</span><br>awk -F, <span class="hljs-string">&#x27;&#123;if(NR@==0)&#123;print NR,$0&#125;&#125;&#x27;</span> a.txt<br></code></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span>循环：<span class="hljs-keyword">for</span>(i=0;i&lt;5;i++)  <span class="hljs-keyword">for</span>(i=1;i&lt;NF;i++)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim编辑器</title>
    <link href="/2023/03/30/Linux/VIM%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/30/Linux/VIM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="常用">常用</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">h,<span class="hljs-keyword">j</span>,<span class="hljs-keyword">k</span>,<span class="hljs-keyword">l</span> 基础移动<br><span class="hljs-keyword">x</span> 删除<br><span class="hljs-keyword">c</span> 删除并进入插入模式<br><span class="hljs-keyword">cw</span> 删除一个词，进入插入模式<br>ci) 删除最近的()里面的词。<br><span class="hljs-symbol">&lt;leader&gt;</span><span class="hljs-symbol">&lt;leader&gt;</span> <span class="hljs-keyword">w</span> : easy_motion插件的一个更方便的跳转功能。如果使用vscode-<span class="hljs-keyword">vim</span>插件，可以直接在设置里面启动easy_motion就行。<span class="hljs-symbol">&lt;leader&gt;</span>键也要在vscode-<span class="hljs-keyword">vim</span>的设置里面指定。<br></code></pre></td></tr></table></figure><p>上面有几个命令需要用到基础的插件，如果在vscode中使用vim可以很方便的开启这些基础插件</p><p><code>Ctrl+Shift+P</code>输入设置，打开vscode的设置。点击右上角打开<code>setting.json</code></p><figure><imgsrc="https://raw.githubusercontent.com/luoxpan/pictureBed/main/202404051111630.png?token=A6VI6WKQRZP6HD4GLD2GFJLGB5WAY"alt="屏幕截图 2024-04-05 110813" /><figcaption aria-hidden="true">屏幕截图 2024-04-05 110813</figcaption></figure><p>将下面的设置加入到<code>setting.json</code>中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// [[Vim]]</span><br>  <span class="hljs-attr">&quot;vim.easymotion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.incsearch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.useSystemClipboard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.useCtrlKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.hlsearch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;j&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;j&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;&lt;Esc&gt;&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.statusBarColors.replace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.statusBarColors.commandlineinprogress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.highlightedyank.enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.leader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot; &quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.handleKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;&lt;C-a&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;&lt;C-f&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;&lt;C-h&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;&lt;C-c&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;&lt;C-x&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;&lt;C-p&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;s&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;&lt;s&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vim.normalModeKeyBindingsNonRecursive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// g + d open definition in side view</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;d&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;editor.action.revealDefinitionAside&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// g + i open implementation in side view</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;i&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;workbench.action.splitEditor&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;editor.action.goToImplementation&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// g + t open type definition in side view</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;t&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;workbench.action.splitEditor&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;editor.action.goToTypeDefinition&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// rename symbol</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;r&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;n&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;editor.action.rename&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// format document</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;f&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;f&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;editor.action.formatDocument&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// open current tab in new side view</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;&lt;Tab&gt;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;n&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;&lt;C-w&gt;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;v&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// close current tab</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;c&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;&lt;C-w&gt;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;c&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// switch to the left tab</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;h&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;T&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// switch to the right tab</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;l&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;t&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// switch between editor groups/views </span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;workbench.action.navigateEditorGroups&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// start the zen mode</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;z&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;workbench.action.toggleZenMode&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br></code></pre></td></tr></table></figure><h2 id="正常模式">正常模式</h2><p>主要进行位置跳转 <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ada">h,j,k,l : ←，↑，↓，右<br>nh,nj,nk,nl <br>w,b,e ：w(word) b(backword) e(<span class="hljs-keyword">end</span>)<br>    w : 下个小词的开头 <span class="hljs-type">W</span> : 下个大词的开头<br>b : 上个小词的开头 <span class="hljs-type">B</span> : 上个大词的开头<br>e : 下个小词的结尾 <span class="hljs-type">E</span> : 下个段的结尾<br>f,t : <span class="hljs-type">f</span>(find) t(till,贴靠)<br>    fa : 本行中下个<span class="hljs-type">a</span>的位置    Fa ：本行中上个a的位置<br>    ta : 本行中下个<span class="hljs-type">a</span>的位置的前一个 Ta : 本行中上个<span class="hljs-type">a</span>的位置的前一个<br>^,$ :<br>^ 本行开头<br>$ 本行结尾<br>+,- :<br>+ 下行非空<br>    - 上行非空<br>    <br>%,*,#:<br>    % 匹配括号移动，需要先把光标移动到括号上<br>    *,# 匹配光标所在的单词，*是下一个,#是上一个<br>gg : 第一行第一个字符<br><span class="hljs-number">6</span>gg : 第6行的开头  等同于6<span class="hljs-type">G</span><br>G : 最后一行的第一个字符<br><span class="hljs-number">4</span>G ：第<span class="hljs-number">4</span>行的第一个字符 等同于 <span class="hljs-number">4</span>gg<br>Go : 最后一行插入<br>gg=G : 全文自动缩进<br>E : 5<span class="hljs-type">j</span><br>U : 5<span class="hljs-type">k</span><br>J : 合并，下一行与当前行合并<br>K : 光标所在词的帮助文档(<span class="hljs-type">man</span>文档)<br>u : 撤销<br>r : 替换一个字符<br>R ：连续替换字符，ESC退出<br>x : 删除当前字符 3<span class="hljs-type">x</span><br>X : 删除前一个字符 4<span class="hljs-type">X</span><br>yy ：复制<br>ye : 从当前位置拷贝到单词结束<br>nyy : 复制<span class="hljs-type">n</span>行 等同于yny<br>p : 粘贴<br>np : 粘贴<span class="hljs-type">n</span>次<br>dd : 剪切一行<br>ndd : 剪切<span class="hljs-type">n</span>行 等同于dnd<br>dt<span class="hljs-string">&quot; :从当前位置开始删除直到遇到&quot;</span><br>DD : 从光标位置开始剪切 <span class="hljs-type">nDD</span> DnD<br>cc : 删除一行并进入插入模式<br>CC ： 从光标位置开始删除，并进入插入模式<br>ctrl+o 上一次跳转的位置<br>ctrl+i 下一次跳转的位置<br>ma : 做一个名为<span class="hljs-type">a</span>的标记命令模式 :marks 查看所有标记<br>`a : 跳转到<span class="hljs-type">a</span>标记<br>`<span class="hljs-string">&quot; : 上次退出当前文件的位置</span><br><span class="hljs-string">`[ : 上次修改的开始位置</span><br><span class="hljs-string">`] : 上次修改的结束位置</span><br><span class="hljs-string">`. : 上次编辑的最后操作位置</span><br><span class="hljs-string">. 重复上一操作</span><br><span class="hljs-string">3. 重复上一操作3次</span><br></code></pre></td></tr></table></figure> 在当前行上移动光标 <imgsrc="https://raw.githubusercontent.com/XingpanLuo/PictureBed/main/DlMXjBAowJIYrVx.png"alt="1678953831946-1589002c-c1d6-40eb-8752-d2a8f19bca12.png" /></p><h2 id="命令模式">命令模式</h2><p>正常模式 =<code>:</code>=&gt;进入命令模式 常用命令 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">:w 保存 :q 退出 :wq 保存退出<br>:w! :q! :wq! 强制执行<br>:h i  获取i的帮助文档<br>:e other.txt  另外other.txt<br>:w other.txt 另存为，要求other.txt不存在<br>:w! other.txt  强制写入other.txt 替换原来的内容<br>:w &gt;&gt; other.txt 在other.txt的最后追加内容<br>:<span class="hljs-number">40</span> 直接跳到第<span class="hljs-number">40</span>行<br>:bn 下一个文件（如果打开了多个文件）<br>:sp 上下分屏<br>:vs 左右分屏<br>ctrl+w+ 箭头 切换窗口<br></code></pre></td></tr></table></figure>搜索与替换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/pattern  搜索pattern  先回车,n下一个,N上一个n,s取消高亮<br>?pattern 搜索pattern 和/方向相反，向上搜索<br>:s/aaa/bbb/g  本行所有aaa替换为bbb<br>:<span class="hljs-number">1</span>,<span class="hljs-number">5</span>s/aaa/bbb/g  第<span class="hljs-number">1</span>至<span class="hljs-number">5</span>行所有aaa替换为bbb<br>:.,$s/aaa/bbb/g  当前行到最后一行所有aaa替换为bbb<br>:%s/aaa/bbb/g   全文aaa替换为bbb<br></code></pre></td></tr></table></figure> ## 插入模式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i : 当前位置插入<br>I : 当前行开头插入<br>a : 光标的下一位置插入<br>A : 当前行的结尾插入<br>o : 下一行插入<br>O : 上一行插入<br>cw : 替换从光标所在位置后到一个单词结尾的字符 要修改一个单词时使用<br><br>ctrl+c 退出插入模式<br>ESC 退出插入模式<br>ctrl+o 进入命令-插入模式，只退出插入模式一下，执行一个命令后进入插入模式<br></code></pre></td></tr></table></figure> ## 选择模式<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs r">v 进入选择模式<br>ctrl<span class="hljs-operator">+</span>v 进入块选择模式<br>ctrl<span class="hljs-operator">+</span>d 选择该光标左下角所有内容<br>h<span class="hljs-punctuation">,</span>j<span class="hljs-punctuation">,</span>k<span class="hljs-punctuation">,</span>l 进行选择<br>y 复制<br>p 粘贴<br>A 在开头写入<span class="hljs-comment"># ESC退出，所有选中行全都加上了#注释</span><br><span class="hljs-built_in">c</span> 选中后<span class="hljs-built_in">c</span>删除选中内容并进入插入模式，重新输入后ESC退出，所有选中内容都被修改了<br>选中多行的一个字符，cw<span class="hljs-punctuation">,</span>删除一个单词，并进入插入模式<br></code></pre></td></tr></table></figure> ## ~/.vimrc vim配置文档 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs routeros">syntax on <span class="hljs-string">&quot;语法高亮</span><br><span class="hljs-string">set nocompatible &quot;</span>不与vi兼容<br><span class="hljs-built_in">set</span> number <span class="hljs-string">&quot;显示行号 </span><br><span class="hljs-string">&quot;</span><span class="hljs-built_in">set</span> nu “nu 为 number的缩写<br><br><span class="hljs-built_in">set</span> relativenumber <span class="hljs-string">&quot;显示相对行号</span><br><span class="hljs-string"></span><br><span class="hljs-string">set cursorline &quot;</span>突出显示当前行  <span class="hljs-built_in">set</span> cul<br><span class="hljs-string">&quot;set cursorcolumn &quot;</span>突出显示当前列 <span class="hljs-built_in">set</span> cuc<br><br><span class="hljs-built_in">set</span> showmatch <span class="hljs-string">&quot;显示括号匹配</span><br><span class="hljs-string">set showmode &quot;</span>在底部显示，当前处于命令模式还是插入模式<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">bg</span>=dark <span class="hljs-string">&quot;设置黑色背景</span><br><span class="hljs-string">:colorscheme desert</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>设置缩进 1、设置TAB长度为4空格 2、设置自动缩进长度为4空格 3、继承前一行的缩进方式，适用于多行注释<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">tabstop</span>=4<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">shiftwidth</span>=4<br><br><span class="hljs-built_in">set</span> expandtab <span class="hljs-string">&quot;按下tab自动转换为空格</span><br><span class="hljs-string"></span><br><span class="hljs-string">autocmd BufWritePost <span class="hljs-variable">$MYVIMRC</span> source <span class="hljs-variable">$MYVIMRC</span> &quot;</span>实现.vimrc保存时自动重启加载<br><span class="hljs-built_in">set</span> wrap <span class="hljs-string">&quot;设置自动换行 set nowarap 取消自动换行 </span><br><span class="hljs-string">set showcmd &quot;</span>输入的命令显示出来，看的清楚些<br><span class="hljs-string">&quot;在命令模式下，按下tab可以自动补全命令</span><br><span class="hljs-string">set wildmenu</span><br><span class="hljs-string"></span><br><span class="hljs-string">set wildmode=longest,list,full</span><br><span class="hljs-string"></span><br><span class="hljs-string">set backspace=indent,eol,start &quot;</span>inset模式下，使退格键可以删掉任何东西<br><span class="hljs-built_in">set</span> hlsearch <span class="hljs-string">&quot;搜索高亮  </span><br><span class="hljs-string">exec &quot;</span>nohlsearch<span class="hljs-string">&quot;</span><br><span class="hljs-string">set incsearch &quot;</span>高亮显示搜索的匹配过程，每输入一个字符，就自动跳转到第一个匹配结果<br><br>hi Search <span class="hljs-attribute">term</span>=standout <span class="hljs-attribute">cterm</span>=bold <span class="hljs-attribute">ctermfg</span>=7 <span class="hljs-attribute">ctermbg</span>=1<br><span class="hljs-built_in">set</span> ignorecase <span class="hljs-string">&quot;</span><br><span class="hljs-string">set smartcase  &quot;</span>  <br><span class="hljs-built_in">set</span> <span class="hljs-attribute">mouse</span>=a    <span class="hljs-string">&quot;</span><br><span class="hljs-string">set autoindent &quot;</span>自动缩进，按下回车后，下一行会自动根上一行的缩进保持一致 <br><br><span class="hljs-built_in">set</span> smartindent <span class="hljs-string">&quot;智能缩进</span><br><span class="hljs-string">set ruler &quot;</span>在状态栏显示光标当前位置，哪一行哪一列<br><span class="hljs-built_in">set</span> undofile<br>noremap E 5j <span class="hljs-string">&quot;向下移动5行</span><br><span class="hljs-string">noremap U 5k &quot;</span>向上移动5行<br>inoremap jk &lt;ESC&gt; <br><span class="hljs-string">&quot;按下s取消高亮结果显示,本来按下s删除当前字符并进入插入模式</span><br><span class="hljs-string"></span><br><span class="hljs-string">map s :noh&lt;CR&gt; </span><br><span class="hljs-string">map S :w&lt;CR&gt;</span><br><span class="hljs-string">map Q :q&lt;CR&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>map R :source <span class="hljs-variable">$MYVIMRC</span>&lt;CR&gt;<br>map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;<br>filetype indent on <span class="hljs-string">&quot;开启文件类型检查，并且载入与该类型对应的缩进规则。如何，如果编辑的是.py文件，Vim就是会找到Python的缩进规则</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列2-内存对齐、空类、多态</title>
    <link href="/2023/03/25/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%972-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E3%80%81%E7%A9%BA%E7%B1%BB%E3%80%81%E5%A4%9A%E6%80%81/"/>
    <url>/2023/03/25/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%972-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E3%80%81%E7%A9%BA%E7%B1%BB%E3%80%81%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="内存对齐">内存对齐</h2><h3 id="内存对齐的原因">内存对齐的原因</h3><ul><li>一部分原因是某些硬件平台对特定的数据只能从特定地址开始存取。</li><li>根本原因在于字节对齐可以提高CPU访问数据的效率。例如，一个int数据如果不按字节对齐，就会出现为了读取一个数据，需要CPU访问两次内存的情况，CPU访问内存所花费的时间是远远大于计算的，显然不按字节存取会造成CPU性能瓶颈</li></ul><h3 id="对齐原则">对齐原则</h3><h4 id="基本类型">基本类型</h4><p>基本类型要求起始地址是其长度的整数倍。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//占据内存[0,1]</span><br><span class="hljs-built_in">int</span> b;<span class="hljs-comment">//占据内存[4,5,6,7].地址2,3不可用,</span><br><span class="hljs-comment">//因为int要按4对齐,要求起始地址%4==0</span><br>&#125;;<br>sizeof(A)=<span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><h4 id="数组">数组</h4><p>第一个元素按照基本类型或结构体的对齐原则对齐后，后面的元素连续存放即可</p><h4 id="结构体">结构体</h4><p>不指定对齐方式的情况</p><ul><li>每个元素单独按照自身长度进行对齐</li><li>整体按照元素最大长度进行对齐</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-comment">//short: 2 int: 4 long: 8</span><br><span class="hljs-keyword">struct</span> A&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//[0,1]</span><br><span class="hljs-built_in">int</span> b;<span class="hljs-comment">//[4..7]</span><br><span class="hljs-built_in">short</span> c;<span class="hljs-comment">//[8,9]</span><br>&#125;;<span class="hljs-comment">//12,因为10不是4的倍数，故填充至12（这里的10来源：地址0到9有10位）</span><br><br><span class="hljs-keyword">struct</span> B&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//[0,1]</span><br><span class="hljs-built_in">short</span> b;<span class="hljs-comment">//[2,3]</span><br><span class="hljs-built_in">int</span> c;<span class="hljs-comment">//[4..7]</span><br>&#125;;<span class="hljs-comment">//8//8是4的倍数，不用填充</span><br><br><span class="hljs-keyword">struct</span> C&#123;<br><span class="hljs-built_in">int</span> a;<span class="hljs-comment">//[0..3]</span><br><span class="hljs-built_in">short</span> b;<span class="hljs-comment">//[4,5]</span><br><span class="hljs-built_in">short</span> c;<span class="hljs-comment">//[6,7]</span><br>&#125;;<span class="hljs-comment">//8//8是4的倍数，不用填充</span><br><br><span class="hljs-keyword">struct</span> D&#123;<br><span class="hljs-built_in">short</span> a;<span class="hljs-comment">//[0,1]</span><br><span class="hljs-built_in">long</span> b;<span class="hljs-comment">//[8..15]</span><br><span class="hljs-built_in">short</span> c;<span class="hljs-comment">//[16,17]</span><br><span class="hljs-built_in">int</span> d;<span class="hljs-comment">//[20..23]</span><br>&#125;;<span class="hljs-comment">//24//24是8的倍数，不用填充</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;short: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">short</span>)&lt;&lt;<span class="hljs-string">&quot; int: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>)<br>&lt;&lt;<span class="hljs-string">&quot; long: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;A: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(A)&lt;&lt;<span class="hljs-string">&quot; B: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(B)&lt;&lt;<span class="hljs-string">&quot; C: &quot;</span><br>&lt;&lt;<span class="hljs-keyword">sizeof</span>(C)&lt;&lt;<span class="hljs-string">&quot; D: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(D)&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303252043199.png"alt="image-20230325204358151" /><figcaption aria-hidden="true">image-20230325204358151</figcaption></figure><h4 id="联合体">联合体</h4><ul><li>联合体内存要求至少为最长元素的长度</li><li>同时，内存大小必须为所有成员的整数倍</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><br>union A&#123;<br><span class="hljs-built_in">char</span> a;<br><span class="hljs-built_in">int</span> b[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">long</span> c;<br>&#125;;<br><span class="hljs-comment">/*结果为16.首先A至少为12，因为3个int长度为12，其次长度必须为8的倍数，因为long的长度为8。故最终结果为16</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;short: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">short</span>)&lt;&lt;<span class="hljs-string">&quot; int: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>)<br>&lt;&lt;<span class="hljs-string">&quot; long: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;A: &quot;</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(A)&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303252044239.png"alt="image-20230325204433214" /><figcaption aria-hidden="true">image-20230325204433214</figcaption></figure><h4 id="指定对齐方式">指定对齐方式</h4><p>使用<code>#pragma pack(n)</code> 指定对齐方式。</p><p>当指定对齐方式时，上述的各种类型的对齐字节为自身对齐值与指定对齐值中的较小值。</p><p>对于结构体和联合体，整体的大小仍然是去正常分析的情况与指定的方式取较小值。</p><p>例子1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">short</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">short</span> c;<br>&#125;;<br><span class="hljs-comment">//如果没有指定以2对齐，sizeof(A)=12</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2)</span><br><span class="hljs-comment">//指定为2对齐，结果为2+4+2=8</span><br></code></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">short</span> b;<br><span class="hljs-type">long</span> c;<br><span class="hljs-type">char</span> d[<span class="hljs-number">2</span>];<br>&#125;;<br><span class="hljs-comment">//正常分析的结果为 4+2+(2)+8+2+(6)=24 .(2)为short b后填充的，(6)为整体填充的，为了结果对8整除</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-comment">//指定为4对齐，则结果为4+2+(2)+8+2+(2)=20. 因为min&#123;8,4&#125;=4,故整体只要为4的倍数就可以了</span><br><br></code></pre></td></tr></table></figure><h2 id="空类">空类</h2><p>空类的大小为1.</p><p>原因：以下三个原因其实是一个意思，只是表达方式不太同。</p><ul><li>为了确保两个不同对象的地址不同。</li><li>C++ 标准要求类型相同的两个对象地址必须不同。</li><li>发生这种情况的原因归结为正确实施标准，C++其中一条标准是“任何对象在内存中的地址都不应与任何其他变量相同”确保这一点的最简单方法是什么？确保所有类型都具有非零大小。为了实现这一点，编译器向没有数据成员和虚函数的结构和类添加一个虚拟字节，使它们的大小为1 而不是 0，然后保证它们具有唯一的内存地址</li></ul><h2 id="多态">多态</h2><p>多态，顾名思义就是同一种事物在不同情况下表现出不同的形态。</p><p>C++中的多态可以分为<strong>静态多态</strong>和<strong>动态多态</strong>两种</p><ul><li>静态多态：函数重载和泛型编程（模板编程）</li></ul><h3 id="动态多态">动态多态</h3><p>大部分情况下提到C++的多态指的是第二种动态多态。动态多态是通过在基类方法前加上<code>virtual</code>关键字，使得该函数成为虚函数，然后子类可以重写该方法。这样包含虚方法的类就具有了多态性：</p><ul><li>通过基类指针调用虚函数时，若指针指向的基类对象，则调用基类的方法，若指向的是子类指针，则调用相应的子类方法。</li><li>通过基类引用调用虚函数时，若引用的对象是基类对象，则调用基类方法，若引用对象是子类，则调用相应的子类方法。</li></ul><p>如果基类中有虚函数，那么应该将基类的虚构函数也定义为虚函数。</p><p>原因：如果不那么做，基类指针指向子类，然后<code>delete</code>该指针时，调用的是基类的析构函数，这会导致子类的析构函数没有被调用。</p><p>而如果把基类的析构函数定义为虚函数，则<code>delete</code>该指针会调用子类的析构函数，子类析构完成会自动调用基类的析构函数，这样才能保证子类和基类的资源都被释放。</p><h4 id="纯虚函数">纯虚函数</h4><p>再基类的纯虚函数声明的后面加上<code>=0</code>。该虚函数成为纯虚函数，该基类成为抽象类。</p><ul><li>纯虚函数在基类中声明但不定义，而要求所有的派生类一定要定义这个虚函数的实现。</li><li>具有纯虚函数的基类成为抽象类，抽象类不能实例化，但可以定义抽象类的指针或引用来对子类进行管理</li><li>如果子类中只声明而没有实现纯虚函数，那么这个子类还是一个抽象类，依然不能实例化</li></ul><h4 id="虚函数指针和虚函数表">虚函数指针和虚函数表</h4><p>C++通过虚函数指针和虚函数表来实现，</p><p>每一个有虚函数的类，或者有虚函数的类的子类，都有一个虚函数表，虚函数表中列出了该类的虚函数的实现地址。这个虚函数表在编译期就建立，存储在了数据区段的<code>.rodata</code>子段。</p><p>这些类的每一个对象都有一个指向虚函数表的指针。当通过基类指针调用虚函数时，会根据指针实际指向的对象中的虚表指针去找到对应的虚函数表，在表中找到函数实现。</p><p>一些<strong>tips</strong>:</p><ol type="1"><li><p>虚表和虚表指针建立时间：</p><ul><li><p>虚函数表在编译期建立，虚表指针一般作为类的第一个成员变量，虚表指针在基类构造函数之后，子类构造函数之前进行初始化。</p></li><li><p>构造函数的调用过程：进入构造函数体之前，如果存在虚函数，虚表指针被初始化。如果存在构造函数的初始化列表，则执行初始化列表。然后进入构造函数体执行构造。</p></li></ul></li><li><p>哪些函数不能声明为虚函数</p><ul><li><p>友元函数，它不是类成员函数</p></li><li><p>静态成员函数，它没有this指针，没有this指针就无法访问虚表指针，也就找不到虚函数的实现</p></li><li><p>构造函数、复制构造函数以及赋值操作符重载可以但不建议声明为虚函数</p></li></ul></li><li><p>派生类虚表如何建立</p><ul><li>先将基类的虚表复制一份</li><li>如果子类对基类中的虚函数进行了重写，则将子类的虚表相应位置替换为子类的函数实现地址</li><li>如果子类新增了自己的虚函数，则按照其声明次序，放在上述虚表的后面</li></ul></li></ol><p>从类中直接获取虚函数表的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vAfunc1</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;vAfunc1&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vAfunc2</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;vAfunc2&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Afunc</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;Afunc: &quot;</span>&lt;&lt;data1&lt;&lt;endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> data1;<br>&#125;;<br><br><span class="hljs-keyword">using</span> Func=<span class="hljs-built_in">void</span>();<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>A a;<br><span class="hljs-keyword">auto</span> t1=(<span class="hljs-type">int64_t</span> *)(&amp;a);<span class="hljs-comment">//对a的地址强制转换</span><br><span class="hljs-keyword">auto</span> t2=(<span class="hljs-type">int64_t</span> *)*t1;<span class="hljs-comment">//对a的第一个数据解引用，取得虚表</span><br><span class="hljs-keyword">auto</span> t3=(Func *)*t2;<span class="hljs-comment">//虚表的第一个元素。是a的第一个虚函数</span><br><span class="hljs-built_in">t3</span>();<br><span class="hljs-keyword">auto</span> t4=(Func *)*(t2+<span class="hljs-number">1</span>);<span class="hljs-comment">//虚表的第二个元素。</span><br><span class="hljs-built_in">t4</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">vAfunc1</span><br><span class="hljs-comment">vAfunc2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="rtti-运行时类型判别">RTTI 运行时类型判别</h2><p>当一个函数的传入参数是一个基类指针（引用）时，我们可能需要知道这个基类指针参数指向的到底指向的是哪一种子类。</p><p>这就需要用到虚表中第一个函数的前面存放的一个<code>type_info</code></p><p>可以直接从<code>type_info</code>中获取类的类型信息，但那样太麻烦，C++提供了可以直接使用的库函数<code>typeid()</code>可以返回指针和引用所指的实际类型。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">void</span> test(<span class="hljs-type">A</span> *a)&#123;<br><span class="hljs-keyword">if</span>(typeid(*a)==typeid(<span class="hljs-type">A</span>))&#123;<br><span class="hljs-type">A</span> *pa=reinterpret_cast&lt;<span class="hljs-type">A</span> *&gt;(a);<br>pa-&gt;func1();<br>&#125;<br><span class="hljs-keyword">if</span>(typeid(*a)==typeid(<span class="hljs-type">B</span>))&#123;<br><span class="hljs-type">B</span> *pb=reinterpret_cast&lt;<span class="hljs-type">B</span> *&gt;(a);<br>pb-&gt;func2();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dynamic_cast&lt;type *&gt;(e)</code>将基类的指针或引用安全的转成其子类的指针和引用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">B:<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">A</span>&#123;&#125;;<br>B b;<br><br>A *pa=dynamic_cast&lt;A *&gt; (&amp;b);<span class="hljs-comment">//返回正常的A*</span><br><span class="hljs-comment">//下面这行代码pa尽管是一个A*指针，但它指向的内存大小是能容纳B类的，故能正常转换</span><br>B *pb=dynamic_cast&lt;B *&gt; (pa);<span class="hljs-comment">//返回正常的B* </span><br><br>A a;<br><span class="hljs-comment">//A类的内存小于B类的内存，下面的操作会返回nullptr</span><br>B *ppb=dynamic_cast&lt;B *&gt;(&amp;a);<span class="hljs-comment">//返回nullptr</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP困惑系列1-存储持续性、作用域、链接性</title>
    <link href="/2023/03/25/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%971-%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%93%BE%E6%8E%A5%E6%80%A7/"/>
    <url>/2023/03/25/CPP/Cpp%E5%9B%B0%E6%83%91/CPP%E5%9B%B0%E6%83%91%E7%B3%BB%E5%88%971-%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%93%BE%E6%8E%A5%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="存储持续性">存储持续性</h2><p>即变量再内存中的存在时间。C++中有三类存储持续性，C++11新增了一种。</p><ul><li>自动存储持续性：<ul><li>存储在栈区。进入代码块前存储，离开代码块就自动销毁</li><li>包括函数内部定义的局部变量和<code>register</code>修饰的寄存器变量</li><li><code>register</code>起初表示期望编译器将该变量存入寄存器以提高性能，但不强制要求编译器这样做。因此现在的编译器都是自己决定什么时候将局部变量存入寄存器，目前绝大部分的编译器会忽略这个关键字。</li></ul></li><li>静态存储持续性<ul><li>存储在数据段和BSS段。程序开始前建立，程序结束才销毁<ul><li>数据段：已初始化的非0的全局变量和已初始化为非0的static变量</li><li>BSS段：未初始化的全局变量和未初始化的static变量，初始化为0的全局变量和初始化为0的static变量</li><li>上述描述的证明程序及截图见下面有关注释。</li></ul></li><li>有外部链接、内部链接、无链接3种<ul><li>静态外部链接：全局变量（一个文件定义，其它文件<code>extern</code>引入声明)</li><li>静态内部链接：static 全局变量（只能定义所在的翻译单元使用）</li><li>静态无链接：static 局部变量（只能在定义所在的代码块内使用）</li></ul></li></ul></li><li>动态存储持续性<ul><li>用new申请的内存会一直存在，直到使用delete进行释放</li></ul></li><li>线程持续性：C++11引入<ul><li>使用<code>thread_local</code>声明，则其生命周期与所属的线程一样长</li></ul></li></ul><h2 id="有关.bss和.data注释">有关.bss和.data注释</h2><p>bss段和data段存储变量验证： 程序： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 这段代码看起来不够规范，例如没有include &lt;iostream&gt;</span><br><span class="hljs-comment">* 也没有return 0;  但我是故意的,尽量不要引入多余参数和操作有利于我们分析</span><br><span class="hljs-comment">* 如果include &lt;iostream&gt; 会导致.bss段多出一个不知道干嘛的数据</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> global_not_init;<span class="hljs-comment">//.BSS</span><br><span class="hljs-type">int</span> global_init_not_zero=<span class="hljs-number">1</span>;<span class="hljs-comment">//.DATA</span><br><span class="hljs-type">int</span> global_init_zero=<span class="hljs-number">0</span>;<span class="hljs-comment">//.BSS</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_global_not_init;<span class="hljs-comment">//.BSS</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_global_init_not_zero=<span class="hljs-number">2</span>;<span class="hljs-comment">//.DATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_global_init_zero=<span class="hljs-number">0</span>;<span class="hljs-comment">//.BSS</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_local_not_init;<span class="hljs-comment">//.BSS</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_local_init_not_zero=<span class="hljs-number">3</span>;<span class="hljs-comment">//.DATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> static_local_init_zero=<span class="hljs-number">0</span>;<span class="hljs-comment">//.BSS</span><br>&#125;<br></code></pre></td></tr></table></figure><code>g++ -c bss.cpp -o bss.o</code> <code>objdump -x bss.o</code>结果如下： <imgsrc="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303251729547.png"alt="image.png" /></p><p>总结：初始化为非0的全局变量和初始化为非0的static变量存在.data区，其它在.bss区</p><p>bss段并不给该段的数据分配空间。程序运行后，系统给bss段的变量分配空间并自动初始化为0.</p><p>sectiontable(节头表)中保存了bss段变量需要内存空间的大小总和，因此系统知道要分配多少内存该bss段。</p><p><code>objdump -h bss.o</code>.data段有3个int变量，故为12，.bss段有6个int故为24。（截图中数字为16进制）</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/XingpanLuo/PictureBed/BlogImag202303251728729.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="补充c-函数存储位置">补充C++ 函数存储位置</h2><ul><li><p>C++ 中，函数的定义放在代码区，包括类成员函数和一般函数。</p></li><li><p>类的成员函数不计入内存空间，这里的成员函数包括一般的、static的、内联的等。</p></li><li><p>但类中存在存在虚函数时，就需要维护一个指向虚函数表的指针。虚函数表详细内容系列2再来讨论。</p></li></ul><p>一个疑惑：类中没有函数信息，那类是怎么找到函数的呢？</p><ul><li>这个问题本身就有问题，不是类找到函数，而是函数找到类</li><li>当我们执行<code>classA.func(a,b)</code>时，可以不那么严谨的认为执行了<code>func(&amp;classA,a,b)</code></li></ul><h2 id="作用域">作用域</h2><p>作用域，即一个变量可以被引用的范围</p><ul><li><p>文件作用域（全局作用域）：在函数和代码块之外声明的变量具有全局作用域</p></li><li><p>局部作用域：在函数内部声明的变量具有局部作用域</p></li><li><p>在代码块内声明的变量具有块作用域。如for循环中声明的临时变量</p></li><li><p>类作用域：在类内部声明的变量。</p><p>变量的作用域不会因为加了static或const而改变。部分博客认为static将全局变量的作用域改变了，我认为这种描述不好，这种说法大概是认为该变量的作用域由“多个文件“变为了”一个文件“，但我更偏向于认为，”一个文件“就是最大的作用域，其余的文件也是需要extern引入声明后才获得了作用域的。这颇有点咬文嚼字的感觉，但我依然喜欢以下的表述：static将全局变量的链接性由外部链接缩小为内部链接，但作用域仍然是一个文件。const也能将全局变量的链接性由外部链接缩小为内部链接。同样作用域仍然是一个文件## 链接性 多个文件间的共享性质称为链接性。</p></li><li><p>自动存储类型无链接性（自动变量没有链接性）</p></li><li><p>静态存储类型有外部链接、内部链接、无链接3种</p><ul><li>静态外部链接：全局变量（一个文件定义，其它文件<code>extern</code>引入声明)</li><li>静态内部链接：static 全局变量（只能定义所在的翻译单元使用）</li><li>静态无链接：static 局部变量（只能在定义所在的代码块内使用）</li></ul></li><li><p>动态存储类型无链接性。指针可以是自动的或静态的，但指针所指向的用new申请的区域没有讨论链接性的意义。</p></li></ul><table><thead><tr><th>存储描述</th><th>持续性</th><th>作用域</th><th>链接性</th><th>如何声明</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>代码块</td><td>无</td><td>在代码块中</td></tr><tr><td>静态，无链接</td><td>静态</td><td>代码块</td><td>无</td><td>在代码块中,使用static</td></tr><tr><td>静态，内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>函数和代码块之外，用static</td></tr><tr><td>静态，外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>函数和代码块之外</td></tr></tbody></table><h2 id="static">static</h2><ul><li>static 对全局变量<ul><li>将其由外部链接性缩减为内部链接性</li></ul></li><li>static 对普通函数<ul><li>将其由外部链接性缩减为内部链接性。不能被其它文件链接到</li></ul></li><li>static 对局部变量<ul><li>将其存储持续性（生命周期）由自动变为静态。即该变量会一直存在直到程序结束。</li></ul></li><li>static 类成员变量：<ul><li>所有该类的对象共享一个变量</li><li>若初始化为非0，存储在data段；否则在BSS段</li><li><code>const static int</code>可以在类内进行初始化，其它都要在类外初始化。</li><li>类外初始化 方法： <code>类名::变量名=初值</code></li><li>访问方式：<code>类名::变量名。或者 对象.变量名</code></li></ul></li><li>static 类成员函数<ul><li>管理static类成员变量</li><li><code>类名::成员函数 。对象.成员函数</code></li><li>没有this指针，只能调用static的数据和static成员函数。</li></ul></li></ul><p>C语言的static变量会在编译期进行初始化，程序中有初始化为非0的，初始化为响应的值，否则初始化为0.</p><p>而C++由于引入了类和对象，对象的初始化需要调用构造函数，并不像C语言的初始化那么简单，因此C++规定所有的全局变量和static变量（也就是静态持续性变量）需要在首次使用时才进行初始化。</p>]]></content>
    
    
    <categories>
      
      <category>CPP困惑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 基础指令</title>
    <link href="/2023/03/25/Linux/Linux%20%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/03/25/Linux/Linux%20%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="近期使用到的命令">近期使用到的命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将a.cpp的内容复制到剪切板。结合windows与虚拟机的共享剪切板很好用</span><br><span class="hljs-built_in">cat</span> a.cpp | xclip -sel clip<br><span class="hljs-comment">#objdump 查看.o文件</span><br><span class="hljs-comment">#查看.data段,.bss段有多大</span><br>objdump -h a.o <br><span class="hljs-comment">#查看.data段和.bss段存放了哪些内容</span><br>objdump -x a.o<br><span class="hljs-comment">#将一篇很长的文件筛选出部分信息</span><br><span class="hljs-comment">#-E 为使用完全的正则表达式</span><br><span class="hljs-comment">#[system] 出现行及其下面两行。[system.cpu]出现的行及其下面两行</span><br>grep -E <span class="hljs-string">&quot;^\[(\w*)\]$|^\[(\w*)\.(\w*)\]$&quot;</span> -A 2 a.txt<br><br></code></pre></td></tr></table></figure><ul><li>whoami 显示当前登录的用户</li><li>hostname 显示当前机器的主机名</li><li>pwd 显示当前的工作目录绝对路劲 <a name="goNBT"></a> ## cd命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">.   当前目录<br>..  上一级目录<br>/   根目录<br>~   用户目录<br>-   上一次工作目录<br><br></code></pre></td></tr></table></figure> <a name="OR86w"></a> ## ls命令 : 打印目录文件及文件夹信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> [选项] [路径]<br><span class="hljs-built_in">ls</span> -a  显示隐藏文件<br><span class="hljs-built_in">ls</span> -l   显示详细信息<br><span class="hljs-built_in">ls</span> -hl  显示详细信息，包括人类可读的内存占用<br></code></pre></td></tr></table></figure> <a name="COQAK"></a> ## su切换用户<code>su - 用户名</code> <a name="IHYp0"></a> ##logout退出当前用户登录 <code>logout</code> <a name="mUsEq"></a> ## mkdir新建文件夹 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> [选项] [目录]<br><span class="hljs-built_in">mkdir</span> dir1创建文件夹<br><span class="hljs-built_in">mkdir</span> &#123;dir1,dir2,dir3&#125;创建多个文件夹<br><span class="hljs-built_in">mkdir</span> -p ./dir1/dir2/dir3 就算没有dir1,dir2，也可以递归创建出dir1,dir2,dir3<br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span>&#123;1..10&#125;   创建10个文件夹dir1,dir2,...,dir10<br></code></pre></td></tr></table></figure> <a name="wCQGf"></a> ## touch创建普通文件、修改文件事件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> [选项] [文件名]<br><span class="hljs-built_in">touch</span> a.txt b.py c.cpp<br><span class="hljs-built_in">touch</span> text&#123;a..z&#125;.txt  main&#123;1..3&#125;.cpp<br><span class="hljs-built_in">touch</span> -t 03160910 a.txt 修改文件的修改时间为3月16日9点10分<br></code></pre></td></tr></table></figure> <a name="Pv1Vo"></a> ## cp 复制<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> [选项] 源文件 目标文件<br><span class="hljs-built_in">cp</span> a.txt b.cpp c.py ./dir/复制多个文件到目标文件夹<br><span class="hljs-built_in">cp</span> -r dir1 dir2 复制整个文件夹需要加上-r参数<br><span class="hljs-built_in">cp</span> -d a.out b.out 复制，保存软连接不变<br><span class="hljs-built_in">cp</span> -i 复制前询问，防止意外覆盖<br></code></pre></td></tr></table></figure> <a name="jL2Dm"></a> ## mv 移动文件、重命名文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> [选项] [一个或多个源文件] 目标文件或目录<br><span class="hljs-built_in">mv</span> a.txt b.cpp ./dir/  移动一个或多个文件到目标目录<br><span class="hljs-built_in">mv</span> *.cpp ./dir/ <br><span class="hljs-built_in">mv</span> a.txt aa.txt 重命名文件<br></code></pre></td></tr></table></figure> <a name="vsPL2"></a> ## rm 删除 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [选项] 文件<br><span class="hljs-built_in">rm</span> a.txt 删除文件<br><span class="hljs-built_in">rm</span> a.txt b.txt<br><span class="hljs-built_in">rm</span> text*.txt  <br><span class="hljs-built_in">rm</span> -r <span class="hljs-built_in">dir</span> 递归删除目录<br><span class="hljs-built_in">rm</span> -d dir0 只能用来删除空文件夹<br><span class="hljs-built_in">rm</span> -f abb* 强制删除所有以abb开头的文件<br><span class="hljs-built_in">rm</span> -r -f ./*   强制删除当前目录下的所有内容<br></code></pre></td></tr></table></figure><a name="o0Mey"></a> ## 终端快捷键 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctrl+a 回到命令行开头<br>ctrl+e 命令行结尾<br>ctrl+l 清空<br>ctrl+d 从光标出删除一个字符<br></code></pre></td></tr></table></figure> <a name="WfYQy"></a> ##重定向符号 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.读取文件内容，写入另一个文件中<br><span class="hljs-built_in">cat</span> src.txt &gt; dest.txt重定向输出覆盖<br><span class="hljs-built_in">cat</span> src.txt &gt;&gt; dest.txt 重定向追加<br>2.重定向写入符<br><span class="hljs-built_in">cat</span> &lt; src.txt  <br>将文本内容拆分<br>xargs -n 3 &lt; src.txt 限制每行只能输出3个字符<br><span class="hljs-built_in">cat</span> &gt;&gt; dest.txt &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">cat -n a.txt 显示行号，参数-n</span><br></code></pre></td></tr></table></figure> <a name="StbNt"></a> ## cat 查看文本内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看文本内容<br><span class="hljs-built_in">cat</span> file.txt<br>-b 对非空行显示行号<br>-n 对所有行显示行号<br>2. 多个文件合并<br><span class="hljs-built_in">cat</span> file1.txt file2.txt &gt; file3.txt<br>3.非交互式编辑或追加内容<br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; <span class="hljs-string">EOF 这是追加内容 EOF</span><br>4.清空文件内容<br><span class="hljs-built_in">cat</span> /dev/null &gt; file.txt<br><br></code></pre></td></tr></table></figure> <a name="Q3qws"></a> ## head 查看文件开头几行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> a.txt  查看前10行<br><span class="hljs-built_in">head</span> -n 5 a.txt 查看前5行<br><span class="hljs-built_in">head</span> -n -5 a.txt 查看倒数第5行之前所有<br></code></pre></td></tr></table></figure> <a name="LYV36"></a> ## tail 查看文件末尾几行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">能实时刷新显示a.txt的末尾变化<br><span class="hljs-built_in">tail</span> -F a.txt<br></code></pre></td></tr></table></figure> <a name="llDrz"></a> ## stat 查看文件详细信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看文件详细信息<br>-f : 显示文件系统状态而非文件状态<br>-t : 以简洁方式输出<br></code></pre></td></tr></table></figure> <a name="vaq5n"></a> ## chmod 权限设置 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">r,w,x : 读、写、执行<br>用户-用户所在组-所有<br>111=7 可读可写可执行<br>110=6 可读可写不可执行<br>010=2 只可写<br><span class="hljs-built_in">chmod</span> 777 a.txt <br></code></pre></td></tr></table></figure><a name="ZKXQ0"></a> ## find 查找 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">find 路径 选项 文件名<br>搜索*.txt与*.cpp 但过滤a.*<br>-a 与；-o 或；-not 非<br>！！！注意空格！！！每个\(或\)的左后两边都要有空格。指令与指令之间也要有空格<br>find . \( -not -name <span class="hljs-string">&quot;a.*&quot;</span> \) -a \( -name <span class="hljs-string">&quot;*.txt&quot;</span> -o -name <span class="hljs-string">&quot;*.cpp&quot;</span> \) <br>根据正则表达式查找<br>find . -regex <span class="hljs-string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span><br>-ok 执行后面的指令，并询问是否确定执行&#123;&#125; 中的是find找到的内容 <br>-<span class="hljs-built_in">exec</span> 执行后面的指令，不询问<br>注意以\;结尾<br>删除*.txt并逐一询问是否确定删除<br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -ok <span class="hljs-built_in">rm</span> &#123;&#125; \;<br>合并所有*.txt到all.txt<br>find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.txt&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cat</span> &#123;&#125; &gt; all.txt \;<br>-<span class="hljs-built_in">type</span> f 文件 -<span class="hljs-built_in">type</span> d 文件夹<br>将30天前的<span class="hljs-built_in">log</span>文件移动到old目录<br>find . -<span class="hljs-built_in">type</span> f -mtime +30 -name <span class="hljs-string">&quot;*.log&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cp</span> &#123;&#125; old \;<br>-atime 访问时间<br>-ctime 改变事件 +30超过30天，-5 5天内，5 正好5天前<br></code></pre></td></tr></table></figure> <a name="Sr17b"></a> ##通配符 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">? 匹配一个任意字符<br>* 匹配0个或多个任意字符<br>[] 匹配中括号中的任意一个字符，例如[abc]匹配a或b或c<br>[a-m] [2-4] 匹配范围内的任意一个字符<br>[^] 逻辑非。例如[a^1-9].txt   匹配a.txt,但不匹配a1.txt,a2.txt<br>^ 匹配行首<br>$ 匹配行尾<br></code></pre></td></tr></table></figure> <a name="arZ3I"></a> ## grep 搜索匹配并打印<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">在文件内搜索匹配<br>grep <span class="hljs-string">&quot;match_pattern&quot;</span> file1.txt file2.txt<br>递归搜索当前目录及所有子目录中的问价<br>grep -r <span class="hljs-string">&quot;match_pattern&quot;</span><br>正则匹配输出以数字开头的所有行<br>grep <span class="hljs-string">&quot;^[0-9].*&quot;</span> file.txt<br></code></pre></td></tr></table></figure> <a name="HEj5C"></a> ## tar 压缩和解压缩 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#=======================&quot;.tar&quot;格式=========================</span><br><span class="hljs-comment">#打包不会压缩</span><br>tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg<br><span class="hljs-comment">#解打包到当前目录</span><br>tar -xvf anaconda-ks.cfg.tar<br><span class="hljs-comment">#解打包到指定目录</span><br>tar -xvf anaconda-ks.cfg.tar -C /testdir/<br><br><span class="hljs-comment">#=====================&quot;.tar.gz&quot;格式=====================</span><br><span class="hljs-comment">#把/tmp/目录直接打包并压缩为&quot;.tar.gz&quot;格式</span><br>tar -zcvf tmp.tar.gz /tmp/<br><span class="hljs-comment">#解压缩并解打包&quot;.tar.gz&quot;格式文件</span><br>tar -zxvf tmp.tar.gz<br></code></pre></td></tr></table></figure><a name="KsbWb"></a> ## cut 分割 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.txt的每行的第4-7个字符<br><span class="hljs-built_in">cut</span> -c 4-7 a.txt<br><span class="hljs-built_in">cut</span> -c 5,6 a.txt 每行的第5个和第6个字符<br><span class="hljs-built_in">cut</span> -c -6 a.txt 每行的前6个字符<br>a.txt每行用:分割。取出分割结果的1-3个<br><span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f 1-3 a.txt<br><span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f 3- a.txt 分割结果的第三个到最后<br></code></pre></td></tr></table></figure> <a name="hMHfX"></a> ##paste 合并 与cut相反 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">两个文件按列合并<br><span class="hljs-built_in">paste</span> a.txt b.txt<br>按列合并，并用 : 连接<br><span class="hljs-built_in">paste</span> -d <span class="hljs-string">&quot;:&quot;</span> a.txt b.txt<br></code></pre></td></tr></table></figure> <a name="D7hDp"></a> ## sort 排序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.对文件进行排序<br><span class="hljs-built_in">sort</span> a.txt 数字排在前面，字母排在后面<br><span class="hljs-built_in">sort</span> -r a.txt 逆序（从大到小）<br>2. 对文件每行按照第一个字符按照数字排序。如果第一个字符不是数字，就认为是数字0<br><span class="hljs-built_in">sort</span> -n a.txt 默认从小到大排序<br><span class="hljs-built_in">sort</span> -nr a.txt 从大到小排序<br>3.对排序结果去重<br><span class="hljs-built_in">sort</span> -u a.txt<br>4.指定分割符号,指定区域进行排序<br><span class="hljs-built_in">sort</span> -n -t <span class="hljs-string">&quot;.&quot;</span> -k 4 ip.txt<br></code></pre></td></tr></table></figure> <a name="fOoXm"></a> ## uniq 去重 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.去除连续出现的行<br><span class="hljs-built_in">uniq</span> a.txt<br><span class="hljs-built_in">uniq</span> -c a.txt 显示重复出现的次数<br>2.一般结合<span class="hljs-built_in">sort</span>使用<br><span class="hljs-built_in">sort</span> -n a.txt | <span class="hljs-built_in">uniq</span> -c<br>3.找出只出现一次的行<br><span class="hljs-built_in">sort</span> -n a.txt | <span class="hljs-built_in">uniq</span> -c -u<br></code></pre></td></tr></table></figure><a name="v5hCo"></a> ## wc 单词统计 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.统计文件的行数<br><span class="hljs-built_in">wc</span> -l a.txt<br>2.统计单词数量<br><span class="hljs-built_in">wc</span> -w a.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test1 test2&quot;</span> | <span class="hljs-built_in">wc</span> -w 结果为2两个单词<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;好 啊 不好&quot;</span> | <span class="hljs-built_in">wc</span> -w 结果为3<br>3.统计字符数(包括结尾的$符号<br><span class="hljs-built_in">wc</span> -m a.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test&quot;</span> | <span class="hljs-built_in">wc</span> -m  结果为5<br>4.输出最长行的字符数<br><span class="hljs-built_in">cat</span> a.txt | <span class="hljs-built_in">wc</span> -L<br></code></pre></td></tr></table></figure> <a name="JwKbv"></a>## tr 从标准输入中替换、所见或删除字符，将结果写到标准输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 替换一部分字符<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;my name is lumos&quot;</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[a-z]&#x27;</span> <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br><span class="hljs-comment">#MY NAME IS LUMOS</span><br>2.删除一部分字符 -d 选项<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;my name is lumos and i an 21 years old&quot;</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;a-z&#x27;</span><br><span class="hljs-comment">#21</span><br>3.把文件中的内容进行替换(把文件当作标准输入<br><span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt; a.txt<br>4.去除连续重复字符 -s选项<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;iii am lllumoos&quot;</span> | <span class="hljs-built_in">tr</span> -s  <span class="hljs-string">&#x27;ialo&#x27;</span><br><span class="hljs-comment">#i am lumos</span><br></code></pre></td></tr></table></figure> <a name="UZMmi"></a> ## xargs 管道命令，构造参数等简单的说就是，把其它命令给他的数据，传递给它后面的命令作为参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.txt:<br>1 2<br>3 4 5<br>1.多行连接输出<br>xargs &lt; a.txt<br><span class="hljs-comment">#1 2 3 4 5 </span><br>2.-n 每行最多输出原来的n行<br>xargs -n &lt; a.txt<br>3. -d 分割<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a,b,c&quot;</span> | xargs -d <span class="hljs-string">&quot;,&quot;</span> -n 2<br>3. -i &#123;&#125;替代传输的数据<br>将当前所有的txt文件，移动到<span class="hljs-built_in">dir</span>目录<br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> | xargs -i <span class="hljs-built_in">mv</span> &#123;&#125; <span class="hljs-built_in">dir</span>/<br>4. -I 用字符串替换数据<br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> | xargs -I alltxt <span class="hljs-built_in">mv</span> alltxt <span class="hljs-built_in">dir</span>/<br></code></pre></td></tr></table></figure> <a name="j9Hxv"></a> ## join 合并 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">只能对排序好的文件使用<br>将两个文件，按照某列为匹配字段进行合并<br>依照a文件的ID1段和b文件ID2段进行合并,指定分隔符为<span class="hljs-string">&quot; &quot;</span> <br><span class="hljs-built_in">join</span> -1 ID1 -2 ID2 -t <span class="hljs-string">&quot; &quot;</span> a.txt b.txt &gt; c.txt<br>a.txt<br>zhou 2000 1<br>li 2500 2<br>wan 2000 2<br>zhan 2600 2<br>b.txt <br>zhou c 1<br>zhan java 2<br>wan php 3<br><br>c.txt<br>1 zhou 2000 zhou c<br>2 li 2500 zhan java<br>2 wan 2000 zhan java<br>2 zhan 2600 zhan java<br></code></pre></td></tr></table></figure><a name="pi9eA"></a> ## comm 比较文件内容 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 比较文件内容<br><span class="hljs-built_in">comm</span> a.txt b.txt<br>-1 不输出文件1特有的行<br>-2 不输出文件2特有的行<br>-3 不输出两个文件共有的行<br>2.只显示两个文件共有部分<br><span class="hljs-built_in">comm</span> -12 a.txt b.txt<br></code></pre></td></tr></table></figure><a name="EI20q"></a> ## diff 比较文件不同 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">diff a.txt b.txt<br>-c 上下文模式，显示全部内文，并标出不同之处<br>-u 统一模式，以合并的方式来显示文件内容的不同<br></code></pre></td></tr></table></figure><a name="peBXG"></a> ## df 查看磁盘占用情况 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span>是disk free的缩写<br><span class="hljs-built_in">df</span> [选项] 文件（磁盘）<br>1.显示磁盘使用情况<br><span class="hljs-built_in">df</span><br>2. 以inode模式显示<br><span class="hljs-built_in">df</span> -i<br>3.列出文件系统的类型<br><span class="hljs-built_in">df</span> -T<br></code></pre></td></tr></table></figure><a name="uoXcJ"></a> ## du 查看文件和目录的占用情况 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a 显示目录中所有文件的大小<br>-h 以K,M,G为单位，提高信息可读性<br>-c 显示综合<br><span class="hljs-built_in">du</span> -h a.txt 文件a.txt的占用<br><span class="hljs-built_in">du</span> -ch a.txt b.txt 两个文件的占用及其总和<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
